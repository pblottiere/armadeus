The IPU is the Image Processing Unit found on i.MX50/51/53 SoCs. It
features several units for image processing, this patch adds support
for the units needed for Framebuffer support, namely:

- Display Controller (dc)
- Display Interface (di)
- Display Multi Fifo Controller (dmfc)
- Display Processor (dp)
- Image DMA Controller (idmac)

This patch is based on the Freescale driver, but follows a different
approach. The Freescale code implements logical idmac channels and
the handling of the subunits is hidden in common idmac code pathes
in big switch/case statements. This patch instead just provides code
and resource management for the different subunits. The user, in this
case the framebuffer driver, decides how the different units play
together.

The IPU has other units missing in this patch:

- CMOS Sensor Interface (csi)
- Video Deinterlacer (vdi)
- Sensor Multi FIFO Controler (smfc)
- Image Converter (ic)
- Image Rotator (irt)

So expect more files to come in this directory.

Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
---
 arch/arm/plat-mxc/include/mach/ipu-v3.h |   49 +++
 drivers/mfd/Kconfig                     |    7 +
 drivers/mfd/Makefile                    |    1 +
 drivers/mfd/imx-ipu-v3/Makefile         |    3 +
 drivers/mfd/imx-ipu-v3/ipu-common.c     |  708 +++++++++++++++++++++++++++++++
 drivers/mfd/imx-ipu-v3/ipu-cpmem.c      |  612 ++++++++++++++++++++++++++
 drivers/mfd/imx-ipu-v3/ipu-dc.c         |  364 ++++++++++++++++
 drivers/mfd/imx-ipu-v3/ipu-di.c         |  550 ++++++++++++++++++++++++
 drivers/mfd/imx-ipu-v3/ipu-dmfc.c       |  355 ++++++++++++++++
 drivers/mfd/imx-ipu-v3/ipu-dp.c         |  476 +++++++++++++++++++++
 drivers/mfd/imx-ipu-v3/ipu-prv.h        |  216 ++++++++++
 include/linux/mfd/imx-ipu-v3.h          |  219 ++++++++++
 12 files changed, 3560 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-mxc/include/mach/ipu-v3.h
 create mode 100644 drivers/mfd/imx-ipu-v3/Makefile
 create mode 100644 drivers/mfd/imx-ipu-v3/ipu-common.c
 create mode 100644 drivers/mfd/imx-ipu-v3/ipu-cpmem.c
 create mode 100644 drivers/mfd/imx-ipu-v3/ipu-dc.c
 create mode 100644 drivers/mfd/imx-ipu-v3/ipu-di.c
 create mode 100644 drivers/mfd/imx-ipu-v3/ipu-dmfc.c
 create mode 100644 drivers/mfd/imx-ipu-v3/ipu-dp.c
 create mode 100644 drivers/mfd/imx-ipu-v3/ipu-prv.h
 create mode 100644 include/linux/mfd/imx-ipu-v3.h

diff --git a/arch/arm/plat-mxc/include/mach/ipu-v3.h b/arch/arm/plat-mxc/include/mach/ipu-v3.h
new file mode 100644
index 0000000..f8900b9
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/ipu-v3.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#ifndef __MACH_IPU_V3_H_
+#define __MACH_IPU_V3_H_
+
+/* IPU specific extensions to struct fb_videomode flag field */
+#define FB_SYNC_OE_LOW_ACT	(1 << 8)
+#define FB_SYNC_CLK_LAT_FALL	(1 << 9)
+#define FB_SYNC_DATA_INVERT	(1 << 10)
+#define FB_SYNC_CLK_IDLE_EN	(1 << 11)
+#define FB_SYNC_SHARP_MODE	(1 << 12)
+#define FB_SYNC_SWAP_RGB	(1 << 13)
+
+struct ipuv3_fb_platform_data {
+	const struct fb_videomode	*modes;
+	int				num_modes;
+	char				*mode_str;
+	u32				interface_pix_fmt;
+
+#define IMX_IPU_FB_USE_MODEDB	(1 << 0)
+#define IMX_IPU_FB_USE_OVERLAY	(1 << 1)
+	unsigned long			flags;
+
+	int				ipu_channel_bg;
+	int				ipu_channel_fg;
+	int				dc_channel;
+	int				dp_channel;
+	int				display;
+};
+
+struct imx_ipuv3_platform_data {
+	int rev;
+	struct ipuv3_fb_platform_data	*fb_head0_platform_data;
+	struct ipuv3_fb_platform_data	*fb_head1_platform_data;
+};
+
+#endif /* __MACH_IPU_V3_H_ */
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 3a1493b..3c81879 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -624,6 +624,13 @@ config MFD_VX855
 	  driver connects the radio-wl1273 V4L2 module and the wl1273
 	  audio codec.
 
+config MFD_IMX_IPU_V3
+	tristate "Support the Image Processing Unit (IPU) found on the i.MX51"
+	depends on ARCH_MX51
+	select MFD_CORE
+	help
+	  Say yes here to support the IPU on i.MX51.
+
 endif # MFD_SUPPORT
 
 menu "Multimedia Capabilities Port drivers"
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index f54b365..7873b13 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -83,3 +83,4 @@ obj-$(CONFIG_MFD_JANZ_CMODIO)	+= janz-cmodio.o
 obj-$(CONFIG_MFD_VX855)		+= vx855.o
 obj-$(CONFIG_MFD_WL1273_CORE)	+= wl1273-core.o
 obj-$(CONFIG_MFD_CS5535)	+= cs5535-mfd.o
+obj-$(CONFIG_MFD_IMX_IPU_V3)	+= imx-ipu-v3/
diff --git a/drivers/mfd/imx-ipu-v3/Makefile b/drivers/mfd/imx-ipu-v3/Makefile
new file mode 100644
index 0000000..ff70fe8
--- /dev/null
+++ b/drivers/mfd/imx-ipu-v3/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_MFD_IMX_IPU_V3) += imx-ipu-v3.o
+
+imx-ipu-v3-objs := ipu-common.o ipu-dc.o ipu-di.o ipu-dp.o ipu-dmfc.o ipu-cpmem.o
diff --git a/drivers/mfd/imx-ipu-v3/ipu-common.c b/drivers/mfd/imx-ipu-v3/ipu-common.c
new file mode 100644
index 0000000..d96245f
--- /dev/null
+++ b/drivers/mfd/imx-ipu-v3/ipu-common.c
@@ -0,0 +1,708 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/mfd/imx-ipu-v3.h>
+#include <linux/clk.h>
+#include <linux/list.h>
+#include <mach/common.h>
+#include <linux/mfd/core.h>
+#include <mach/ipu-v3.h>
+
+#include "ipu-prv.h"
+
+static struct clk *ipu_clk;
+static struct device *ipu_dev;
+
+static DEFINE_SPINLOCK(ipu_lock);
+static DEFINE_MUTEX(ipu_channel_lock);
+void __iomem *ipu_cm_reg;
+void __iomem *ipu_idmac_reg;
+
+static int ipu_use_count;
+
+static struct ipu_channel channels[64];
+
+struct ipu_channel *ipu_idmac_get(unsigned num)
+{
+	struct ipu_channel *channel;
+
+	dev_dbg(ipu_dev, "%s %d\n", __func__, num);
+
+	if (num > 63)
+		return ERR_PTR(-ENODEV);
+
+	mutex_lock(&ipu_channel_lock);
+
+	channel = &channels[num];
+
+	if (channel->busy) {
+		channel = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	channel->busy = 1;
+	channel->num = num;
+
+out:
+	mutex_unlock(&ipu_channel_lock);
+
+	return channel;
+}
+EXPORT_SYMBOL(ipu_idmac_get);
+
+void ipu_idmac_put(struct ipu_channel *channel)
+{
+	dev_dbg(ipu_dev, "%s %d\n", __func__, channel->num);
+
+	mutex_lock(&ipu_channel_lock);
+
+	channel->busy = 0;
+
+	mutex_unlock(&ipu_channel_lock);
+}
+EXPORT_SYMBOL(ipu_idmac_put);
+
+void ipu_idmac_set_double_buffer(struct ipu_channel *channel, bool doublebuffer)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&ipu_lock, flags);
+
+	reg = ipu_cm_read(IPU_CHA_DB_MODE_SEL(channel->num));
+	if (doublebuffer)
+		reg |= idma_mask(channel->num);
+	else
+		reg &= ~idma_mask(channel->num);
+	ipu_cm_write(reg, IPU_CHA_DB_MODE_SEL(channel->num));
+
+	spin_unlock_irqrestore(&ipu_lock, flags);
+}
+EXPORT_SYMBOL(ipu_idmac_set_double_buffer);
+
+int ipu_module_enable(u32 mask)
+{
+	unsigned long lock_flags;
+	u32 ipu_conf;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	ipu_conf = ipu_cm_read(IPU_CONF);
+	ipu_conf |= mask;
+	ipu_cm_write(ipu_conf, IPU_CONF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+
+int ipu_module_disable(u32 mask)
+{
+	unsigned long lock_flags;
+	u32 ipu_conf;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	ipu_conf = ipu_cm_read(IPU_CONF);
+	ipu_conf &= ~mask;
+	ipu_cm_write(ipu_conf, IPU_CONF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+
+void ipu_idmac_select_buffer(struct ipu_channel *channel, u32 buf_num)
+{
+	unsigned int chno = channel->num;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ipu_lock, flags);
+
+	/* Mark buffer as ready. */
+	if (buf_num == 0)
+		ipu_cm_write(idma_mask(chno), IPU_CHA_BUF0_RDY(chno));
+	else
+		ipu_cm_write(idma_mask(chno), IPU_CHA_BUF1_RDY(chno));
+
+	spin_unlock_irqrestore(&ipu_lock, flags);
+}
+EXPORT_SYMBOL(ipu_idmac_select_buffer);
+
+int ipu_idmac_enable_channel(struct ipu_channel *channel)
+{
+	u32 val;
+	unsigned long flags;
+
+	ipu_get();
+
+	spin_lock_irqsave(&ipu_lock, flags);
+
+	val = ipu_idmac_read(IDMAC_CHA_EN(channel->num));
+	val |= idma_mask(channel->num);
+	ipu_idmac_write(val, IDMAC_CHA_EN(channel->num));
+
+	spin_unlock_irqrestore(&ipu_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_idmac_enable_channel);
+
+int ipu_idmac_disable_channel(struct ipu_channel *channel)
+{
+	u32 val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ipu_lock, flags);
+
+	/* Disable DMA channel(s) */
+	val = ipu_idmac_read(IDMAC_CHA_EN(channel->num));
+	val &= ~idma_mask(channel->num);
+	ipu_idmac_write(val, IDMAC_CHA_EN(channel->num));
+
+	/* Set channel buffers NOT to be ready */
+	ipu_cm_write(0xf0000000, IPU_GPR); /* write one to clear */
+
+	if (ipu_idma_is_set(IPU_CHA_BUF0_RDY, channel->num)) {
+		ipu_cm_write(idma_mask(channel->num),
+			     IPU_CHA_BUF0_RDY(channel->num));
+	}
+	if (ipu_idma_is_set(IPU_CHA_BUF1_RDY, channel->num)) {
+		ipu_cm_write(idma_mask(channel->num),
+			     IPU_CHA_BUF1_RDY(channel->num));
+	}
+
+	ipu_cm_write(0x0, IPU_GPR); /* write one to set */
+
+	/* Reset the double buffer */
+	val = ipu_cm_read(IPU_CHA_DB_MODE_SEL(channel->num));
+	val &= ~idma_mask(channel->num);
+	ipu_cm_write(val, IPU_CHA_DB_MODE_SEL(channel->num));
+
+	spin_unlock_irqrestore(&ipu_lock, flags);
+
+	ipu_put();
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_idmac_disable_channel);
+
+static LIST_HEAD(ipu_irq_handlers);
+
+static void ipu_irq_update_irq_mask(void)
+{
+	struct ipu_irq_handler *handler;
+	int i;
+
+	DECLARE_IPU_IRQ_BITMAP(irqs);
+
+	bitmap_zero(irqs, IPU_IRQ_COUNT);
+
+	list_for_each_entry(handler, &ipu_irq_handlers, list)
+		bitmap_or(irqs, irqs, handler->ipu_irqs, IPU_IRQ_COUNT);
+
+	for (i = 0; i < BITS_TO_LONGS(IPU_IRQ_COUNT); i++)
+		ipu_cm_write(irqs[i], IPU_INT_CTRL(i + 1));
+}
+
+int ipu_irq_add_handler(struct ipu_irq_handler *ipuirq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ipu_lock, flags);
+
+	list_add_tail(&ipuirq->list, &ipu_irq_handlers);
+	ipu_irq_update_irq_mask();
+
+	spin_unlock_irqrestore(&ipu_lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_irq_add_handler);
+
+void ipu_irq_remove_handler(struct ipu_irq_handler *handler)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ipu_lock, flags);
+
+	list_del(&handler->list);
+	ipu_irq_update_irq_mask();
+
+	spin_unlock_irqrestore(&ipu_lock, flags);
+}
+EXPORT_SYMBOL(ipu_irq_remove_handler);
+
+int ipu_irq_update_handler(struct ipu_irq_handler *handler,
+		unsigned long *bitmap)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ipu_lock, flags);
+
+	bitmap_copy(handler->ipu_irqs, bitmap, IPU_IRQ_COUNT);
+	ipu_irq_update_irq_mask();
+
+	spin_unlock_irqrestore(&ipu_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_irq_update_handler);
+
+static void ipu_completion_handler(unsigned long *bitmask, void *context)
+{
+	struct completion *completion = context;
+
+	complete(completion);
+}
+
+int ipu_wait_for_interrupt(int interrupt, int timeout_ms)
+{
+	struct ipu_irq_handler handler;
+	DECLARE_COMPLETION_ONSTACK(completion);
+	int ret;
+
+	bitmap_zero(handler.ipu_irqs, IPU_IRQ_COUNT);
+	bitmap_set(handler.ipu_irqs, interrupt, 1);
+
+	ipu_cm_write(1 << (interrupt % 32), IPU_INT_STAT(interrupt / 32 + 1));
+
+	handler.handler = ipu_completion_handler;
+	handler.context = &completion;
+	ipu_irq_add_handler(&handler);
+
+	ret = wait_for_completion_timeout(&completion,
+			msecs_to_jiffies(timeout_ms));
+
+	ipu_irq_remove_handler(&handler);
+
+	if (ret > 0)
+		ret = 0;
+	else
+		ret = -ETIMEDOUT;
+
+	return ret;
+}
+EXPORT_SYMBOL(ipu_wait_for_interrupt);
+
+static irqreturn_t ipu_irq_handler(int irq, void *desc)
+{
+	DECLARE_IPU_IRQ_BITMAP(status);
+	struct ipu_irq_handler *handler;
+	int i;
+
+	for (i = 0; i < BITS_TO_LONGS(IPU_IRQ_COUNT); i++) {
+		status[i] = ipu_cm_read(IPU_INT_STAT(i + 1));
+		ipu_cm_write(status[i], IPU_INT_STAT(i + 1));
+	}
+
+	list_for_each_entry(handler, &ipu_irq_handlers, list) {
+		DECLARE_IPU_IRQ_BITMAP(tmp);
+		if (bitmap_and(tmp, status, handler->ipu_irqs, IPU_IRQ_COUNT))
+			handler->handler(tmp, handler->context);
+	}
+
+	return IRQ_HANDLED;
+}
+
+ipu_color_space_t format_to_colorspace(u32 fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_RGB666:
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_RGB32:
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_ABGR32:
+	case IPU_PIX_FMT_LVDS666:
+	case IPU_PIX_FMT_LVDS888:
+		return RGB;
+
+	default:
+		return YCbCr;
+	}
+}
+
+static int ipu_reset(void)
+{
+	int timeout = 10000;
+	u32 val;
+
+	/* hard reset the IPU */
+	val = readl(MX51_IO_ADDRESS(MX51_SRC_BASE_ADDR));
+	val |= 1 << 3;
+	writel(val, MX51_IO_ADDRESS(MX51_SRC_BASE_ADDR));
+
+	ipu_cm_write(0x807FFFFF, IPU_MEM_RST);
+
+	while (ipu_cm_read(IPU_MEM_RST) & 0x80000000) {
+		if (!timeout--)
+			return -ETIME;
+		udelay(100);
+	}
+
+	return 0;
+}
+
+/*
+ * The MIPI HSC unit has been removed from the i.MX51 Reference Manual by
+ * the Freescale marketing division. However this did not remove the
+ * hardware from the chip which still needs to be configured...
+ */
+static int __devinit ipu_mipi_setup(void)
+{
+	struct clk *hsc_clk;
+	void __iomem *hsc_addr;
+	int ret = 0;
+
+	hsc_addr = ioremap(MX51_MIPI_HSC_BASE_ADDR, PAGE_SIZE);
+	if (!hsc_addr)
+		return -ENOMEM;
+
+	hsc_clk = clk_get_sys(NULL, "mipi_hsp");
+	if (IS_ERR(hsc_clk)) {
+		ret = PTR_ERR(hsc_clk);
+		goto unmap;
+	}
+	clk_enable(hsc_clk);
+
+	/* setup MIPI module to legacy mode */
+	__raw_writel(0xF00, hsc_addr);
+
+	/* CSI mode: reserved; DI control mode: legacy (from Freescale BSP) */
+	__raw_writel(__raw_readl(hsc_addr + 0x800) | 0x30ff,
+		hsc_addr + 0x800);
+
+	clk_disable(hsc_clk);
+	clk_put(hsc_clk);
+unmap:
+	iounmap(hsc_addr);
+
+	return ret;
+}
+
+static int ipu_submodules_init(struct platform_device *pdev,
+		unsigned long ipu_base, struct clk *ipu_clk)
+{
+	char *unit;
+	int ret;
+
+	ret = ipu_di_init(pdev, 0, ipu_base + IPU_DI0_REG_BASE,
+			IPU_CONF_DI0_EN, ipu_clk);
+	if (ret) {
+		unit = "di0";
+		goto err_di_0;
+	}
+
+	ret = ipu_di_init(pdev, 1, ipu_base + IPU_DI1_REG_BASE,
+			IPU_CONF_DI1_EN, ipu_clk);
+	if (ret) {
+		unit = "di1";
+		goto err_di_1;
+	}
+
+	ret = ipu_dc_init(pdev, ipu_base + IPU_DC_REG_BASE,
+			ipu_base + IPU_DC_TMPL_REG_BASE);
+	if (ret) {
+		unit = "dc_template";
+		goto err_dc;
+	}
+
+	ret = ipu_dmfc_init(pdev, ipu_base + IPU_DMFC_REG_BASE, ipu_clk);
+	if (ret) {
+		unit = "dmfc";
+		goto err_dmfc;
+	}
+
+	ret = ipu_dp_init(pdev, ipu_base + IPU_SRM_REG_BASE);
+	if (ret) {
+		unit = "dp";
+		goto err_dp;
+	}
+
+	ret = ipu_cpmem_init(pdev, ipu_base + IPU_CPMEM_REG_BASE);
+	if (ret) {
+		unit = "cpmem";
+		goto err_cpmem;
+	}
+
+	return 0;
+
+err_cpmem:
+	ipu_dp_exit(pdev);
+err_dp:
+	ipu_dmfc_exit(pdev);
+err_dmfc:
+	ipu_dc_exit(pdev);
+err_dc:
+	ipu_di_exit(pdev, 1);
+err_di_1:
+	ipu_di_exit(pdev, 0);
+err_di_0:
+	dev_err(&pdev->dev, "init %s failed with %d\n", unit, ret);
+	return ret;
+}
+
+void ipu_get(void)
+{
+	mutex_lock(&ipu_channel_lock);
+
+	ipu_use_count++;
+
+	if (ipu_use_count == 1)
+		clk_enable(ipu_clk);
+
+	mutex_unlock(&ipu_channel_lock);
+}
+
+void ipu_put(void)
+{
+	mutex_lock(&ipu_channel_lock);
+
+	ipu_use_count--;
+
+	if (ipu_use_count == 0)
+		clk_disable(ipu_clk);
+
+	if (ipu_use_count < 0) {
+		dev_err(ipu_dev, "ipu use count < 0\n");
+		ipu_use_count = 0;
+	}
+
+	mutex_unlock(&ipu_channel_lock);
+}
+
+static void ipu_submodules_exit(struct platform_device *pdev,
+		unsigned long ipu_base)
+{
+	ipu_cpmem_exit(pdev);
+	ipu_dp_exit(pdev);
+	ipu_dmfc_exit(pdev);
+	ipu_dc_exit(pdev);
+	ipu_di_exit(pdev, 1);
+	ipu_di_exit(pdev, 0);
+}
+
+static int ipu_add_subdevice_pdata(struct platform_device *pdev,
+		const char *name, int id, void *pdata, size_t pdata_size)
+{
+	struct mfd_cell cell = {
+		.platform_data = pdata,
+		.data_size = pdata_size,
+	};
+
+	cell.name = name;
+
+	return mfd_add_devices(&pdev->dev, id, &cell, 1, NULL, 0);
+}
+
+static int ipu_add_client_devices(struct platform_device *pdev)
+{
+	struct imx_ipuv3_platform_data *plat_data = pdev->dev.platform_data;
+	struct ipuv3_fb_platform_data *fbdata;
+
+	fbdata = plat_data->fb_head0_platform_data;
+	if (fbdata) {
+		fbdata->ipu_channel_bg =
+			MX51_IPU_CHANNEL_MEM_BG_SYNC;
+		fbdata->ipu_channel_fg =
+			MX51_IPU_CHANNEL_MEM_FG_SYNC;
+		fbdata->dc_channel = 5;
+		fbdata->dp_channel = IPU_DP_FLOW_SYNC;
+
+		ipu_add_subdevice_pdata(pdev, "imx-ipuv3-fb", 0,
+				fbdata, sizeof(*fbdata));
+	}
+
+	fbdata = plat_data->fb_head1_platform_data;
+	if (fbdata) {
+		fbdata->ipu_channel_bg =
+			MX51_IPU_CHANNEL_MEM_DC_SYNC;
+		fbdata->ipu_channel_fg = -1;
+		fbdata->dc_channel = 1;
+		fbdata->dp_channel = -1;
+
+		ipu_add_subdevice_pdata(pdev, "imx-ipuv3-fb", 1,
+				fbdata, sizeof(*fbdata));
+	}
+
+	return 0;
+}
+
+static int __devinit ipu_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	unsigned long ipu_base;
+	int ret, irq1, irq2;
+
+	/* There can be only one */
+	if (ipu_dev)
+		return -EBUSY;
+
+	spin_lock_init(&ipu_lock);
+
+	ipu_dev = &pdev->dev;
+
+	irq1 = platform_get_irq(pdev, 0);
+	irq2 = platform_get_irq(pdev, 1);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (!res || irq1 < 0 || irq2 < 0)
+		return -ENODEV;
+
+	ipu_base = res->start;
+
+	ipu_cm_reg = ioremap(ipu_base + IPU_CM_REG_BASE, PAGE_SIZE);
+	if (!ipu_cm_reg) {
+		ret = -ENOMEM;
+		goto failed_ioremap1;
+	}
+
+	ipu_idmac_reg = ioremap(ipu_base + IPU_IDMAC_REG_BASE, PAGE_SIZE);
+	if (!ipu_idmac_reg) {
+		ret = -ENOMEM;
+		goto failed_ioremap2;
+	}
+
+	ret = ipu_mipi_setup();
+	if (ret)
+		goto failed_mipi_setup;
+
+	ipu_clk = clk_get(&pdev->dev, "ipu");
+	if (IS_ERR(ipu_clk)) {
+		ret = PTR_ERR(ipu_clk);
+		dev_err(&pdev->dev, "clk_get failed with %d", ret);
+		goto failed_clk_get;
+	}
+
+	ipu_get();
+
+	ret = request_irq(irq1, ipu_irq_handler, IRQF_DISABLED, pdev->name,
+			&pdev->dev);
+	if (ret) {
+		dev_err(&pdev->dev, "request irq %d failed with: %d\n", irq1, ret);
+		goto failed_request_irq1;
+	}
+
+	ret = request_irq(irq2, ipu_irq_handler, IRQF_DISABLED, pdev->name,
+			&pdev->dev);
+	if (ret) {
+		dev_err(&pdev->dev, "request irq %d failed with: %d\n", irq2, ret);
+		goto failed_request_irq2;
+	}
+
+	ipu_reset();
+
+	ret = ipu_submodules_init(pdev, ipu_base, ipu_clk);
+	if (ret)
+		goto failed_submodules_init;
+
+	/* Set sync refresh channels as high priority */
+	ipu_idmac_write(0x18800000, IDMAC_CHA_PRI(0));
+
+	ret = ipu_add_client_devices(pdev);
+        if (ret) {
+                dev_err(&pdev->dev, "adding client devices failed with %d\n", ret);
+		goto failed_add_clients;
+        }
+
+	ipu_put();
+
+	return 0;
+
+failed_add_clients:
+	ipu_submodules_exit(pdev, ipu_base);
+failed_submodules_init:
+	free_irq(irq2, &pdev->dev);
+failed_request_irq2:
+	free_irq(irq1, &pdev->dev);
+	ipu_put();
+failed_request_irq1:
+	clk_put(ipu_clk);
+failed_clk_get:
+failed_mipi_setup:
+	iounmap(ipu_idmac_reg);
+failed_ioremap2:
+	iounmap(ipu_cm_reg);
+failed_ioremap1:
+
+	return ret;
+}
+
+static int __devexit ipu_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+	unsigned long ipu_base;
+	int irq1, irq2;
+
+	irq1 = platform_get_irq(pdev, 0);
+	irq2 = platform_get_irq(pdev, 1);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ipu_base = res->start;
+
+	mfd_remove_devices(&pdev->dev);
+	ipu_submodules_exit(pdev, ipu_base);
+	free_irq(irq2, &pdev->dev);
+	free_irq(irq1, &pdev->dev);
+	iounmap(ipu_idmac_reg);
+	iounmap(ipu_cm_reg);
+
+	if (ipu_use_count != 0) {
+		dev_err(ipu_dev, "unbalanced use count: %d\n", ipu_use_count);
+		clk_disable(ipu_clk);
+	}
+
+	clk_put(ipu_clk);
+	ipu_dev = NULL;
+
+	return 0;
+}
+
+static struct platform_driver mxcipu_driver = {
+	.driver = {
+		.name = "imx-ipuv3",
+	},
+	.probe = ipu_probe,
+	.remove = __devexit_p(ipu_remove),
+};
+
+static int __init ipu_gen_init(void)
+{
+	int32_t ret;
+
+	ret = platform_driver_register(&mxcipu_driver);
+	return 0;
+}
+subsys_initcall(ipu_gen_init);
+
+static void __exit ipu_gen_uninit(void)
+{
+	platform_driver_unregister(&mxcipu_driver);
+}
+module_exit(ipu_gen_uninit);
+
+MODULE_DESCRIPTION("i.MX IPU v3 driver");
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/imx-ipu-v3/ipu-cpmem.c b/drivers/mfd/imx-ipu-v3/ipu-cpmem.c
new file mode 100644
index 0000000..faff5ee
--- /dev/null
+++ b/drivers/mfd/imx-ipu-v3/ipu-cpmem.c
@@ -0,0 +1,612 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/mfd/imx-ipu-v3.h>
+#include <linux/types.h>
+#include <linux/bitrev.h>
+#include <linux/io.h>
+
+#include "ipu-prv.h"
+
+#define __F(word, ofs, size) ((((word) * 160 + (ofs)) << 8) | (size))
+
+#define IPU_FIELD_XV		__F(0, 0, 10)
+#define IPU_FIELD_YV		__F(0, 10, 9)
+#define IPU_FIELD_XB		__F(0, 19, 13)
+#define IPU_FIELD_YB		__F(0, 32, 12)
+#define IPU_FIELD_NSB_B		__F(0, 44, 1)
+#define IPU_FIELD_CF		__F(0, 45, 1)
+#define IPU_FIELD_UBO		__F(0, 46, 22)
+#define IPU_FIELD_VBO		__F(0, 68, 22)
+#define IPU_FIELD_IOX		__F(0, 90, 4)
+#define IPU_FIELD_RDRW		__F(0, 94, 1)
+#define IPU_FIELD_SO		__F(0, 113, 1)
+#define IPU_FIELD_BNDM		__F(0, 114, 3)
+#define IPU_FIELD_BM		__F(0, 117, 2)
+#define IPU_FIELD_ROT		__F(0, 119, 1)
+#define IPU_FIELD_HF		__F(0, 120, 1)
+#define IPU_FIELD_VF		__F(0, 121, 1)
+#define IPU_FIELD_THE		__F(0, 122, 1)
+#define IPU_FIELD_CAP		__F(0, 123, 1)
+#define IPU_FIELD_CAE		__F(0, 124, 1)
+#define IPU_FIELD_FW		__F(0, 125, 13)
+#define IPU_FIELD_FH		__F(0, 138, 12)
+#define IPU_FIELD_EBA0		__F(1, 0, 29)
+#define IPU_FIELD_EBA1		__F(1, 29, 29)
+#define IPU_FIELD_ILO		__F(1, 58, 20)
+#define IPU_FIELD_NPB		__F(1, 78, 7)
+#define IPU_FIELD_PFS		__F(1, 85, 4)
+#define IPU_FIELD_ALU		__F(1, 89, 1)
+#define IPU_FIELD_ALBM		__F(1, 90, 3)
+#define IPU_FIELD_ID		__F(1, 93, 2)
+#define IPU_FIELD_TH		__F(1, 95, 7)
+#define IPU_FIELD_SLY		__F(1, 102, 14)
+#define IPU_FIELD_WID3		__F(1, 125, 3)
+#define IPU_FIELD_SLUV		__F(1, 128, 14)
+#define IPU_FIELD_CRE		__F(1, 149, 1)
+
+#define IPU_FIELD_XV		__F(0, 0, 10)
+#define IPU_FIELD_YV		__F(0, 10, 9)
+#define IPU_FIELD_XB		__F(0, 19, 13)
+#define IPU_FIELD_YB		__F(0, 32, 12)
+#define IPU_FIELD_NSB_B		__F(0, 44, 1)
+#define IPU_FIELD_CF		__F(0, 45, 1)
+#define IPU_FIELD_SX		__F(0, 46, 12)
+#define IPU_FIELD_SY		__F(0, 58, 11)
+#define IPU_FIELD_NS		__F(0, 69, 10)
+#define IPU_FIELD_SDX		__F(0, 79, 7)
+#define IPU_FIELD_SM		__F(0, 86, 10)
+#define IPU_FIELD_SCC		__F(0, 96, 1)
+#define IPU_FIELD_SCE		__F(0, 97, 1)
+#define IPU_FIELD_SDY		__F(0, 98, 7)
+#define IPU_FIELD_SDRX		__F(0, 105, 1)
+#define IPU_FIELD_SDRY		__F(0, 106, 1)
+#define IPU_FIELD_BPP		__F(0, 107, 3)
+#define IPU_FIELD_DEC_SEL	__F(0, 110, 2)
+#define IPU_FIELD_DIM		__F(0, 112, 1)
+#define IPU_FIELD_SO		__F(0, 113, 1)
+#define IPU_FIELD_BNDM		__F(0, 114, 3)
+#define IPU_FIELD_BM		__F(0, 117, 2)
+#define IPU_FIELD_ROT		__F(0, 119, 1)
+#define IPU_FIELD_HF		__F(0, 120, 1)
+#define IPU_FIELD_VF		__F(0, 121, 1)
+#define IPU_FIELD_THE		__F(0, 122, 1)
+#define IPU_FIELD_CAP		__F(0, 123, 1)
+#define IPU_FIELD_CAE		__F(0, 124, 1)
+#define IPU_FIELD_FW		__F(0, 125, 13)
+#define IPU_FIELD_FH		__F(0, 138, 12)
+#define IPU_FIELD_EBA0		__F(1, 0, 29)
+#define IPU_FIELD_EBA1		__F(1, 29, 29)
+#define IPU_FIELD_ILO		__F(1, 58, 20)
+#define IPU_FIELD_NPB		__F(1, 78, 7)
+#define IPU_FIELD_PFS		__F(1, 85, 4)
+#define IPU_FIELD_ALU		__F(1, 89, 1)
+#define IPU_FIELD_ALBM		__F(1, 90, 3)
+#define IPU_FIELD_ID		__F(1, 93, 2)
+#define IPU_FIELD_TH		__F(1, 95, 7)
+#define IPU_FIELD_SL		__F(1, 102, 14)
+#define IPU_FIELD_WID0		__F(1, 116, 3)
+#define IPU_FIELD_WID1		__F(1, 119, 3)
+#define IPU_FIELD_WID2		__F(1, 122, 3)
+#define IPU_FIELD_WID3		__F(1, 125, 3)
+#define IPU_FIELD_OFS0		__F(1, 128, 5)
+#define IPU_FIELD_OFS1		__F(1, 133, 5)
+#define IPU_FIELD_OFS2		__F(1, 138, 5)
+#define IPU_FIELD_OFS3		__F(1, 143, 5)
+#define IPU_FIELD_SXYS		__F(1, 148, 1)
+#define IPU_FIELD_CRE		__F(1, 149, 1)
+#define IPU_FIELD_DEC_SEL2	__F(1, 150, 1)
+
+static u32 *ipu_cpmem_base;
+static struct device *ipu_dev;
+
+struct ipu_ch_param_word {
+	u32 data[5];
+	u32 res[3];
+};
+
+struct ipu_ch_param {
+	struct ipu_ch_param_word word[2];
+};
+
+static u32 ipu_bytes_per_pixel(u32 fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_GENERIC:	/* generic data */
+	case IPU_PIX_FMT_RGB332:
+	case IPU_PIX_FMT_YUV420P:
+	case IPU_PIX_FMT_YUV422P:
+		return 1;
+
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_YUYV:
+	case IPU_PIX_FMT_UYVY:
+		return 2;
+
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+		return 3;
+
+	case IPU_PIX_FMT_GENERIC_32:	/* generic data */
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_RGB32:
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_ABGR32:
+		return 4;
+
+	default:
+		return 1;
+	}
+}
+
+bool ipu_pixel_format_has_alpha(u32 fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_ABGR32:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+#define ipu_ch_param_addr(ch) (((struct ipu_ch_param *)ipu_cpmem_base) + (ch))
+
+static inline void ipu_ch_param_set_field(struct ipu_ch_param *base, u32 wbs, u32 v)
+{
+	u32 bit = (wbs >> 8) % 160;
+	u32 size = wbs & 0xff;
+	u32 word = (wbs >> 8) / 160;
+	u32 i = bit / 32;
+	u32 ofs = bit % 32;
+	u32 mask = (1 << size) - 1;
+
+	pr_debug("%s %d %d %d\n", __func__, word, bit , size);
+
+	base->word[word].data[i] &= ~(mask << ofs);
+	base->word[word].data[i] |= v << ofs;
+
+	if ((bit + size - 1) / 32 > i) {
+		base->word[word].data[i + 1] &= ~(v >> (mask ? (32 - ofs) : 0));
+		base->word[word].data[i + 1] |= v >> (ofs ? (32 - ofs) : 0);
+	}
+}
+
+static inline u32 ipu_ch_param_read_field(struct ipu_ch_param *base, u32 wbs)
+{
+	u32 bit = (wbs >> 8) % 160;
+	u32 size = wbs & 0xff;
+	u32 word = (wbs >> 8) / 160;
+	u32 i = bit / 32;
+	u32 ofs = bit % 32;
+	u32 mask = (1 << size) - 1;
+	u32 val = 0;
+
+	pr_debug("%s %d %d %d\n", __func__, word, bit , size);
+
+	val = (base->word[word].data[i] >> ofs) & mask;
+
+	if ((bit + size - 1) / 32 > i) {
+		u32 tmp;
+		tmp = base->word[word].data[i + 1];
+		tmp &= mask >> (ofs ? (32 - ofs) : 0);
+		val |= tmp << (ofs ? (32 - ofs) : 0);
+	}
+
+	return val;
+}
+
+static inline void ipu_ch_params_set_packing(struct ipu_ch_param *p,
+					      int red_width, int red_offset,
+					      int green_width, int green_offset,
+					      int blue_width, int blue_offset,
+					      int alpha_width, int alpha_offset)
+{
+	/* Setup red width and offset */
+	ipu_ch_param_set_field(p, IPU_FIELD_WID0, red_width - 1);
+	ipu_ch_param_set_field(p, IPU_FIELD_OFS0, red_offset);
+	/* Setup green width and offset */
+	ipu_ch_param_set_field(p, IPU_FIELD_WID1, green_width - 1);
+	ipu_ch_param_set_field(p, IPU_FIELD_OFS1, green_offset);
+	/* Setup blue width and offset */
+	ipu_ch_param_set_field(p, IPU_FIELD_WID2, blue_width - 1);
+	ipu_ch_param_set_field(p, IPU_FIELD_OFS2, blue_offset);
+	/* Setup alpha width and offset */
+	ipu_ch_param_set_field(p, IPU_FIELD_WID3, alpha_width - 1);
+	ipu_ch_param_set_field(p, IPU_FIELD_OFS3, alpha_offset);
+}
+
+static inline void ipu_ch_param_dump(int ch)
+{
+	struct ipu_ch_param *p = ipu_ch_param_addr(ch);
+	pr_debug("ch %d word 0 - %08X %08X %08X %08X %08X\n", ch,
+		 p->word[0].data[0], p->word[0].data[1], p->word[0].data[2],
+		 p->word[0].data[3], p->word[0].data[4]);
+	pr_debug("ch %d word 1 - %08X %08X %08X %08X %08X\n", ch,
+		 p->word[1].data[0], p->word[1].data[1], p->word[1].data[2],
+		 p->word[1].data[3], p->word[1].data[4]);
+	pr_debug("PFS 0x%x\n", ipu_ch_param_read_field(p, IPU_FIELD_PFS));
+	pr_debug("BPP 0x%x\n", ipu_ch_param_read_field(p, IPU_FIELD_BPP));
+	pr_debug("NPB 0x%x\n", ipu_ch_param_read_field(p, IPU_FIELD_NPB));
+
+	pr_debug("FW %d\n", ipu_ch_param_read_field(p, IPU_FIELD_FW));
+	pr_debug("FH %d\n", ipu_ch_param_read_field(p, IPU_FIELD_FH));
+	pr_debug("Stride %d\n", ipu_ch_param_read_field(p, IPU_FIELD_SL));
+
+	pr_debug("Width0 %d+1\n", ipu_ch_param_read_field(p, IPU_FIELD_WID0));
+	pr_debug("Width1 %d+1\n", ipu_ch_param_read_field(p, IPU_FIELD_WID1));
+	pr_debug("Width2 %d+1\n", ipu_ch_param_read_field(p, IPU_FIELD_WID2));
+	pr_debug("Width3 %d+1\n", ipu_ch_param_read_field(p, IPU_FIELD_WID3));
+	pr_debug("Offset0 %d\n", ipu_ch_param_read_field(p, IPU_FIELD_OFS0));
+	pr_debug("Offset1 %d\n", ipu_ch_param_read_field(p, IPU_FIELD_OFS1));
+	pr_debug("Offset2 %d\n", ipu_ch_param_read_field(p, IPU_FIELD_OFS2));
+	pr_debug("Offset3 %d\n", ipu_ch_param_read_field(p, IPU_FIELD_OFS3));
+}
+
+static inline void ipu_ch_param_set_burst_size(u32 ch,
+						u16 burst_pixels)
+{
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_NPB,
+			       burst_pixels - 1);
+};
+
+static inline int ipu_ch_param_get_burst_size(u32 ch)
+{
+	return ipu_ch_param_read_field(ipu_ch_param_addr(ch), IPU_FIELD_NPB) + 1;
+};
+
+static inline int ipu_ch_param_get_bpp(u32 ch)
+{
+	return ipu_ch_param_read_field(ipu_ch_param_addr(ch), IPU_FIELD_BPP);
+};
+
+static inline void ipu_ch_param_set_buffer(u32 ch, int bufNum,
+					    dma_addr_t phyaddr)
+{
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch),
+			bufNum ? IPU_FIELD_EBA1 : IPU_FIELD_EBA0,
+			phyaddr / 8);
+};
+
+#define IPU_FIELD_ROT_HF_VF		__F(0, 119, 3)
+
+static inline void ipu_ch_param_set_rotation(u32 ch,
+					      ipu_rotate_mode_t rot)
+{
+	u32 temp_rot = bitrev8(rot) >> 5;
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_ROT_HF_VF, temp_rot);
+};
+
+static inline void ipu_ch_param_set_block_mode(u32 ch)
+{
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_BM, 1);
+};
+
+static inline void ipu_ch_param_set_alpha_use_separate_channel(u32 ch,
+		bool option)
+{
+	if (option)
+		ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_ALU, 1);
+	else
+		ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_ALU, 0);
+};
+
+static inline void ipu_ch_param_set_alpha_condition_read(u32 ch)
+{
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_CRE, 1);
+};
+
+static inline void ipu_ch_param_set_alpha_buffer_memory(u32 ch)
+{
+	int alp_mem_idx;
+
+	switch (ch) {
+	case 14: /* PRP graphic */
+		alp_mem_idx = 0;
+		break;
+	case 15: /* PP graphic */
+		alp_mem_idx = 1;
+		break;
+	case 23: /* DP BG SYNC graphic */
+		alp_mem_idx = 4;
+		break;
+	case 27: /* DP FG SYNC graphic */
+		alp_mem_idx = 2;
+		break;
+	default:
+		dev_err(ipu_dev, "unsupported correlated channel of local alpha channel\n");
+		return;
+	}
+
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_ALBM, alp_mem_idx);
+};
+
+static inline void ipu_ch_param_set_interlaced_scan(u32 ch)
+{
+	u32 stride;
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_SO, 1);
+	stride = ipu_ch_param_read_field(ipu_ch_param_addr(ch), IPU_FIELD_SL) + 1;
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_ILO, stride / 8);
+	stride *= 2;
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_SLY, stride - 1);
+};
+
+static inline void ipu_ch_param_set_high_priority(u32 ch)
+{
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_ID, 1);
+};
+
+static inline void ipu_ch_params_set_alpha_width(u32 ch, int alpha_width)
+{
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), IPU_FIELD_WID3,
+			alpha_width - 1);
+}
+
+static int ipu_ch_param_init(int ch,
+			u32 pixel_fmt, u32 width,
+			u32 height, u32 stride,
+			u32 u, u32 v,
+			u32 uv_stride, dma_addr_t addr0,
+			dma_addr_t addr1)
+{
+	u32 u_offset = 0;
+	u32 v_offset = 0;
+	struct ipu_ch_param params;
+
+	memset(&params, 0, sizeof(params));
+
+	ipu_ch_param_set_field(&params, IPU_FIELD_FW, width - 1);
+	ipu_ch_param_set_field(&params, IPU_FIELD_FH, height - 1);
+	ipu_ch_param_set_field(&params, IPU_FIELD_SLY, stride - 1);
+	ipu_ch_param_set_field(&params, IPU_FIELD_EBA0, addr0 >> 3);
+	ipu_ch_param_set_field(&params, IPU_FIELD_EBA1, addr1 >> 3);
+
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_GENERIC:
+		/* Represents 8-bit Generic data */
+		ipu_ch_param_set_field(&params, IPU_FIELD_BPP, 5);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 6);	/* pix format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 63);	/* burst size */
+
+		break;
+	case IPU_PIX_FMT_GENERIC_32:
+		/* Represents 32-bit Generic data */
+		break;
+	case IPU_PIX_FMT_RGB565:
+		ipu_ch_param_set_field(&params, IPU_FIELD_BPP, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 15);	/* burst size */
+
+		ipu_ch_params_set_packing(&params, 5, 0, 6, 5, 5, 11, 8, 16);
+		break;
+	case IPU_PIX_FMT_BGR24:
+		ipu_ch_param_set_field(&params, IPU_FIELD_BPP, 1);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 19);	/* burst size */
+
+		ipu_ch_params_set_packing(&params, 8, 0, 8, 8, 8, 16, 8, 24);
+		break;
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_YUV444:
+		ipu_ch_param_set_field(&params, IPU_FIELD_BPP, 1);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 19);	/* burst size */
+
+		ipu_ch_params_set_packing(&params, 8, 16, 8, 8, 8, 0, 8, 24);
+		break;
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_BGR32:
+		ipu_ch_param_set_field(&params, IPU_FIELD_BPP, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 15);	/* burst size */
+
+		ipu_ch_params_set_packing(&params, 8, 8, 8, 16, 8, 24, 8, 0);
+		break;
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_RGB32:
+		ipu_ch_param_set_field(&params, IPU_FIELD_BPP, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 15);	/* burst size */
+
+		ipu_ch_params_set_packing(&params, 8, 24, 8, 16, 8, 8, 8, 0);
+		break;
+	case IPU_PIX_FMT_ABGR32:
+		ipu_ch_param_set_field(&params, IPU_FIELD_BPP, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 7);	/* pix format */
+
+		ipu_ch_params_set_packing(&params, 8, 0, 8, 8, 8, 16, 8, 24);
+		break;
+	case IPU_PIX_FMT_UYVY:
+		ipu_ch_param_set_field(&params, IPU_FIELD_BPP, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 0xA);	/* pix format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 15);	/* burst size */
+		break;
+	case IPU_PIX_FMT_YUYV:
+		ipu_ch_param_set_field(&params, IPU_FIELD_BPP, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 0x8);	/* pix format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 31);	/* burst size */
+		break;
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 2);	/* pix format */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		u_offset = stride * height;
+		v_offset = u_offset + (uv_stride * height / 2);
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 31);  /* burst size */
+		break;
+	case IPU_PIX_FMT_YVU422P:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 1);	/* pix format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 31);	/* burst size */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		v_offset = (v == 0) ? stride * height : v;
+		u_offset = (u == 0) ? v_offset + v_offset / 2 : u;
+		break;
+	case IPU_PIX_FMT_YUV422P:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 1);	/* pix format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 31);	/* burst size */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		u_offset = (u == 0) ? stride * height : u;
+		v_offset = (v == 0) ? u_offset + u_offset / 2 : v;
+		break;
+	case IPU_PIX_FMT_NV12:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_PFS, 4);	/* pix format */
+		ipu_ch_param_set_field(&params, IPU_FIELD_NPB, 31);	/* burst size */
+		uv_stride = stride;
+		u_offset = (u == 0) ? stride * height : u;
+		break;
+	default:
+		dev_err(ipu_dev, "mxc ipu: unimplemented pixel format: %d\n",
+			pixel_fmt);
+		return -EINVAL;
+	}
+	/* set burst size to 16 */
+	if (uv_stride)
+		ipu_ch_param_set_field(&params, IPU_FIELD_SLUV, uv_stride - 1);
+
+	if (u > u_offset)
+		u_offset = u;
+
+	if (v > v_offset)
+		v_offset = v;
+
+	ipu_ch_param_set_field(&params, IPU_FIELD_UBO, u_offset / 8);
+	ipu_ch_param_set_field(&params, IPU_FIELD_VBO, v_offset / 8);
+
+	pr_debug("initializing idma ch %d @ %p\n", ch, ipu_ch_param_addr(ch));
+	memcpy(ipu_ch_param_addr(ch), &params, sizeof(params));
+	return 0;
+}
+
+/*
+ * This function is called to initialize a buffer for a IPU channel.
+ *
+ * @param       channel         The IPU channel.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer.
+ *                              Pixel format is a FOURCC ASCII code.
+ *
+ * @param       width           Input parameter for width of buffer in pixels.
+ *
+ * @param       height          Input parameter for height of buffer in pixels.
+ *
+ * @param       stride          Input parameter for stride length of buffer
+ *                              in pixels.
+ *
+ * @param       rot_mode        Input parameter for rotation setting of buffer.
+ *                              A rotation setting other than
+ *                              IPU_ROTATE_VERT_FLIP
+ *                              should only be used for input buffers of
+ *                              rotation channels.
+ *
+ * @param       phyaddr_0       Input parameter buffer 0 physical address.
+ *
+ * @param       phyaddr_1       Input parameter buffer 1 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              double buffering mode.
+ *
+ * @param       u		private u offset for additional cropping,
+ *				zero if not used.
+ *
+ * @param       v		private v offset for additional cropping,
+ *				zero if not used.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int ipu_idmac_init_channel_buffer(struct ipu_channel *channel,
+				u32 pixel_fmt,
+				u16 width, u16 height,
+				u32 stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				u32 u, u32 v, bool interlaced)
+{
+	int ret = 0;
+	u32 dma_chan = channel->num;
+
+	if (stride < width * ipu_bytes_per_pixel(pixel_fmt))
+		stride = width * ipu_bytes_per_pixel(pixel_fmt);
+
+	if (stride % 4) {
+		dev_err(ipu_dev,
+			"Stride not 32-bit aligned, stride = %d\n", stride);
+		return -EINVAL;
+	}
+
+	ipu_get();
+
+	/* Build parameter memory data for DMA channel */
+	ret = ipu_ch_param_init(dma_chan, pixel_fmt, width, height, stride, u, v, 0,
+			   phyaddr_0, phyaddr_1);
+	if (ret)
+		goto out;
+
+	if (rot_mode)
+		ipu_ch_param_set_rotation(dma_chan, rot_mode);
+
+	if (interlaced)
+		ipu_ch_param_set_interlaced_scan(dma_chan);
+
+	if (idmac_idma_is_set(IDMAC_CHA_PRI, dma_chan))
+		ipu_ch_param_set_high_priority(dma_chan);
+
+	ipu_ch_param_dump(dma_chan);
+out:
+	ipu_put();
+
+	return ret;
+}
+EXPORT_SYMBOL(ipu_idmac_init_channel_buffer);
+
+int ipu_idmac_update_channel_buffer(struct ipu_channel *channel,
+				  u32 buf_num, dma_addr_t phyaddr)
+{
+	u32 dma_chan = channel->num;
+
+	ipu_ch_param_set_buffer(dma_chan, buf_num, phyaddr);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_idmac_update_channel_buffer);
+
+int ipu_cpmem_init(struct platform_device *pdev, unsigned long base)
+{
+	ipu_cpmem_base = ioremap(base, PAGE_SIZE);
+	if (!ipu_cpmem_base)
+		return -ENOMEM;
+	ipu_dev = &pdev->dev;
+	return 0;
+}
+
+void ipu_cpmem_exit(struct platform_device *pdev)
+{
+	iounmap(ipu_cpmem_base);
+}
diff --git a/drivers/mfd/imx-ipu-v3/ipu-dc.c b/drivers/mfd/imx-ipu-v3/ipu-dc.c
new file mode 100644
index 0000000..b8c601e
--- /dev/null
+++ b/drivers/mfd/imx-ipu-v3/ipu-dc.c
@@ -0,0 +1,364 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/mfd/imx-ipu-v3.h>
+
+#include "ipu-prv.h"
+
+#define ASYNC_SER_WAVE 6
+
+#define DC_DISP_ID_SERIAL	2
+#define DC_DISP_ID_ASYNC	3
+
+#define DC_MAP_CONF_PTR(n)	(ipu_dc_reg + 0x0108 + ((n) & ~0x1) * 2)
+#define DC_MAP_CONF_VAL(n)	(ipu_dc_reg + 0x0144 + ((n) & ~0x1) * 2)
+
+#define DC_EVT_NF		0
+#define DC_EVT_NL		1
+#define DC_EVT_EOF		2
+#define DC_EVT_NFIELD		3
+#define DC_EVT_EOL		4
+#define DC_EVT_EOFIELD		5
+#define DC_EVT_NEW_ADDR		6
+#define DC_EVT_NEW_CHAN		7
+#define DC_EVT_NEW_DATA		8
+
+#define DC_EVT_NEW_ADDR_W_0	0
+#define DC_EVT_NEW_ADDR_W_1	1
+#define DC_EVT_NEW_CHAN_W_0	2
+#define DC_EVT_NEW_CHAN_W_1	3
+#define DC_EVT_NEW_DATA_W_0	4
+#define DC_EVT_NEW_DATA_W_1	5
+#define DC_EVT_NEW_ADDR_R_0	6
+#define DC_EVT_NEW_ADDR_R_1	7
+#define DC_EVT_NEW_CHAN_R_0	8
+#define DC_EVT_NEW_CHAN_R_1	9
+#define DC_EVT_NEW_DATA_R_0	10
+#define DC_EVT_NEW_DATA_R_1	11
+
+#define DC_WR_CH_CONF(ch)	(ipu_dc_reg + dc_channels[ch].channel_offset)
+#define DC_WR_CH_ADDR(ch)	(ipu_dc_reg + dc_channels[ch].channel_offset + 4)
+#define DC_RL_CH(ch, evt)	(ipu_dc_reg + dc_channels[ch].channel_offset + 8 + ((evt) & ~0x1) * 2)
+
+#define DC_GEN			(ipu_dc_reg + 0x00D4)
+#define DC_DISP_CONF1(disp)	(ipu_dc_reg + 0x00D8 + disp * 4)
+#define DC_DISP_CONF2(disp)	(ipu_dc_reg + 0x00E8 + disp * 4)
+#define DC_STAT			(ipu_dc_reg + 0x01C8)
+
+#define WROD(lf)		(0x18 | (lf << 1))
+
+#define DC_WR_CH_CONF_FIELD_MODE		(1 << 9)
+#define DC_WR_CH_CONF_PROG_TYPE_OFFSET		5
+#define DC_WR_CH_CONF_PROG_TYPE_MASK		(7 << 5)
+#define DC_WR_CH_CONF_PROG_DI_ID		(1 << 2)
+#define DC_WR_CH_CONF_PROG_DISP_ID_OFFSET	3
+#define DC_WR_CH_CONF_PROG_DISP_ID_MASK		(3 << 3)
+
+static void __iomem *ipu_dc_reg;
+static void __iomem *ipu_dc_tmpl_reg;
+static struct device *ipu_dev;
+
+struct ipu_dc {
+	unsigned int di; /* The display interface number assigned to this dc channel */
+	unsigned int channel_offset;
+};
+
+static struct ipu_dc dc_channels[10];
+
+static void ipu_dc_link_event(int chan, int event, int addr, int priority)
+{
+	u32 reg;
+
+	reg = __raw_readl(DC_RL_CH(chan, event));
+	reg &= ~(0xFFFF << (16 * (event & 0x1)));
+	reg |= ((addr << 8) | priority) << (16 * (event & 0x1));
+	__raw_writel(reg, DC_RL_CH(chan, event));
+}
+
+static void ipu_dc_write_tmpl(int word, u32 opcode, u32 operand, int map,
+			       int wave, int glue, int sync)
+{
+	u32 reg;
+	int stop = 1;
+
+	reg = sync;
+	reg |= (glue << 4);
+	reg |= (++wave << 11);
+	reg |= (++map << 15);
+	reg |= (operand << 20) & 0xFFF00000;
+	__raw_writel(reg, ipu_dc_tmpl_reg + word * 8);
+
+	reg = (operand >> 12);
+	reg |= opcode << 4;
+	reg |= (stop << 9);
+	__raw_writel(reg, ipu_dc_tmpl_reg + word * 8 + 4);
+}
+
+static int ipu_pixfmt_to_map(u32 fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_GENERIC:
+	case IPU_PIX_FMT_RGB24:
+		return 0;
+	case IPU_PIX_FMT_RGB666:
+		return 1;
+	case IPU_PIX_FMT_YUV444:
+		return 2;
+	case IPU_PIX_FMT_RGB565:
+		return 3;
+	case IPU_PIX_FMT_LVDS666:
+		return 4;
+	}
+
+	return -EINVAL;
+}
+
+#define SYNC_WAVE 0
+
+int ipu_dc_init_sync(int dc_chan, int di, bool interlaced, u32 pixel_fmt, u32 width)
+{
+	u32 reg = 0, map;
+
+	dc_channels[dc_chan].di = di;
+
+	map = ipu_pixfmt_to_map(pixel_fmt);
+	if (map < 0) {
+		dev_dbg(ipu_dev, "IPU_DISP: No MAP\n");
+		return -EINVAL;
+	}
+
+	ipu_get();
+
+	if (interlaced) {
+		ipu_dc_link_event(dc_chan, DC_EVT_NL, 0, 3);
+		ipu_dc_link_event(dc_chan, DC_EVT_EOL, 0, 2);
+		ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 0, 1);
+
+		/* Init template microcode */
+		ipu_dc_write_tmpl(0, WROD(0), 0, map, SYNC_WAVE, 0, 8);
+	} else {
+		if (di) {
+			ipu_dc_link_event(dc_chan, DC_EVT_NL, 2, 3);
+			ipu_dc_link_event(dc_chan, DC_EVT_EOL, 3, 2);
+			ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 4, 1);
+			/* Init template microcode */
+			ipu_dc_write_tmpl(2, WROD(0), 0, map, SYNC_WAVE, 8, 5);
+			ipu_dc_write_tmpl(3, WROD(0), 0, map, SYNC_WAVE, 4, 5);
+			ipu_dc_write_tmpl(4, WROD(0), 0, map, SYNC_WAVE, 0, 5);
+		} else {
+			ipu_dc_link_event(dc_chan, DC_EVT_NL, 5, 3);
+			ipu_dc_link_event(dc_chan, DC_EVT_EOL, 6, 2);
+			ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 7, 1);
+			/* Init template microcode */
+			ipu_dc_write_tmpl(5, WROD(0), 0, map, SYNC_WAVE, 8, 5);
+			ipu_dc_write_tmpl(6, WROD(0), 0, map, SYNC_WAVE, 4, 5);
+			ipu_dc_write_tmpl(7, WROD(0), 0, map, SYNC_WAVE, 0, 5);
+		}
+	}
+	ipu_dc_link_event(dc_chan, DC_EVT_NF, 0, 0);
+	ipu_dc_link_event(dc_chan, DC_EVT_NFIELD, 0, 0);
+	ipu_dc_link_event(dc_chan, DC_EVT_EOF, 0, 0);
+	ipu_dc_link_event(dc_chan, DC_EVT_EOFIELD, 0, 0);
+	ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN, 0, 0);
+	ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR, 0, 0);
+
+	reg = 0x2;
+	reg |= di << DC_WR_CH_CONF_PROG_DISP_ID_OFFSET;
+	reg |= di << 2;
+	if (interlaced)
+		reg |= DC_WR_CH_CONF_FIELD_MODE;
+
+	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+
+	__raw_writel(0x00000000, DC_WR_CH_ADDR(dc_chan));
+
+	__raw_writel(0x00000084, DC_GEN);
+
+	__raw_writel(width, DC_DISP_CONF2(di));
+
+	ipu_module_enable(IPU_CONF_DC_EN);
+
+	ipu_put();
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_dc_init_sync);
+
+void ipu_dc_init_async(int dc_chan, int di, bool interlaced)
+{
+	u32 reg = 0;
+	dc_channels[dc_chan].di = di;
+	ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_0, 0x64, 1);
+	ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_1, 0x64, 1);
+
+	reg = 0x3;
+	reg |= DC_DISP_ID_SERIAL << DC_WR_CH_CONF_PROG_DISP_ID_OFFSET;
+	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+
+	__raw_writel(0x00000000, DC_WR_CH_ADDR(dc_chan));
+
+	__raw_writel(0x00000084, DC_GEN);
+
+	ipu_module_enable(IPU_CONF_DC_EN);
+}
+EXPORT_SYMBOL(ipu_dc_init_async);
+
+void ipu_dc_enable_channel(u32 dc_chan)
+{
+	int di;
+	u32 reg;
+
+	di = dc_channels[dc_chan].di;
+
+	/* Make sure other DC sync channel is not assigned same DI */
+	reg = __raw_readl(DC_WR_CH_CONF(6 - dc_chan));
+	if ((di << 2) == (reg & DC_WR_CH_CONF_PROG_DI_ID)) {
+		reg &= ~DC_WR_CH_CONF_PROG_DI_ID;
+		reg |= di ? 0 : DC_WR_CH_CONF_PROG_DI_ID;
+		__raw_writel(reg, DC_WR_CH_CONF(6 - dc_chan));
+	}
+
+	reg = __raw_readl(DC_WR_CH_CONF(dc_chan));
+	reg |= 4 << DC_WR_CH_CONF_PROG_TYPE_OFFSET;
+	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+}
+EXPORT_SYMBOL(ipu_dc_enable_channel);
+
+void ipu_dc_disable_channel(u32 dc_chan)
+{
+	u32 reg;
+	int irq = 0, ret, timeout = 50;
+
+	if (dc_chan == 1) {
+		irq = IPU_IRQ_DC_FC_1;
+	} else if (dc_chan == 5) {
+		irq = IPU_IRQ_DP_SF_END;
+	} else {
+		return;
+	}
+
+	ret = ipu_wait_for_interrupt(irq, 50);
+	if (ret)
+		return;
+
+	/* Wait for DC triple buffer to empty */
+	if (dc_channels[dc_chan].di == 0)
+		while ((__raw_readl(DC_STAT) & 0x00000002)
+			!= 0x00000002) {
+			msleep(2);
+			timeout -= 2;
+			if (timeout <= 0)
+				break;
+		}
+	else if (dc_channels[dc_chan].di == 1)
+		while ((__raw_readl(DC_STAT) & 0x00000020)
+			!= 0x00000020) {
+			msleep(2);
+			timeout -= 2;
+			if (timeout <= 0)
+				break;
+	}
+
+	reg = __raw_readl(DC_WR_CH_CONF(dc_chan));
+	reg &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
+	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+}
+EXPORT_SYMBOL(ipu_dc_disable_channel);
+
+static void ipu_dc_map_config(int map, int byte_num, int offset, int mask)
+{
+	int ptr = map * 3 + byte_num;
+	u32 reg;
+
+	reg = __raw_readl(DC_MAP_CONF_VAL(ptr));
+	reg &= ~(0xffff << (16 * (ptr & 0x1)));
+	reg |= ((offset << 8) | mask) << (16 * (ptr & 0x1));
+	__raw_writel(reg, DC_MAP_CONF_VAL(ptr));
+
+	reg = __raw_readl(DC_MAP_CONF_PTR(map));
+	reg &= ~(0x1f << ((16 * (map & 0x1)) + (5 * byte_num)));
+	reg |= ptr << ((16 * (map & 0x1)) + (5 * byte_num));
+	__raw_writel(reg, DC_MAP_CONF_PTR(map));
+}
+
+static void ipu_dc_map_clear(int map)
+{
+	u32 reg = __raw_readl(DC_MAP_CONF_PTR(map));
+	__raw_writel(reg & ~(0xffff << (16 * (map & 0x1))),
+		     DC_MAP_CONF_PTR(map));
+}
+
+int ipu_dc_init(struct platform_device *pdev, unsigned long base, unsigned long template_base)
+{
+	static int channel_offsets[] = { 0, 0x1c, 0x38, 0x54, 0x58, 0x5c, 0x78, 0, 0x94, 0xb4};
+	int i;
+
+	ipu_dc_reg = ioremap(base, PAGE_SIZE);
+	if (!ipu_dc_reg)
+		return -ENOMEM;
+
+	ipu_dev = &pdev->dev;
+
+	ipu_dc_tmpl_reg = ioremap(template_base, PAGE_SIZE);
+	if (!ipu_dc_tmpl_reg) {
+		iounmap(ipu_dc_reg);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < 10; i++)
+		dc_channels[i].channel_offset = channel_offsets[i];
+
+	/* IPU_PIX_FMT_RGB24 */
+	ipu_dc_map_clear(0);
+	ipu_dc_map_config(0, 0, 7, 0xff);
+	ipu_dc_map_config(0, 1, 15, 0xff);
+	ipu_dc_map_config(0, 2, 23, 0xff);
+
+	/* IPU_PIX_FMT_RGB666 */
+	ipu_dc_map_clear(1);
+	ipu_dc_map_config(1, 0, 5, 0xfc);
+	ipu_dc_map_config(1, 1, 11, 0xfc);
+	ipu_dc_map_config(1, 2, 17, 0xfc);
+
+	/* IPU_PIX_FMT_YUV444 */
+	ipu_dc_map_clear(2);
+	ipu_dc_map_config(2, 0, 15, 0xff);
+	ipu_dc_map_config(2, 1, 23, 0xff);
+	ipu_dc_map_config(2, 2, 7, 0xff);
+
+	/* IPU_PIX_FMT_RGB565 */
+	ipu_dc_map_clear(3);
+	ipu_dc_map_config(3, 0, 4, 0xf8);
+	ipu_dc_map_config(3, 1, 10, 0xfc);
+	ipu_dc_map_config(3, 2, 15, 0xf8);
+
+	/* IPU_PIX_FMT_LVDS666 */
+	ipu_dc_map_clear(4);
+	ipu_dc_map_config(4, 0, 5, 0xfc);
+	ipu_dc_map_config(4, 1, 13, 0xfc);
+	ipu_dc_map_config(4, 2, 21, 0xfc);
+
+	return 0;
+}
+
+void ipu_dc_exit(struct platform_device *pdev)
+{
+	iounmap(ipu_dc_reg);
+	iounmap(ipu_dc_tmpl_reg);
+}
diff --git a/drivers/mfd/imx-ipu-v3/ipu-di.c b/drivers/mfd/imx-ipu-v3/ipu-di.c
new file mode 100644
index 0000000..62e3d01
--- /dev/null
+++ b/drivers/mfd/imx-ipu-v3/ipu-di.c
@@ -0,0 +1,550 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/mfd/imx-ipu-v3.h>
+#include <linux/platform_device.h>
+
+#include "ipu-prv.h"
+
+#define SYNC_WAVE 0
+
+#define DC_DISP_ID_SYNC(di)	(di)
+
+struct ipu_di {
+	void __iomem *base;
+	int id;
+	u32 module;
+	struct clk *clk;
+	struct clk *ipu_clk;
+	bool external_clk;
+	bool inuse;
+	bool initialized;
+};
+
+static struct ipu_di dis[2];
+
+static DEFINE_MUTEX(di_mutex);
+static struct device *ipu_dev;
+
+struct di_sync_config {
+	int run_count;
+	int run_src;
+	int offset_count;
+	int offset_src;
+	int repeat_count;
+	int cnt_clr_src;
+	int cnt_polarity_gen_en;
+	int cnt_polarity_clr_src;
+	int cnt_polarity_trigger_src;
+	int cnt_up;
+	int cnt_down;
+};
+
+enum di_pins {
+	DI_PIN11 = 0,
+	DI_PIN12 = 1,
+	DI_PIN13 = 2,
+	DI_PIN14 = 3,
+	DI_PIN15 = 4,
+	DI_PIN16 = 5,
+	DI_PIN17 = 6,
+	DI_PIN_CS = 7,
+
+	DI_PIN_SER_CLK = 0,
+	DI_PIN_SER_RS = 1,
+};
+
+enum di_sync_wave {
+	DI_SYNC_NONE = 0,
+	DI_SYNC_CLK = 1,
+	DI_SYNC_INT_HSYNC = 2,
+	DI_SYNC_HSYNC = 3,
+	DI_SYNC_VSYNC = 4,
+	DI_SYNC_DE = 6,
+};
+
+#define DI_GENERAL		0x0000
+#define DI_BS_CLKGEN0		0x0004
+#define DI_BS_CLKGEN1		0x0008
+#define DI_SW_GEN0(gen)		(0x000c + 4 * ((gen) - 1))
+#define DI_SW_GEN1(gen)		(0x0030 + 4 * ((gen) - 1))
+#define DI_STP_REP(gen)		(0x0148 + 4 * (((gen) - 1)/2))
+#define DI_SYNC_AS_GEN		0x0054
+#define DI_DW_GEN(gen)		(0x0058 + 4 * (gen))
+#define DI_DW_SET(gen, set)	(0x0088 + 4 * ((gen) + 0xc * (set)))
+#define DI_SER_CONF		0x015c
+#define DI_SSC			0x0160
+#define DI_POL			0x0164
+#define DI_AW0			0x0168
+#define DI_AW1			0x016c
+#define DI_SCR_CONF		0x0170
+#define DI_STAT			0x0174
+
+#define DI_SW_GEN0_RUN_COUNT(x)			((x) << 19)
+#define DI_SW_GEN0_RUN_SRC(x)			((x) << 16)
+#define DI_SW_GEN0_OFFSET_COUNT(x)		((x) << 3)
+#define DI_SW_GEN0_OFFSET_SRC(x)		((x) << 0)
+
+#define DI_SW_GEN1_CNT_POL_GEN_EN(x)		((x) << 29)
+#define DI_SW_GEN1_CNT_CLR_SRC(x)		((x) << 25)
+#define DI_SW_GEN1_CNT_POL_TRIGGER_SRC(x)	((x) << 12)
+#define DI_SW_GEN1_CNT_POL_CLR_SRC(x)		((x) << 9)
+#define DI_SW_GEN1_CNT_DOWN(x)			((x) << 16)
+#define DI_SW_GEN1_CNT_UP(x)			(x)
+#define DI_SW_GEN1_AUTO_RELOAD			(0x10000000)
+
+#define DI_DW_GEN_ACCESS_SIZE_OFFSET		24
+#define DI_DW_GEN_COMPONENT_SIZE_OFFSET		16
+
+#define DI_GEN_DI_CLK_EXT			(1 << 20)
+#define DI_GEN_POLARITY_1			(1 << 0)
+#define DI_GEN_POLARITY_2			(1 << 1)
+#define DI_GEN_POLARITY_3			(1 << 2)
+#define DI_GEN_POLARITY_4			(1 << 3)
+#define DI_GEN_POLARITY_5			(1 << 4)
+#define DI_GEN_POLARITY_6			(1 << 5)
+#define DI_GEN_POLARITY_7			(1 << 6)
+#define DI_GEN_POLARITY_8			(1 << 7)
+
+#define DI_POL_DRDY_DATA_POLARITY		(1 << 7)
+#define DI_POL_DRDY_POLARITY_15			(1 << 4)
+
+#define DI_VSYNC_SEL_OFFSET			13
+
+#define DI0_COUNTER_RELEASE			(1 << 24)
+#define DI1_COUNTER_RELEASE			(1 << 25)
+
+static inline u32 ipu_di_read(struct ipu_di *di, unsigned offset)
+{
+	return __raw_readl(di->base + offset);
+}
+
+static inline void ipu_di_write(struct ipu_di *di, u32 value, unsigned offset)
+{
+	__raw_writel(value, di->base + offset);
+}
+
+static void ipu_di_data_wave_config(struct ipu_di *di,
+				     int wave_gen,
+				     int access_size, int component_size)
+{
+	u32 reg;
+	reg = (access_size << DI_DW_GEN_ACCESS_SIZE_OFFSET) |
+	    (component_size << DI_DW_GEN_COMPONENT_SIZE_OFFSET);
+	ipu_di_write(di, reg, DI_DW_GEN(wave_gen));
+}
+
+static void ipu_di_data_pin_config(struct ipu_di *di, int wave_gen, int di_pin, int set,
+				    int up, int down)
+{
+	u32 reg;
+
+	reg = ipu_di_read(di, DI_DW_GEN(wave_gen));
+	reg &= ~(0x3 << (di_pin * 2));
+	reg |= set << (di_pin * 2);
+	ipu_di_write(di, reg, DI_DW_GEN(wave_gen));
+
+	ipu_di_write(di, (down << 16) | up, DI_DW_SET(wave_gen, set));
+}
+
+static void ipu_di_sync_config(struct ipu_di *di, struct di_sync_config *config, int count)
+{
+	u32 reg;
+	int i;
+
+	for (i = 0; i < count; i++) {
+		struct di_sync_config *c = &config[i];
+		int wave_gen = i + 1;
+
+		pr_debug("%s %d\n", __func__, wave_gen);
+		if ((c->run_count >= 0x1000) || (c->offset_count >= 0x1000) || (c->repeat_count >= 0x1000) ||
+			(c->cnt_up >= 0x400) || (c->cnt_down >= 0x400)) {
+			dev_err(ipu_dev, "DI%d counters out of range.\n", di->id);
+			return;
+		}
+
+		reg = DI_SW_GEN0_RUN_COUNT(c->run_count) |
+			DI_SW_GEN0_RUN_SRC(c->run_src) |
+			DI_SW_GEN0_OFFSET_COUNT(c->offset_count) |
+			DI_SW_GEN0_OFFSET_SRC(c->offset_src);
+		ipu_di_write(di, reg, DI_SW_GEN0(wave_gen));
+
+		reg = DI_SW_GEN1_CNT_POL_GEN_EN(c->cnt_polarity_gen_en) |
+			DI_SW_GEN1_CNT_CLR_SRC(c->cnt_clr_src) |
+			DI_SW_GEN1_CNT_POL_TRIGGER_SRC(c->cnt_polarity_trigger_src) |
+			DI_SW_GEN1_CNT_POL_CLR_SRC(c->cnt_polarity_clr_src) |
+			DI_SW_GEN1_CNT_DOWN(c->cnt_down) |
+			DI_SW_GEN1_CNT_UP(c->cnt_up);
+
+		if (c->repeat_count == 0) {
+			/* Enable auto reload */
+			reg |= DI_SW_GEN1_AUTO_RELOAD;
+		}
+
+		ipu_di_write(di, reg, DI_SW_GEN1(wave_gen));
+
+		reg = ipu_di_read(di, DI_STP_REP(wave_gen));
+		reg &= ~(0xffff << (16 * ((wave_gen - 1) & 0x1)));
+		reg |= c->repeat_count << (16 * ((wave_gen - 1) & 0x1));
+		ipu_di_write(di, reg, DI_STP_REP(wave_gen));
+	}
+}
+
+static void ipu_di_sync_config_interlaced(struct ipu_di *di, struct ipu_di_signal_cfg *sig)
+{
+	u32 h_total = sig->width + sig->h_sync_width + sig->h_start_width + sig->h_end_width;
+	u32 v_total = sig->height + sig->v_sync_width + sig->v_start_width + sig->v_end_width;
+	u32 reg;
+	struct di_sync_config cfg[] = {
+		{
+			.run_count = h_total / 2 - 1,
+			.run_src = DI_SYNC_CLK,
+		}, {
+			.run_count = h_total - 11,
+			.run_src = DI_SYNC_CLK,
+			.cnt_down = 4,
+		}, {
+			.run_count = v_total * 2 - 1,
+			.run_src = DI_SYNC_INT_HSYNC,
+			.offset_count = 1,
+			.offset_src = DI_SYNC_INT_HSYNC,
+			.cnt_down = 4,
+		}, {
+			.run_count = v_total / 2 - 1,
+			.run_src = DI_SYNC_HSYNC,
+			.offset_count = sig->v_start_width,
+			.offset_src = DI_SYNC_HSYNC,
+			.repeat_count = 2,
+			.cnt_clr_src = DI_SYNC_VSYNC,
+		}, {
+			.run_src = DI_SYNC_HSYNC,
+			.repeat_count = sig->height / 2,
+			.cnt_clr_src = 4,
+		}, {
+			.run_count = v_total - 1,
+			.run_src = DI_SYNC_HSYNC,
+		}, {
+			.run_count = v_total / 2 - 1,
+			.run_src = DI_SYNC_HSYNC,
+			.offset_count = 9,
+			.offset_src = DI_SYNC_HSYNC,
+			.repeat_count = 2,
+			.cnt_clr_src = DI_SYNC_VSYNC,
+		}, {
+			.run_src = DI_SYNC_CLK,
+			.offset_count = sig->h_start_width,
+			.offset_src = DI_SYNC_CLK,
+			.repeat_count = sig->width,
+			.cnt_clr_src = 5,
+		}, {
+			.run_count = v_total - 1,
+			.run_src = DI_SYNC_INT_HSYNC,
+			.offset_count = v_total / 2,
+			.offset_src = DI_SYNC_INT_HSYNC,
+			.cnt_clr_src = DI_SYNC_HSYNC,
+			.cnt_down = 4,
+		}
+	};
+
+	ipu_di_sync_config(di, cfg, ARRAY_SIZE(cfg));
+
+	/* set gentime select and tag sel */
+	reg = ipu_di_read(di, DI_SW_GEN1(9));
+	reg &= 0x1FFFFFFF;
+	reg |= (3 - 1) << 29 | 0x00008000;
+	ipu_di_write(di, reg, DI_SW_GEN1(9));
+
+	ipu_di_write(di, v_total / 2 - 1, DI_SCR_CONF);
+}
+
+static void ipu_di_sync_config_noninterlaced(struct ipu_di *di,
+		struct ipu_di_signal_cfg *sig, int div)
+{
+	u32 h_total = sig->width + sig->h_sync_width + sig->h_start_width +
+		sig->h_end_width;
+	u32 v_total = sig->height + sig->v_sync_width + sig->v_start_width +
+		sig->v_end_width + (sig->v_end_width < 2 ? 1 : 0);
+	struct di_sync_config cfg[] = {
+		{
+			.run_count = h_total - 1,
+			.run_src = DI_SYNC_CLK,
+		} , {
+			.run_count = h_total - 1,
+			.run_src = DI_SYNC_CLK,
+			.offset_count = div * sig->v_to_h_sync,
+			.offset_src = DI_SYNC_CLK,
+			.cnt_polarity_gen_en = 1,
+			.cnt_polarity_trigger_src = DI_SYNC_CLK,
+			.cnt_down = sig->h_sync_width * 2,
+		} , {
+			.run_count = v_total - 1,
+			.run_src = DI_SYNC_INT_HSYNC,
+			.cnt_polarity_gen_en = 1,
+			.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,
+			.cnt_down = sig->v_sync_width * 2,
+		} , {
+			.run_src = DI_SYNC_HSYNC,
+			.offset_count = sig->v_sync_width + sig->v_start_width,
+			.offset_src = DI_SYNC_HSYNC,
+			.repeat_count = sig->height,
+			.cnt_clr_src = DI_SYNC_VSYNC,
+		} , {
+			.run_src = DI_SYNC_CLK,
+			.offset_count = sig->h_sync_width + sig->h_start_width,
+			.offset_src = DI_SYNC_CLK,
+			.repeat_count = sig->width,
+			.cnt_clr_src = 5,
+		} , {
+			/* unused */
+		} , {
+			/* unused */
+		} , {
+			/* unused */
+		} , {
+			/* unused */
+		},
+	};
+
+	ipu_di_write(di, v_total - 1, DI_SCR_CONF);
+	ipu_di_sync_config(di, cfg, ARRAY_SIZE(cfg));
+}
+
+int ipu_di_init_sync_panel(struct ipu_di *di, u32 pixel_clk, struct ipu_di_signal_cfg *sig)
+{
+	u32 reg;
+	u32 disp_gen, di_gen, vsync_cnt;
+	u32 div;
+	u32 h_total, v_total;
+	struct clk *di_clk;
+
+	dev_dbg(ipu_dev, "disp %d: panel size = %d x %d\n",
+		di->id, sig->width, sig->height);
+
+	if ((sig->v_sync_width == 0) || (sig->h_sync_width == 0))
+		return -EINVAL;
+
+	h_total = sig->width + sig->h_sync_width + sig->h_start_width + sig->h_end_width;
+	v_total = sig->height + sig->v_sync_width + sig->v_start_width + sig->v_end_width;
+
+	mutex_lock(&di_mutex);
+	ipu_get();
+
+	/* Init clocking */
+	if (sig->ext_clk) {
+		di->external_clk = true;
+		di_clk = di->clk;
+	} else {
+		di->external_clk = false;
+		di_clk = di->ipu_clk;
+	}
+
+	/*
+	 * Calculate divider
+	 * Fractional part is 4 bits,
+	 * so simply multiply by 2^4 to get fractional part.
+	 */
+	div = (clk_get_rate(di_clk) * 16) / pixel_clk;
+	if (div < 0x10)	/* Min DI disp clock divider is 1 */
+		div = 0x10;
+
+	disp_gen = ipu_cm_read(IPU_DISP_GEN);
+	disp_gen &= di->id ? ~DI1_COUNTER_RELEASE : ~DI0_COUNTER_RELEASE;
+	ipu_cm_write(disp_gen, IPU_DISP_GEN);
+
+	ipu_di_write(di, div, DI_BS_CLKGEN0);
+
+	/* Setup pixel clock timing */
+	/* Down time is half of period */
+	ipu_di_write(di, (div / 16) << 16, DI_BS_CLKGEN1);
+
+	ipu_di_data_wave_config(di, SYNC_WAVE, div / 16 - 1, div / 16 - 1);
+	ipu_di_data_pin_config(di, SYNC_WAVE, DI_PIN15, 3, 0, div / 16 * 2);
+
+	div = div / 16;		/* Now divider is integer portion */
+
+	di_gen = 0;
+	if (sig->ext_clk)
+		di_gen |= DI_GEN_DI_CLK_EXT;
+
+	if (sig->interlaced) {
+		ipu_di_sync_config_interlaced(di, sig);
+
+		/* set y_sel = 1 */
+		di_gen |= 0x10000000;
+		di_gen |= DI_GEN_POLARITY_5;
+		di_gen |= DI_GEN_POLARITY_8;
+
+		vsync_cnt = 7;
+
+		if (sig->Hsync_pol)
+			di_gen |= DI_GEN_POLARITY_3;
+		if (sig->Vsync_pol)
+			di_gen |= DI_GEN_POLARITY_2;
+	} else {
+		ipu_di_sync_config_noninterlaced(di, sig, div);
+
+		vsync_cnt = 3;
+
+		if (sig->Hsync_pol)
+			di_gen |= DI_GEN_POLARITY_2;
+		if (sig->Vsync_pol)
+			di_gen |= DI_GEN_POLARITY_3;
+	}
+
+	ipu_di_write(di, di_gen, DI_GENERAL);
+	ipu_di_write(di, (--vsync_cnt << DI_VSYNC_SEL_OFFSET) | 0x00000002,
+		     DI_SYNC_AS_GEN);
+
+	reg = ipu_di_read(di, DI_POL);
+	reg &= ~(DI_POL_DRDY_DATA_POLARITY | DI_POL_DRDY_POLARITY_15);
+
+	if (sig->enable_pol)
+		reg |= DI_POL_DRDY_POLARITY_15;
+	if (sig->data_pol)
+		reg |= DI_POL_DRDY_DATA_POLARITY;
+
+	ipu_di_write(di, reg, DI_POL);
+
+	ipu_put();
+	mutex_unlock(&di_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_di_init_sync_panel);
+
+int ipu_di_enable(struct ipu_di *di)
+{
+	u32 reg;
+
+	ipu_get();
+	reg = ipu_cm_read(IPU_DISP_GEN);
+	if (di->id)
+		reg |= DI1_COUNTER_RELEASE;
+	else
+		reg |= DI0_COUNTER_RELEASE;
+	ipu_cm_write(reg, IPU_DISP_GEN);
+
+	if (di->external_clk)
+		clk_enable(di->clk);
+
+	ipu_module_enable(di->module);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_di_enable);
+
+int ipu_di_disable(struct ipu_di *di)
+{
+	u32 reg;
+
+	ipu_module_disable(di->module);
+	ipu_put();
+
+	if (di->external_clk)
+		clk_disable(di->clk);
+
+	reg = ipu_cm_read(IPU_DISP_GEN);
+	if (di->id)
+		reg &= ~DI1_COUNTER_RELEASE;
+	else
+		reg &= ~DI0_COUNTER_RELEASE;
+	ipu_cm_write(reg, IPU_DISP_GEN);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_di_disable);
+
+static DEFINE_MUTEX(ipu_di_lock);
+
+struct ipu_di *ipu_di_get(int disp)
+{
+	struct ipu_di *di;
+
+	if (disp > 1)
+		return ERR_PTR(-EINVAL);
+
+	di = &dis[disp];
+
+	mutex_lock(&ipu_di_lock);
+
+	if (!di->initialized) {
+		di = ERR_PTR(-ENOSYS);
+		goto out;
+	}
+
+	if (di->inuse) {
+		di = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	di->inuse = true;
+out:
+	mutex_unlock(&ipu_di_lock);
+
+	return di;
+}
+EXPORT_SYMBOL(ipu_di_get);
+
+void ipu_di_put(struct ipu_di *di)
+{
+	mutex_lock(&ipu_di_lock);
+
+	di->inuse = false;
+
+	mutex_unlock(&ipu_di_lock);
+}
+EXPORT_SYMBOL(ipu_di_put);
+
+int ipu_di_init(struct platform_device *pdev, int id, unsigned long base,
+		u32 module, struct clk *ipu_clk)
+{
+	char *clkid;
+
+	if (id > 1)
+		return -EINVAL;
+
+	if (id)
+		clkid = "di1";
+	else
+		clkid = "di0";
+
+	ipu_dev = &pdev->dev;
+
+	dis[id].clk = clk_get(&pdev->dev, clkid);
+	dis[id].module = module;
+	dis[id].id = id;
+	dis[id].ipu_clk = ipu_clk;
+	dis[id].base = ioremap(base, PAGE_SIZE);
+	dis[id].initialized = true;
+	dis[id].inuse = false;
+	if (!dis[id].base)
+		return -ENOMEM;
+
+	/* Set MCU_T to divide MCU access window into 2 */
+	ipu_cm_write(0x00400000L | (IPU_MCU_T_DEFAULT << 18), IPU_DISP_GEN);
+
+	return 0;
+}
+
+void ipu_di_exit(struct platform_device *pdev, int id)
+{
+	clk_put(dis[id].clk);
+	iounmap(dis[id].base);
+	dis[id].initialized = false;
+}
diff --git a/drivers/mfd/imx-ipu-v3/ipu-dmfc.c b/drivers/mfd/imx-ipu-v3/ipu-dmfc.c
new file mode 100644
index 0000000..3d47a76
--- /dev/null
+++ b/drivers/mfd/imx-ipu-v3/ipu-dmfc.c
@@ -0,0 +1,355 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/mfd/imx-ipu-v3.h>
+
+#include "ipu-prv.h"
+
+#define DMFC_RD_CHAN		0x0000
+#define DMFC_WR_CHAN		0x0004
+#define DMFC_WR_CHAN_DEF	0x0008
+#define DMFC_DP_CHAN		0x000c
+#define DMFC_DP_CHAN_DEF	0x0010
+#define DMFC_GENERAL1		0x0014
+#define DMFC_GENERAL2		0x0018
+#define DMFC_IC_CTRL		0x001c
+#define DMFC_STAT		0x0020
+
+#define DMFC_WR_CHAN_1_28		0
+#define DMFC_WR_CHAN_2_41		8
+#define DMFC_WR_CHAN_1C_42		16
+#define DMFC_WR_CHAN_2C_43		24
+
+#define DMFC_DP_CHAN_5B_23		0
+#define DMFC_DP_CHAN_5F_27		8
+#define DMFC_DP_CHAN_6B_24		16
+#define DMFC_DP_CHAN_6F_29		24
+
+#define DMFC_FIFO_SIZE_64		(3 << 3)
+#define DMFC_FIFO_SIZE_128		(2 << 3)
+#define DMFC_FIFO_SIZE_256		(1 << 3)
+#define DMFC_FIFO_SIZE_512		(0 << 3)
+
+#define DMFC_SEGMENT(x)			((x & 0x7) << 0)
+#define DMFC_BURSTSIZE_32		(0 << 6)
+#define DMFC_BURSTSIZE_16		(1 << 6)
+#define DMFC_BURSTSIZE_8		(2 << 6)
+#define DMFC_BURSTSIZE_4		(3 << 6)
+
+static struct device *ipu_dev;
+
+struct dmfc_channel {
+	int		ipu_channel;
+	unsigned long	channel_reg;
+	unsigned long	shift;
+	unsigned	eot_shift;
+	unsigned	slots;
+	unsigned	max_fifo_lines;
+	unsigned	slotmask;
+	unsigned	segment;
+};
+
+static struct dmfc_channel dmfcs[] = {
+	{
+		.ipu_channel	= 23,
+		.channel_reg	= DMFC_DP_CHAN,
+		.shift		= DMFC_DP_CHAN_5B_23,
+		.eot_shift	= 20,
+		.max_fifo_lines	= 3,
+	}, {
+		.ipu_channel	= 24,
+		.channel_reg	= DMFC_DP_CHAN,
+		.shift		= DMFC_DP_CHAN_6B_24,
+		.eot_shift	= 22,
+		.max_fifo_lines	= 1,
+	}, {
+		.ipu_channel	= 27,
+		.channel_reg	= DMFC_DP_CHAN,
+		.shift		= DMFC_DP_CHAN_5F_27,
+		.eot_shift	= 21,
+		.max_fifo_lines	= 2,
+	}, {
+		.ipu_channel	= 28,
+		.channel_reg	= DMFC_WR_CHAN,
+		.shift		= DMFC_WR_CHAN_1_28,
+		.eot_shift	= 16,
+		.max_fifo_lines	= 2,
+	}, {
+		.ipu_channel	= 29,
+		.channel_reg	= DMFC_DP_CHAN,
+		.shift		= DMFC_DP_CHAN_6F_29,
+		.eot_shift	= 23,
+		.max_fifo_lines	= 1,
+	},
+};
+
+#define DMFC_NUM_CHANNELS	ARRAY_SIZE(dmfcs)
+
+static int dmfc_use_count;
+static void __iomem *dmfc_regs;
+static unsigned long dmfc_bandwidth_per_slot;
+static DEFINE_MUTEX(dmfc_mutex);
+
+int ipu_dmfc_enable_channel(struct dmfc_channel *dmfc)
+{
+	mutex_lock(&dmfc_mutex);
+	ipu_get();
+
+	if (!dmfc_use_count)
+		ipu_module_enable(IPU_CONF_DMFC_EN);
+
+	dmfc_use_count++;
+
+	mutex_unlock(&dmfc_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_dmfc_enable_channel);
+
+void ipu_dmfc_disable_channel(struct dmfc_channel *dmfc)
+{
+	mutex_lock(&dmfc_mutex);
+
+	dmfc_use_count--;
+
+	if (!dmfc_use_count)
+		ipu_module_disable(IPU_CONF_DMFC_EN);
+
+	if (dmfc_use_count < 0)
+		dmfc_use_count = 0;
+
+	ipu_put();
+	mutex_unlock(&dmfc_mutex);
+}
+EXPORT_SYMBOL(ipu_dmfc_disable_channel);
+
+static int ipu_dmfc_setup_channel(struct dmfc_channel *dmfc, int slots, int segment)
+{
+	u32 val, field;
+
+	dev_dbg(ipu_dev, "dmfc: using %d slots starting from segment %d for IPU channel %d\n",
+			slots, segment, dmfc->ipu_channel);
+
+	if (!dmfc)
+		return -EINVAL;
+
+	switch (slots) {
+	case 1:
+		field = DMFC_FIFO_SIZE_64;
+		break;
+	case 2:
+		field = DMFC_FIFO_SIZE_128;
+		break;
+	case 4:
+		field = DMFC_FIFO_SIZE_256;
+		break;
+	case 8:
+		field = DMFC_FIFO_SIZE_512;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	field |= DMFC_SEGMENT(segment) | DMFC_BURSTSIZE_8;
+
+	val = readl(dmfc_regs + dmfc->channel_reg);
+
+	val &= ~(0xff << dmfc->shift);
+	val |= field << dmfc->shift;
+
+	writel(val, dmfc_regs + dmfc->channel_reg);
+
+	dmfc->slots = slots;
+	dmfc->segment = segment;
+	dmfc->slotmask = ((1 << slots) - 1) << segment;
+
+	return 0;
+}
+
+static int dmfc_bandwidth_to_slots(unsigned long bandwidth)
+{
+	int slots = 1;
+
+	while (slots * dmfc_bandwidth_per_slot < bandwidth)
+		slots *= 2;
+
+	return slots;
+}
+
+static int dmfc_find_slots(int slots)
+{
+	unsigned slotmask_need, slotmask_used = 0;
+	int i, segment = 0;
+
+	slotmask_need = (1 << slots) - 1;
+
+	for (i = 0; i < DMFC_NUM_CHANNELS; i++)
+		slotmask_used |= dmfcs[i].slotmask;
+
+	while (slotmask_need <= 0xff) {
+		if (!(slotmask_used & slotmask_need))
+			return segment;
+
+		slotmask_need <<= 1;
+		segment++;
+	}
+
+	return -EBUSY;
+}
+
+void ipu_dmfc_free_bandwidth(struct dmfc_channel *dmfc)
+{
+	int i;
+
+	dev_dbg(ipu_dev, "dmfc: freeing %d slots starting from segment %d\n",
+			dmfc->slots, dmfc->segment);
+
+	mutex_lock(&dmfc_mutex);
+
+	if (!dmfc->slots)
+		goto out;
+
+	dmfc->slotmask = 0;
+	dmfc->slots = 0;
+	dmfc->segment = 0;
+
+	for (i = 0; i < ARRAY_SIZE(dmfcs); i++)
+		dmfcs[i].slotmask = 0;
+
+	for (i = 0; i < ARRAY_SIZE(dmfcs); i++) {
+		if (dmfcs[i].slots > 0) {
+			dmfcs[i].segment = dmfc_find_slots(dmfcs[i].slots);
+			dmfcs[i].slotmask = ((1 << dmfcs[i].slots) - 1) << dmfcs[i].segment;
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(dmfcs); i++) {
+		if (dmfcs[i].slots > 0)
+			ipu_dmfc_setup_channel(&dmfcs[i], dmfcs[i].slots, dmfcs[i].segment);
+	}
+out:
+	mutex_unlock(&dmfc_mutex);
+}
+EXPORT_SYMBOL(ipu_dmfc_free_bandwidth);
+
+int ipu_dmfc_alloc_bandwidth(struct dmfc_channel *dmfc,
+		unsigned long bandwidth_pixel_per_second)
+{
+	int slots = dmfc_bandwidth_to_slots(bandwidth_pixel_per_second);
+	int segment = 0, ret = 0;
+
+	dev_dbg(ipu_dev, "dmfc: trying to allocate %ldMpixel/s for IPU channel %d\n",
+			bandwidth_pixel_per_second / 1000000, dmfc->ipu_channel);
+
+	ipu_dmfc_free_bandwidth(dmfc);
+
+	ipu_get();
+	mutex_lock(&dmfc_mutex);
+
+	if (slots > 8) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	segment = dmfc_find_slots(slots);
+	if (segment < 0) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ipu_dmfc_setup_channel(dmfc, slots, segment);
+
+out:
+	ipu_put();
+	mutex_unlock(&dmfc_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL(ipu_dmfc_alloc_bandwidth);
+
+int ipu_dmfc_init_channel(struct dmfc_channel *dmfc, int width)
+{
+	u32 dmfc_gen1;
+
+	ipu_get();
+
+	dmfc_gen1 = readl(dmfc_regs + DMFC_GENERAL1);
+
+	if ((dmfc->slots * 64 * 4) / width > dmfc->max_fifo_lines)
+		dmfc_gen1 |= 1 << dmfc->eot_shift;
+	else
+		dmfc_gen1 &= ~(1 << dmfc->eot_shift);
+
+	writel(dmfc_gen1, dmfc_regs + DMFC_GENERAL1);
+
+	ipu_put();
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_dmfc_init_channel);
+
+struct dmfc_channel *ipu_dmfc_get(int ipu_channel)
+{
+	int i;
+
+	for (i = 0; i < DMFC_NUM_CHANNELS; i++)
+		if (dmfcs[i].ipu_channel == ipu_channel)
+			return &dmfcs[i];
+	return NULL;
+}
+EXPORT_SYMBOL(ipu_dmfc_get);
+
+void ipu_dmfc_put(struct dmfc_channel *dmfc)
+{
+	ipu_dmfc_free_bandwidth(dmfc);
+}
+EXPORT_SYMBOL(ipu_dmfc_put);
+
+int ipu_dmfc_init(struct platform_device *pdev, unsigned long base,
+		struct clk *ipu_clk)
+{
+	dmfc_regs = ioremap(base, PAGE_SIZE);
+
+	if (!dmfc_regs)
+		return -ENOMEM;
+
+	ipu_dev = &pdev->dev;
+
+	writel(0x0, dmfc_regs + DMFC_WR_CHAN);
+	writel(0x0, dmfc_regs + DMFC_DP_CHAN);
+
+	/*
+	 * We have a total bandwidth of clkrate * 4pixel divided
+	 * into 8 slots.
+	 */
+	dmfc_bandwidth_per_slot = clk_get_rate(ipu_clk) / 4;
+
+	dev_dbg(ipu_dev, "dmfc: 8 slots with %ldMpixel/s bandwidth each\n",
+			dmfc_bandwidth_per_slot / 1000000);
+
+	writel(0x202020f6, dmfc_regs + DMFC_WR_CHAN_DEF);
+	writel(0x2020f6f6, dmfc_regs + DMFC_DP_CHAN_DEF);
+	writel(0x00000003, dmfc_regs + DMFC_GENERAL1);
+
+	return 0;
+}
+
+void ipu_dmfc_exit(struct platform_device *pdev)
+{
+	iounmap(dmfc_regs);
+}
diff --git a/drivers/mfd/imx-ipu-v3/ipu-dp.c b/drivers/mfd/imx-ipu-v3/ipu-dp.c
new file mode 100644
index 0000000..57a7fec
--- /dev/null
+++ b/drivers/mfd/imx-ipu-v3/ipu-dp.c
@@ -0,0 +1,476 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/mfd/imx-ipu-v3.h>
+#include <linux/err.h>
+
+#include "ipu-prv.h"
+
+#define DP_SYNC 0
+#define DP_ASYNC0 0x60
+#define DP_ASYNC1 0xBC
+
+#define DP_COM_CONF(flow)		(ipu_dp_base + flow)
+#define DP_GRAPH_WIND_CTRL(flow)	(ipu_dp_base + 0x0004 + flow)
+#define DP_FG_POS(flow)			(ipu_dp_base + 0x0008 + flow)
+#define DP_CSC_A_0(flow)		(ipu_dp_base + 0x0044 + flow)
+#define DP_CSC_A_1(flow)		(ipu_dp_base + 0x0048 + flow)
+#define DP_CSC_A_2(flow)		(ipu_dp_base + 0x004C + flow)
+#define DP_CSC_A_3(flow)		(ipu_dp_base + 0x0050 + flow)
+#define DP_CSC_0(flow)			(ipu_dp_base + 0x0054 + flow)
+#define DP_CSC_1(flow)			(ipu_dp_base + 0x0058 + flow)
+
+#define DP_COM_CONF_FG_EN		(1 << 0)
+#define DP_COM_CONF_GWSEL		(1 << 1)
+#define DP_COM_CONF_GWAM		(1 << 2)
+#define DP_COM_CONF_GWCKE		(1 << 3)
+#define DP_COM_CONF_CSC_DEF_MASK	(3 << 8)
+#define DP_COM_CONF_CSC_DEF_OFFSET	8
+#define DP_COM_CONF_CSC_DEF_FG		(3 << 8)
+#define DP_COM_CONF_CSC_DEF_BG		(2 << 8)
+#define DP_COM_CONF_CSC_DEF_BOTH	(1 << 8)
+
+struct ipu_dp {
+	u32 flow;
+	bool in_use;
+};
+
+static struct ipu_dp ipu_dp[3];
+static struct device *ipu_dev;
+
+static u32 ipu_flows[] = {DP_SYNC, DP_ASYNC0, DP_ASYNC1};
+
+enum csc_type_t {
+	RGB2YUV = 0,
+	YUV2RGB,
+	RGB2RGB,
+	YUV2YUV,
+	CSC_NONE,
+	CSC_NUM
+};
+
+static void __iomem *ipu_dp_base;
+static int dp_use_count;
+static DEFINE_MUTEX(dp_mutex);
+
+/*     Y = R *  .299 + G *  .587 + B *  .114;
+       U = R * -.169 + G * -.332 + B *  .500 + 128.;
+       V = R *  .500 + G * -.419 + B * -.0813 + 128.;*/
+static const int rgb2ycbcr_coeff[5][3] = {
+	{ 153, 301, 58, },
+	{ -87, -170, 0x0100, },
+	{ 0x100, -215, -42, },
+	{ 0x0000, 0x0200, 0x0200, },	/* B0, B1, B2 */
+	{ 0x2, 0x2, 0x2, },	/* S0, S1, S2 */
+};
+
+/*     R = (1.164 * (Y - 16)) + (1.596 * (Cr - 128));
+       G = (1.164 * (Y - 16)) - (0.392 * (Cb - 128)) - (0.813 * (Cr - 128));
+       B = (1.164 * (Y - 16)) + (2.017 * (Cb - 128); */
+static const int ycbcr2rgb_coeff[5][3] = {
+	{ 0x095, 0x000, 0x0CC, },
+	{ 0x095, 0x3CE, 0x398, },
+	{ 0x095, 0x0FF, 0x000, },
+	{ 0x3E42, 0x010A, 0x3DD6, },	/*B0,B1,B2 */
+	{ 0x1, 0x1, 0x1, },	/*S0,S1,S2 */
+};
+
+/* Please keep S0, S1 and S2 as 0x2 by using this conversion */
+static int _rgb_to_yuv(int n, int red, int green, int blue)
+{
+	int c;
+
+	c = red * rgb2ycbcr_coeff[n][0];
+	c += green * rgb2ycbcr_coeff[n][1];
+	c += blue * rgb2ycbcr_coeff[n][2];
+	c /= 16;
+	c += rgb2ycbcr_coeff[3][n] * 4;
+	c += 8;
+	c /= 16;
+	if (c < 0)
+		c = 0;
+	if (c > 255)
+		c = 255;
+	return c;
+}
+
+struct dp_csc_param_t {
+	int mode;
+	void *coeff;
+};
+
+/*
+ * Row is for BG:	RGB2YUV YUV2RGB RGB2RGB YUV2YUV CSC_NONE
+ * Column is for FG:	RGB2YUV YUV2RGB RGB2RGB YUV2YUV CSC_NONE
+ */
+static struct dp_csc_param_t dp_csc_array[CSC_NUM][CSC_NUM] = {
+	{
+		{ DP_COM_CONF_CSC_DEF_BOTH, &rgb2ycbcr_coeff, },
+		{ 0, 0, },
+		{ 0, 0, },
+		{ DP_COM_CONF_CSC_DEF_BG, &rgb2ycbcr_coeff, },
+		{ DP_COM_CONF_CSC_DEF_BG, &rgb2ycbcr_coeff, },
+	}, {
+		{ 0, 0, },
+		{ DP_COM_CONF_CSC_DEF_BOTH, &ycbcr2rgb_coeff, },
+		{ DP_COM_CONF_CSC_DEF_BG, &ycbcr2rgb_coeff, },
+		{ 0, 0, },
+		{ DP_COM_CONF_CSC_DEF_BG, &ycbcr2rgb_coeff, },
+	}, {
+		{ 0, 0, },
+		{ DP_COM_CONF_CSC_DEF_FG, &ycbcr2rgb_coeff, },
+		{ 0, 0, },
+		{ 0, 0, },
+		{ 0, 0, },
+	}, {
+		{ DP_COM_CONF_CSC_DEF_FG, &rgb2ycbcr_coeff, },
+		{ 0, 0, },
+		{ 0, 0, },
+		{ 0, 0, },
+		{ 0, 0, },
+	}, {
+		{ DP_COM_CONF_CSC_DEF_FG, &rgb2ycbcr_coeff, },
+		{ DP_COM_CONF_CSC_DEF_FG, &ycbcr2rgb_coeff, },
+		{ 0, 0, },
+		{ 0, 0, },
+		{ 0, 0, },
+	}
+};
+
+static enum csc_type_t fg_csc_type = CSC_NONE, bg_csc_type = CSC_NONE;
+
+static int color_key_4rgb = 1;
+
+int ipu_dp_set_color_key(struct ipu_dp *dp, bool enable, u32 color_key)
+{
+	u32 reg;
+	int y, u, v;
+	int red, green, blue;
+
+	mutex_lock(&dp_mutex);
+
+	color_key_4rgb = 1;
+	/* Transform color key from rgb to yuv if CSC is enabled */
+	if (((fg_csc_type == RGB2YUV) && (bg_csc_type == YUV2YUV)) ||
+			((fg_csc_type == YUV2YUV) && (bg_csc_type == RGB2YUV)) ||
+			((fg_csc_type == YUV2YUV) && (bg_csc_type == YUV2YUV)) ||
+			((fg_csc_type == YUV2RGB) && (bg_csc_type == YUV2RGB))) {
+
+		dev_dbg(ipu_dev, "color key 0x%x need change to yuv fmt\n", color_key);
+
+		red = (color_key >> 16) & 0xFF;
+		green = (color_key >> 8) & 0xFF;
+		blue = color_key & 0xFF;
+
+		y = _rgb_to_yuv(0, red, green, blue);
+		u = _rgb_to_yuv(1, red, green, blue);
+		v = _rgb_to_yuv(2, red, green, blue);
+		color_key = (y << 16) | (u << 8) | v;
+
+		color_key_4rgb = 0;
+
+		dev_dbg(ipu_dev, "color key change to yuv fmt 0x%x\n", color_key);
+	}
+
+	if (enable) {
+		reg = __raw_readl(DP_GRAPH_WIND_CTRL(dp->flow)) & 0xFF000000L;
+		__raw_writel(reg | color_key, DP_GRAPH_WIND_CTRL(dp->flow));
+
+		reg = __raw_readl(DP_COM_CONF(dp->flow));
+		__raw_writel(reg | DP_COM_CONF_GWCKE, DP_COM_CONF(dp->flow));
+	} else {
+		reg = __raw_readl(DP_COM_CONF(dp->flow));
+		__raw_writel(reg & ~DP_COM_CONF_GWCKE, DP_COM_CONF(dp->flow));
+	}
+
+	reg = ipu_cm_read(IPU_SRM_PRI2) | 0x8;
+	ipu_cm_write(reg, IPU_SRM_PRI2);
+
+	mutex_unlock(&dp_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_dp_set_color_key);
+
+int ipu_dp_set_global_alpha(struct ipu_dp *dp, bool enable, u8 alpha, bool bg_chan)
+{
+	u32 reg;
+
+	mutex_lock(&dp_mutex);
+
+	reg = __raw_readl(DP_COM_CONF(dp->flow));
+	if (bg_chan)
+		reg &= ~DP_COM_CONF_GWSEL;
+	else
+		reg |= DP_COM_CONF_GWSEL;
+	__raw_writel(reg, DP_COM_CONF(dp->flow));
+
+	if (enable) {
+		reg = __raw_readl(DP_GRAPH_WIND_CTRL(dp->flow)) & 0x00FFFFFFL;
+		__raw_writel(reg | ((u32) alpha << 24),
+			     DP_GRAPH_WIND_CTRL(dp->flow));
+
+		reg = __raw_readl(DP_COM_CONF(dp->flow));
+		__raw_writel(reg | DP_COM_CONF_GWAM, DP_COM_CONF(dp->flow));
+	} else {
+		reg = __raw_readl(DP_COM_CONF(dp->flow));
+		__raw_writel(reg & ~DP_COM_CONF_GWAM, DP_COM_CONF(dp->flow));
+	}
+
+	reg = ipu_cm_read(IPU_SRM_PRI2) | 0x8;
+	ipu_cm_write(reg, IPU_SRM_PRI2);
+
+	mutex_unlock(&dp_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_dp_set_global_alpha);
+
+int ipu_dp_set_window_pos(struct ipu_dp *dp, u16 x_pos, u16 y_pos)
+{
+	u32 reg;
+
+	mutex_lock(&dp_mutex);
+
+	__raw_writel((x_pos << 16) | y_pos, DP_FG_POS(dp->flow));
+
+	reg = ipu_cm_read(IPU_SRM_PRI2);
+	reg |= 0x8;
+	ipu_cm_write(reg, IPU_SRM_PRI2);
+
+	mutex_unlock(&dp_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_dp_set_window_pos);
+
+#define mask_a(a) ((u32)(a) & 0x3FF)
+#define mask_b(b) ((u32)(b) & 0x3FFF)
+
+void __ipu_dp_csc_setup(int dp, struct dp_csc_param_t dp_csc_param,
+			bool srm_mode_update)
+{
+	u32 reg;
+	const int (*coeff)[5][3];
+
+	if (dp_csc_param.mode >= 0) {
+		reg = __raw_readl(DP_COM_CONF(dp));
+		reg &= ~DP_COM_CONF_CSC_DEF_MASK;
+		reg |= dp_csc_param.mode;
+		__raw_writel(reg, DP_COM_CONF(dp));
+	}
+
+	coeff = dp_csc_param.coeff;
+
+	if (coeff) {
+		__raw_writel(mask_a((*coeff)[0][0]) |
+				(mask_a((*coeff)[0][1]) << 16), DP_CSC_A_0(dp));
+		__raw_writel(mask_a((*coeff)[0][2]) |
+				(mask_a((*coeff)[1][0]) << 16), DP_CSC_A_1(dp));
+		__raw_writel(mask_a((*coeff)[1][1]) |
+				(mask_a((*coeff)[1][2]) << 16), DP_CSC_A_2(dp));
+		__raw_writel(mask_a((*coeff)[2][0]) |
+				(mask_a((*coeff)[2][1]) << 16), DP_CSC_A_3(dp));
+		__raw_writel(mask_a((*coeff)[2][2]) |
+				(mask_b((*coeff)[3][0]) << 16) |
+				((*coeff)[4][0] << 30), DP_CSC_0(dp));
+		__raw_writel(mask_b((*coeff)[3][1]) | ((*coeff)[4][1] << 14) |
+				(mask_b((*coeff)[3][2]) << 16) |
+				((*coeff)[4][2] << 30), DP_CSC_1(dp));
+	}
+
+	if (srm_mode_update) {
+		reg = ipu_cm_read(IPU_SRM_PRI2) | 0x8;
+		ipu_cm_write(reg, IPU_SRM_PRI2);
+	}
+}
+
+int ipu_dp_setup_channel(struct ipu_dp *dp, u32 in_pixel_fmt,
+		 u32 out_pixel_fmt, int bg)
+{
+	int in_fmt, out_fmt;
+	enum csc_type_t *csc_type;
+	u32 reg;
+
+	ipu_get();
+
+	if (bg)
+		csc_type = &bg_csc_type;
+	else
+		csc_type = &fg_csc_type;
+
+	in_fmt = format_to_colorspace(in_pixel_fmt);
+	out_fmt = format_to_colorspace(out_pixel_fmt);
+
+	if (in_fmt == RGB) {
+		if (out_fmt == RGB)
+			*csc_type = RGB2RGB;
+		else
+			*csc_type = RGB2YUV;
+	} else {
+		if (out_fmt == RGB)
+			*csc_type = YUV2RGB;
+		else
+			*csc_type = YUV2YUV;
+	}
+
+	/* Transform color key from rgb to yuv if CSC is enabled */
+	reg = __raw_readl(DP_COM_CONF(dp->flow));
+	if (color_key_4rgb && (reg & DP_COM_CONF_GWCKE) &&
+			(((fg_csc_type == RGB2YUV) && (bg_csc_type == YUV2YUV)) ||
+			 ((fg_csc_type == YUV2YUV) && (bg_csc_type == RGB2YUV)) ||
+			 ((fg_csc_type == YUV2YUV) && (bg_csc_type == YUV2YUV)) ||
+			 ((fg_csc_type == YUV2RGB) && (bg_csc_type == YUV2RGB)))) {
+		int red, green, blue;
+		int y, u, v;
+		u32 color_key = __raw_readl(DP_GRAPH_WIND_CTRL(dp->flow)) & 0xFFFFFFL;
+
+		dev_dbg(ipu_dev, "_ipu_dp_init color key 0x%x need change to yuv fmt!\n", color_key);
+
+		red = (color_key >> 16) & 0xFF;
+		green = (color_key >> 8) & 0xFF;
+		blue = color_key & 0xFF;
+
+		y = _rgb_to_yuv(0, red, green, blue);
+		u = _rgb_to_yuv(1, red, green, blue);
+		v = _rgb_to_yuv(2, red, green, blue);
+		color_key = (y << 16) | (u << 8) | v;
+
+		reg = __raw_readl(DP_GRAPH_WIND_CTRL(dp->flow)) & 0xFF000000L;
+		__raw_writel(reg | color_key, DP_GRAPH_WIND_CTRL(dp->flow));
+		color_key_4rgb = 0;
+
+		dev_dbg(ipu_dev, "_ipu_dp_init color key change to yuv fmt 0x%x!\n", color_key);
+	}
+
+	__ipu_dp_csc_setup(dp->flow, dp_csc_array[bg_csc_type][fg_csc_type], true);
+
+	ipu_put();
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_dp_setup_channel);
+
+int ipu_dp_enable_channel(struct ipu_dp *dp)
+{
+	mutex_lock(&dp_mutex);
+	ipu_get();
+
+	if (!dp_use_count)
+		ipu_module_enable(IPU_CONF_DP_EN);
+
+	dp_use_count++;
+
+	mutex_unlock(&dp_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_dp_enable_channel);
+
+void ipu_dp_disable_channel(struct ipu_dp *dp)
+{
+	mutex_lock(&dp_mutex);
+
+	dp_use_count--;
+
+	if (!dp_use_count)
+		ipu_module_disable(IPU_CONF_DP_EN);
+
+	if (dp_use_count < 0)
+		dp_use_count = 0;
+
+	ipu_put();
+	mutex_unlock(&dp_mutex);
+}
+EXPORT_SYMBOL(ipu_dp_disable_channel);
+
+void ipu_dp_enable_fg(struct ipu_dp *dp)
+{
+	u32 reg;
+
+	/* Enable FG channel */
+	reg = __raw_readl(DP_COM_CONF(DP_SYNC));
+	__raw_writel(reg | DP_COM_CONF_FG_EN, DP_COM_CONF(DP_SYNC));
+
+	reg = ipu_cm_read(IPU_SRM_PRI2);
+	reg |= 0x8;
+	ipu_cm_write(reg, IPU_SRM_PRI2);
+}
+EXPORT_SYMBOL(ipu_dp_enable_fg);
+
+void ipu_dp_disable_fg(struct ipu_dp *dp)
+{
+	u32 reg, csc;
+
+	ipu_get();
+
+	reg = __raw_readl(DP_COM_CONF(DP_SYNC));
+	csc = reg & DP_COM_CONF_CSC_DEF_MASK;
+	if (csc == DP_COM_CONF_CSC_DEF_FG)
+		reg &= ~DP_COM_CONF_CSC_DEF_MASK;
+
+	reg &= ~DP_COM_CONF_FG_EN;
+	__raw_writel(reg, DP_COM_CONF(DP_SYNC));
+
+	reg = ipu_cm_read(IPU_SRM_PRI2) | 0x8;
+	ipu_cm_write(reg, IPU_SRM_PRI2);
+
+	ipu_put();
+}
+EXPORT_SYMBOL(ipu_dp_disable_fg);
+
+struct ipu_dp *ipu_dp_get(unsigned int flow)
+{
+	struct ipu_dp *dp;
+
+	if (flow > 2)
+		return ERR_PTR(-EINVAL);
+
+	dp = &ipu_dp[flow];
+
+	if (dp->in_use)
+		return ERR_PTR(-EBUSY);
+
+	dp->in_use = true;
+	dp->flow = ipu_flows[flow];
+
+	return dp;
+}
+EXPORT_SYMBOL(ipu_dp_get);
+
+void ipu_dp_put(struct ipu_dp *dp)
+{
+	dp->in_use = false;
+}
+EXPORT_SYMBOL(ipu_dp_put);
+
+int ipu_dp_init(struct platform_device *pdev, unsigned long base)
+{
+	ipu_dp_base = ioremap(base, PAGE_SIZE);
+	if (!ipu_dp_base)
+		return -ENOMEM;
+
+	ipu_dev = &pdev->dev;
+
+	return 0;
+}
+
+void ipu_dp_exit(struct platform_device *pdev)
+{
+	 iounmap(ipu_dp_base);
+}
diff --git a/drivers/mfd/imx-ipu-v3/ipu-prv.h b/drivers/mfd/imx-ipu-v3/ipu-prv.h
new file mode 100644
index 0000000..339b554
--- /dev/null
+++ b/drivers/mfd/imx-ipu-v3/ipu-prv.h
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#ifndef __IPU_PRV_H__
+#define __IPU_PRV_H__
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <mach/hardware.h>
+
+#define MX51_IPU_CHANNEL_CSI0			 0
+#define MX51_IPU_CHANNEL_CSI1			 1
+#define MX51_IPU_CHANNEL_CSI2			 2
+#define MX51_IPU_CHANNEL_CSI3			 3
+#define MX51_IPU_CHANNEL_MEM_BG_SYNC		23
+#define MX51_IPU_CHANNEL_MEM_FG_SYNC		27
+#define MX51_IPU_CHANNEL_MEM_DC_SYNC		28
+#define MX51_IPU_CHANNEL_MEM_FG_SYNC_ALPHA	31
+#define MX51_IPU_CHANNEL_MEM_DC_ASYNC		41
+#define MX51_IPU_CHANNEL_ROT_ENC_MEM		45
+#define MX51_IPU_CHANNEL_ROT_VF_MEM		46
+#define MX51_IPU_CHANNEL_ROT_PP_MEM		47
+#define MX51_IPU_CHANNEL_ROT_ENC_MEM_OUT	48
+#define MX51_IPU_CHANNEL_ROT_VF_MEM_OUT		49
+#define MX51_IPU_CHANNEL_ROT_PP_MEM_OUT		50
+#define MX51_IPU_CHANNEL_MEM_BG_SYNC_ALPHA	51
+
+#define IPU_DISP0_BASE		0x00000000
+#define IPU_MCU_T_DEFAULT	8
+#define IPU_DISP1_BASE		(IPU_MCU_T_DEFAULT << 25)
+#define IPU_CM_REG_BASE		0x1e000000
+#define IPU_IDMAC_REG_BASE	0x1e008000
+#define IPU_ISP_REG_BASE	0x1e010000
+#define IPU_DP_REG_BASE		0x1e018000
+#define IPU_IC_REG_BASE		0x1e020000
+#define IPU_IRT_REG_BASE	0x1e028000
+#define IPU_CSI0_REG_BASE	0x1e030000
+#define IPU_CSI1_REG_BASE	0x1e038000
+#define IPU_DI0_REG_BASE	0x1e040000
+#define IPU_DI1_REG_BASE	0x1e048000
+#define IPU_SMFC_REG_BASE	0x1e050000
+#define IPU_DC_REG_BASE		0x1e058000
+#define IPU_DMFC_REG_BASE	0x1e060000
+#define IPU_CPMEM_REG_BASE	0x1f000000
+#define IPU_LUT_REG_BASE	0x1f020000
+#define IPU_SRM_REG_BASE	0x1f040000
+#define IPU_TPM_REG_BASE	0x1f060000
+#define IPU_DC_TMPL_REG_BASE	0x1f080000
+#define IPU_ISP_TBPR_REG_BASE	0x1f0c0000
+#define IPU_VDI_REG_BASE	0x1e068000
+
+/* Register addresses */
+/* IPU Common registers */
+#define IPU_CM_REG(offset)	(offset)
+
+#define IPU_CONF			IPU_CM_REG(0)
+
+#define IPU_SRM_PRI1			IPU_CM_REG(0x00a0)
+#define IPU_SRM_PRI2			IPU_CM_REG(0x00a4)
+#define IPU_FS_PROC_FLOW1		IPU_CM_REG(0x00a8)
+#define IPU_FS_PROC_FLOW2		IPU_CM_REG(0x00ac)
+#define IPU_FS_PROC_FLOW3		IPU_CM_REG(0x00b0)
+#define IPU_FS_DISP_FLOW1		IPU_CM_REG(0x00b4)
+#define IPU_FS_DISP_FLOW2		IPU_CM_REG(0x00b8)
+#define IPU_SKIP			IPU_CM_REG(0x00bc)
+#define IPU_DISP_ALT_CONF		IPU_CM_REG(0x00c0)
+#define IPU_DISP_GEN			IPU_CM_REG(0x00c4)
+#define IPU_DISP_ALT1			IPU_CM_REG(0x00c8)
+#define IPU_DISP_ALT2			IPU_CM_REG(0x00cc)
+#define IPU_DISP_ALT3			IPU_CM_REG(0x00d0)
+#define IPU_DISP_ALT4			IPU_CM_REG(0x00d4)
+#define IPU_SNOOP			IPU_CM_REG(0x00d8)
+#define IPU_MEM_RST			IPU_CM_REG(0x00dc)
+#define IPU_PM				IPU_CM_REG(0x00e0)
+#define IPU_GPR				IPU_CM_REG(0x00e4)
+#define IPU_CHA_DB_MODE_SEL(ch)		IPU_CM_REG(0x0150 + 4 * ((ch) / 32))
+#define IPU_ALT_CHA_DB_MODE_SEL(ch)	IPU_CM_REG(0x0168 + 4 * ((ch) / 32))
+#define IPU_CHA_CUR_BUF(ch)		IPU_CM_REG(0x023C + 4 * ((ch) / 32))
+#define IPU_ALT_CUR_BUF0		IPU_CM_REG(0x0244)
+#define IPU_ALT_CUR_BUF1		IPU_CM_REG(0x0248)
+#define IPU_SRM_STAT			IPU_CM_REG(0x024C)
+#define IPU_PROC_TASK_STAT		IPU_CM_REG(0x0250)
+#define IPU_DISP_TASK_STAT		IPU_CM_REG(0x0254)
+#define IPU_CHA_BUF0_RDY(ch)		IPU_CM_REG(0x0268 + 4 * ((ch) / 32))
+#define IPU_CHA_BUF1_RDY(ch)		IPU_CM_REG(0x0270 + 4 * ((ch) / 32))
+#define IPU_ALT_CHA_BUF0_RDY(ch)	IPU_CM_REG(0x0278 + 4 * ((ch) / 32))
+#define IPU_ALT_CHA_BUF1_RDY(ch)	IPU_CM_REG(0x0280 + 4 * ((ch) / 32))
+
+#define IPU_INT_CTRL(n)		IPU_CM_REG(0x003C + 4 * ((n) - 1))
+#define IPU_INT_CTRL_IRQ(irq)	IPU_INT_CTRL(((irq) / 32))
+#define IPU_INT_STAT_IRQ(irq)	IPU_INT_STAT(((irq) / 32))
+#define IPU_INT_STAT(n)		IPU_CM_REG(0x0200 + 4 * ((n) - 1))
+
+extern void __iomem *ipu_cm_reg;
+
+static inline u32 ipu_cm_read(unsigned offset)
+{
+	return __raw_readl(ipu_cm_reg + offset);
+}
+
+static inline void ipu_cm_write(u32 value, unsigned offset)
+{
+	__raw_writel(value, ipu_cm_reg + offset);
+}
+
+#define IPU_IDMAC_REG(offset)	(offset)
+
+#define IDMAC_CONF			IPU_IDMAC_REG(0x0000)
+#define IDMAC_CHA_EN(ch)		IPU_IDMAC_REG(0x0004 + 4 * ((ch) / 32))
+#define IDMAC_SEP_ALPHA			IPU_IDMAC_REG(0x000c)
+#define IDMAC_ALT_SEP_ALPHA		IPU_IDMAC_REG(0x0010)
+#define IDMAC_CHA_PRI(ch)		IPU_IDMAC_REG(0x0014 + 4 * ((ch) / 32))
+#define IDMAC_WM_EN(ch)			IPU_IDMAC_REG(0x001c + 4 * ((ch) / 32))
+#define IDMAC_CH_LOCK_EN_1		IPU_IDMAC_REG(0x0024)
+#define IDMAC_CH_LOCK_EN_2		IPU_IDMAC_REG(0x0028)
+#define IDMAC_SUB_ADDR_0		IPU_IDMAC_REG(0x002c)
+#define IDMAC_SUB_ADDR_1		IPU_IDMAC_REG(0x0030)
+#define IDMAC_SUB_ADDR_2		IPU_IDMAC_REG(0x0034)
+#define IDMAC_BAND_EN(ch)		IPU_IDMAC_REG(0x0040 + 4 * ((ch) / 32))
+#define IDMAC_CHA_BUSY(ch)		IPU_IDMAC_REG(0x0100 + 4 * ((ch) / 32))
+
+extern void __iomem *ipu_idmac_reg;
+
+static inline u32 ipu_idmac_read(unsigned offset)
+{
+	return __raw_readl(ipu_idmac_reg + offset);
+}
+
+static inline void ipu_idmac_write(u32 value, unsigned offset)
+{
+	__raw_writel(value, ipu_idmac_reg + offset);
+}
+
+#define idmac_idma_is_set(reg, dma)	(ipu_idmac_read(reg(dma)) & idma_mask(dma))
+#define idma_mask(ch)			(1 << (ch & 0x1f))
+#define ipu_idma_is_set(reg, dma)	(ipu_cm_read(reg(dma)) & idma_mask(dma))
+
+enum ipu_modules {
+	IPU_CONF_CSI0_EN		= (1 << 0),
+	IPU_CONF_CSI1_EN		= (1 << 1),
+	IPU_CONF_IC_EN			= (1 << 2),
+	IPU_CONF_ROT_EN			= (1 << 3),
+	IPU_CONF_ISP_EN			= (1 << 4),
+	IPU_CONF_DP_EN			= (1 << 5),
+	IPU_CONF_DI0_EN			= (1 << 6),
+	IPU_CONF_DI1_EN			= (1 << 7),
+	IPU_CONF_SMFC_EN		= (1 << 8),
+	IPU_CONF_DC_EN			= (1 << 9),
+	IPU_CONF_DMFC_EN		= (1 << 10),
+
+	IPU_CONF_VDI_EN			= (1 << 12),
+
+	IPU_CONF_IDMAC_DIS		= (1 << 22),
+
+	IPU_CONF_IC_DMFC_SEL		= (1 << 25),
+	IPU_CONF_IC_DMFC_SYNC		= (1 << 26),
+	IPU_CONF_VDI_DMFC_SYNC		= (1 << 27),
+
+	IPU_CONF_CSI0_DATA_SOURCE	= (1 << 28),
+	IPU_CONF_CSI1_DATA_SOURCE	= (1 << 29),
+	IPU_CONF_IC_INPUT		= (1 << 30),
+	IPU_CONF_CSI_SEL		= (1 << 31),
+};
+
+struct ipu_channel {
+	unsigned int num;
+
+	bool enabled;
+	bool busy;
+};
+
+ipu_color_space_t format_to_colorspace(u32 fmt);
+bool ipu_pixel_format_has_alpha(u32 fmt);
+
+u32 _ipu_channel_status(struct ipu_channel *channel);
+
+int _ipu_chan_is_interlaced(struct ipu_channel *channel);
+
+int ipu_module_enable(u32 mask);
+int ipu_module_disable(u32 mask);
+
+int ipu_di_init(struct platform_device *pdev, int id, unsigned long base,
+		u32 module, struct clk *ipu_clk);
+void ipu_di_exit(struct platform_device *pdev, int id);
+
+int ipu_dmfc_init(struct platform_device *pdev, unsigned long base,
+		struct clk *ipu_clk);
+void ipu_dmfc_exit(struct platform_device *pdev);
+
+int ipu_dp_init(struct platform_device *pdev, unsigned long base);
+void ipu_dp_exit(struct platform_device *pdev);
+
+int ipu_dc_init(struct platform_device *pdev, unsigned long base,
+		unsigned long template_base);
+void ipu_dc_exit(struct platform_device *pdev);
+
+int ipu_cpmem_init(struct platform_device *pdev, unsigned long base);
+void ipu_cpmem_exit(struct platform_device *pdev);
+
+void ipu_get(void);
+void ipu_put(void);
+
+#endif				/* __IPU_PRV_H__ */
diff --git a/include/linux/mfd/imx-ipu-v3.h b/include/linux/mfd/imx-ipu-v3.h
new file mode 100644
index 0000000..7243360
--- /dev/null
+++ b/include/linux/mfd/imx-ipu-v3.h
@@ -0,0 +1,219 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_IPU_H__
+#define __ASM_ARCH_IPU_H__
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <linux/bitmap.h>
+
+/*
+ * Enumeration of IPU rotation modes
+ */
+typedef enum {
+	/* Note the enum values correspond to BAM value */
+	IPU_ROTATE_NONE = 0,
+	IPU_ROTATE_VERT_FLIP = 1,
+	IPU_ROTATE_HORIZ_FLIP = 2,
+	IPU_ROTATE_180 = 3,
+	IPU_ROTATE_90_RIGHT = 4,
+	IPU_ROTATE_90_RIGHT_VFLIP = 5,
+	IPU_ROTATE_90_RIGHT_HFLIP = 6,
+	IPU_ROTATE_90_LEFT = 7,
+} ipu_rotate_mode_t;
+
+/*
+ * IPU Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/* Generic or Raw Data Formats */
+#define IPU_PIX_FMT_GENERIC v4l2_fourcc('I', 'P', 'U', '0')	/* IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_32 v4l2_fourcc('I', 'P', 'U', '1')	/* IPU Generic Data */
+#define IPU_PIX_FMT_LVDS666 v4l2_fourcc('L', 'V', 'D', '6')	/* IPU Generic Data */
+#define IPU_PIX_FMT_LVDS888 v4l2_fourcc('L', 'V', 'D', '8')	/* IPU Generic Data */
+/* RGB Formats */
+#define IPU_PIX_FMT_RGB332  V4L2_PIX_FMT_RGB332			/*  8  RGB-3-3-2    */
+#define IPU_PIX_FMT_RGB555  V4L2_PIX_FMT_RGB555			/* 16  RGB-5-5-5    */
+#define IPU_PIX_FMT_RGB565  V4L2_PIX_FMT_RGB565			/* 1 6  RGB-5-6-5   */
+#define IPU_PIX_FMT_RGB666  v4l2_fourcc('R', 'G', 'B', '6')	/* 18  RGB-6-6-6    */
+#define IPU_PIX_FMT_BGR666  v4l2_fourcc('B', 'G', 'R', '6')	/* 18  BGR-6-6-6    */
+#define IPU_PIX_FMT_BGR24   V4L2_PIX_FMT_BGR24			/* 24  BGR-8-8-8    */
+#define IPU_PIX_FMT_RGB24   V4L2_PIX_FMT_RGB24			/* 24  RGB-8-8-8    */
+#define IPU_PIX_FMT_BGR32   V4L2_PIX_FMT_BGR32			/* 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_BGRA32  v4l2_fourcc('B', 'G', 'R', 'A')	/* 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_RGB32   V4L2_PIX_FMT_RGB32			/* 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_RGBA32  v4l2_fourcc('R', 'G', 'B', 'A')	/* 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_ABGR32  v4l2_fourcc('A', 'B', 'G', 'R')	/* 32  ABGR-8-8-8-8 */
+/* YUV Interleaved Formats */
+#define IPU_PIX_FMT_YUYV    V4L2_PIX_FMT_YUYV			/* 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_UYVY    V4L2_PIX_FMT_UYVY			/* 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_Y41P    V4L2_PIX_FMT_Y41P			/* 12 YUV 4:1:1 */
+#define IPU_PIX_FMT_YUV444  V4L2_PIX_FMT_YUV444			/* 24 YUV 4:4:4 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define IPU_PIX_FMT_NV12    V4L2_PIX_FMT_NV12			/* 12  Y/CbCr 4:2:0  */
+/* YUV Planar Formats */
+#define IPU_PIX_FMT_GREY    V4L2_PIX_FMT_GREY			/* 8  Greyscale */
+#define IPU_PIX_FMT_YVU410P V4L2_PIX_FMT_YVU410P		/* 9  YVU 4:1:0 */
+#define IPU_PIX_FMT_YUV410P V4L2_PIX_FMT_YUV410P		/* 9  YUV 4:1:0 */
+#define IPU_PIX_FMT_YVU420P v4l2_fourcc('Y', 'V', '1', '2')	/* 12 YVU 4:2:0 */
+#define IPU_PIX_FMT_YUV420P v4l2_fourcc('I', '4', '2', '0')	/* 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YUV420P2 v4l2_fourcc('Y', 'U', '1', '2')	/* 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YVU422P v4l2_fourcc('Y', 'V', '1', '6')	/* 16 YVU 4:2:2 */
+#define IPU_PIX_FMT_YUV422P V4L2_PIX_FMT_YUV422P		/* 16 YUV 4:2:2 */
+
+/*
+ * Bitfield of Display Interface signal polarities.
+ */
+struct ipu_di_signal_cfg {
+	unsigned datamask_en:1;
+	unsigned ext_clk:1;
+	unsigned interlaced:1;
+	unsigned odd_field_first:1;
+	unsigned clksel_en:1;
+	unsigned clkidle_en:1;
+	unsigned data_pol:1;	/* true = inverted */
+	unsigned clk_pol:1;	/* true = rising edge */
+	unsigned enable_pol:1;
+	unsigned Hsync_pol:1;	/* true = active high */
+	unsigned Vsync_pol:1;
+
+	u16 width;
+	u16 height;
+	u32 pixel_fmt;
+	u16 h_start_width;
+	u16 h_sync_width;
+	u16 h_end_width;
+	u16 v_start_width;
+	u16 v_sync_width;
+	u16 v_end_width;
+	u32 v_to_h_sync;
+};
+
+typedef enum {
+	RGB,
+	YCbCr,
+	YUV
+} ipu_color_space_t;
+
+#define IPU_IRQ_EOF(channel)		(channel)		/* 0 .. 63 */
+#define IPU_IRQ_NFACK(channel)		((channel) + 64)	/* 64 .. 127 */
+#define IPU_IRQ_NFB4EOF(channel)	((channel) + 128)	/* 128 .. 191 */
+#define IPU_IRQ_EOS(channel)		((channel) + 192)	/* 192 .. 255 */
+
+#define IPU_IRQ_DP_SF_START		(448 + 2)
+#define IPU_IRQ_DP_SF_END		(448 + 3)
+#define IPU_IRQ_BG_SF_END		IPU_IRQ_DP_SF_END,
+#define IPU_IRQ_DC_FC_0			(448 + 8)
+#define IPU_IRQ_DC_FC_1			(448 + 9)
+#define IPU_IRQ_DC_FC_2			(448 + 10)
+#define IPU_IRQ_DC_FC_3			(448 + 11)
+#define IPU_IRQ_DC_FC_4			(448 + 12)
+#define IPU_IRQ_DC_FC_6			(448 + 13)
+#define IPU_IRQ_VSYNC_PRE_0		(448 + 14)
+#define IPU_IRQ_VSYNC_PRE_1		(448 + 15)
+
+#define IPU_IRQ_COUNT	(15 * 32)
+
+#define DECLARE_IPU_IRQ_BITMAP(name)	DECLARE_BITMAP(name, IPU_IRQ_COUNT)
+
+struct ipu_irq_handler {
+	struct list_head	list;
+	void			(*handler)(unsigned long *, void *);
+	void			*context;
+	DECLARE_IPU_IRQ_BITMAP(ipu_irqs);
+};
+
+int ipu_irq_add_handler(struct ipu_irq_handler *ipuirq);
+void ipu_irq_remove_handler(struct ipu_irq_handler *handler);
+int ipu_irq_update_handler(struct ipu_irq_handler *handler,
+		unsigned long *bitmap);
+int ipu_wait_for_interrupt(int interrupt, int timeout_ms);
+
+struct ipu_channel;
+
+/*
+ * IPU Image DMA Controller (idmac) functions
+ */
+struct ipu_channel *ipu_idmac_get(unsigned channel);
+void ipu_idmac_put(struct ipu_channel *);
+int ipu_idmac_init_channel_buffer(struct ipu_channel *channel,
+				u32 pixel_fmt,
+				u16 width, u16 height,
+				u32 stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				u32 u_offset, u32 v_offset, bool interlaced);
+
+int ipu_idmac_update_channel_buffer(struct ipu_channel *channel,
+				  u32 bufNum, dma_addr_t phyaddr);
+
+int ipu_idmac_enable_channel(struct ipu_channel *channel);
+int ipu_idmac_disable_channel(struct ipu_channel *channel);
+
+void ipu_idmac_set_double_buffer(struct ipu_channel *channel, bool doublebuffer);
+void ipu_idmac_select_buffer(struct ipu_channel *channel, u32 buf_num);
+
+/*
+ * IPU Display Controller (dc) functions
+ */
+int ipu_dc_init_sync(int dc_chan, int di, bool interlaced, u32 pixel_fmt, u32 width);
+void ipu_dc_init_async(int dc_chan, int di, bool interlaced);
+void ipu_dc_enable_channel(u32 dc_chan);
+void ipu_dc_disable_channel(u32 dc_chan);
+
+/*
+ * IPU Display Interface (di) functions
+ */
+struct ipu_di;
+struct ipu_di *ipu_di_get(int disp);
+void ipu_di_put(struct ipu_di *);
+int ipu_di_disable(struct ipu_di *);
+int ipu_di_enable(struct ipu_di *);
+int ipu_di_init_sync_panel(struct ipu_di *, u32 pixel_clk,
+		struct ipu_di_signal_cfg *sig);
+
+/*
+ * IPU Display Multi FIFO Controller (dmfc) functions
+ */
+struct dmfc_channel;
+int ipu_dmfc_enable_channel(struct dmfc_channel *dmfc);
+void ipu_dmfc_disable_channel(struct dmfc_channel *dmfc);
+int ipu_dmfc_alloc_bandwidth(struct dmfc_channel *dmfc, unsigned long bandwidth_mbs);
+void ipu_dmfc_free_bandwidth(struct dmfc_channel *dmfc);
+int ipu_dmfc_init_channel(struct dmfc_channel *dmfc, int width);
+struct dmfc_channel *ipu_dmfc_get(int ipu_channel);
+void ipu_dmfc_put(struct dmfc_channel *dmfc);
+
+/*
+ * IPU Display Processor (dp) functions
+ */
+#define IPU_DP_FLOW_SYNC	0
+#define IPU_DP_FLOW_ASYNC0	1
+#define IPU_DP_FLOW_ASYNC1	2
+
+struct ipu_dp *ipu_dp_get(unsigned int flow);
+void ipu_dp_put(struct ipu_dp *);
+int ipu_dp_enable_channel(struct ipu_dp *dp);
+void ipu_dp_disable_channel(struct ipu_dp *dp);
+void ipu_dp_enable_fg(struct ipu_dp *dp);
+void ipu_dp_disable_fg(struct ipu_dp *dp);
+int ipu_dp_setup_channel(struct ipu_dp *dp, u32 in_pixel_fmt,
+		 u32 out_pixel_fmt, int bg);
+int ipu_dp_set_window_pos(struct ipu_dp *, u16 x_pos, u16 y_pos);
+int ipu_dp_set_color_key(struct ipu_dp *dp, bool enable, u32 colorKey);
+int ipu_dp_set_global_alpha(struct ipu_dp *dp, bool enable, u8 alpha,
+		bool bg_chan);
+
+#endif
-- 
1.7.2.3

