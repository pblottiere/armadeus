
Adds support for Armadeus Systems APF27 module (i.MX27 based), APF27Dev
companion baseboard and APW extension board.

Signed-off-by: Julien Boibessot <julien.boibessot@armadeus.com>
Signed-off-by: Nicolas Colombain <nicolas.colombain@armadeus.com>
Signed-off-by: Eric Jarrige <eric.jarrige@armadeus.org>

Index: linux-2.6.29.6/arch/arm/mach-mx2/apf27.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.6/arch/arm/mach-mx2/apf27.c	2014-01-22 16:39:52.328884634 +0100
@@ -0,0 +1,739 @@
+ /*
+ * apf27.c
+ *
+ * Support for the APF27 System On Module
+ *
+ * Copyright (C) 2008-2011 ARMadeus Systems
+ * Authors: Julien Boibessot <julien.boibessot@armadeus.com>
+ *          Eric Jarrige <eric.jarrige@armadeus.com>
+ *
+ * Inspired a lot by pcm038.c which is:
+ * Copyright 2007 Robert Schwebel <r.schwebel@pengutronix.de>, Pengutronix
+ * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <linux/i2c.h>
+#include <linux/serial.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/cpufreq.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/fsl_devices.h> /* USB device */
+
+#include <asm/mach/flash.h>
+#include <asm/io.h>
+#include <asm/mach/arch.h>
+#include <asm/mach-types.h>
+#include <asm/mach/time.h>
+// #include <asm/arch/clock.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/iomux-mx1-mx2.h>
+#include <mach/gpio.h>
+#include <mach/imx_i2c.h>
+#include <mach/imx-uart.h>
+#include <mach/mxc_nand.h>
+#include <mach/mxc_ehci.h>
+#include <mach/ulpi.h>
+#include "../../../drivers/armadeus/pwm/pwm.h"
+#if defined(CONFIG_CPU_FREQ_IMX27) || defined(CONFIG_CPU_FREQ_IMX27_MODULE)
+#include "cpufreq_imx.h"
+#endif
+#include <mach/board-apf27.h>
+#include <asm/mach/map.h>
+
+#include "devices.h"
+#include "crm_regs.h"
+
+extern void apf27_baseboard_init(void);
+#ifdef CONFIG_PM
+extern void apf27_baseboard_resume(void);
+extern void apf27_baseboard_suspend(void);
+#endif
+#ifdef CONFIG_FB_MXC
+extern void apf27_lcd_startup(void);
+#endif
+
+#ifdef CONFIG_ARMADEUS_PWM_DRIVER_MODULE
+#define CONFIG_PWM
+#endif
+
+
+#ifdef CONFIG_PWM
+static int mxc_pwm0_pins[] = {
+	PE5_PF_PWM0
+};
+
+static int apf27_pwm_0_init(void)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_pwm0_pins, ARRAY_SIZE(mxc_pwm0_pins), "PWM0");
+}
+
+static int apf27_pwm_0_exit(void)
+{
+	mxc_gpio_release_multiple_pins(mxc_pwm0_pins, ARRAY_SIZE(mxc_pwm0_pins));
+	return 0;
+}
+
+static struct imx_pwm_platform_data apf27_pwm_0_data = {
+	.init = apf27_pwm_0_init,
+	.exit = apf27_pwm_0_exit,
+};
+#endif
+
+
+/* APF27 has a Micron 128MiB 1,8V NAND flash, 16 bits width */
+static struct mxc_nand_platform_data apf27_nand_board_info = {
+	.width = 2,
+	.hw_ecc = 1,
+};
+
+
+/* APF27 has an I2C EEPROM on I2C2 Bus */
+#ifdef CONFIG_I2C
+static int mxc_i2c1_pins[] = {
+	PC5_PF_I2C2_SDA,
+	PC6_PF_I2C2_SCL
+};
+
+static int apf27_i2c_1_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_i2c1_pins, ARRAY_SIZE(mxc_i2c1_pins),
+						"I2C2");
+}
+
+static int apf27_i2c_1_exit(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_i2c1_pins, ARRAY_SIZE(mxc_i2c1_pins));
+	return 0;
+}
+
+static struct imx_i2c_platform_data apf27_i2c_1_data = {
+	.max_clk = 100000,
+	.init = apf27_i2c_1_init,
+	.exit = apf27_i2c_1_exit,
+};
+
+static struct i2c_board_info apf27_i2c_devices_bus1[] = {
+	[0] = {
+		.type = "24c02",
+		.flags = 0,
+		.addr = 0x50,
+		.platform_data = NULL,
+		.irq = 0
+	},
+};
+#endif /* CONFIG_I2C */
+
+
+/* APF27 has an RS232 debug port/console on UART1 with "on module" transceiver */
+static int mxc_uart0_pins[] = {
+	PE12_PF_UART1_TXD,
+	PE13_PF_UART1_RXD
+};
+
+static int uart_mxc_port0_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart0_pins, ARRAY_SIZE(mxc_uart0_pins), "UART1");
+}
+
+static int uart_mxc_port0_exit(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_uart0_pins, ARRAY_SIZE(mxc_uart0_pins));
+
+	return 0;
+}
+
+static struct imxuart_platform_data uart0_pdata = {
+	.init = uart_mxc_port0_init,
+	.exit = uart_mxc_port0_exit,
+	.flags = 0,
+};
+
+/* APF27 has an "on module" transceiver for UART3 */
+static int mxc_uart2_pins[] = {
+	PE8_PF_UART3_TXD,
+	PE9_PF_UART3_RXD,
+#ifdef CONFIG_SERIAL_IMX_UART3_USE_RTSCTS
+	PE10_PF_UART3_CTS,
+	PE11_PF_UART3_RTS,
+#endif
+};
+
+static int uart_mxc_port2_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart2_pins, ARRAY_SIZE(mxc_uart2_pins), "UART3");
+}
+
+static int uart_mxc_port2_exit(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_uart2_pins, ARRAY_SIZE(mxc_uart2_pins));
+
+	return 0;
+}
+
+static struct imxuart_platform_data uart2_pdata = {
+	.init = uart_mxc_port2_init,
+	.exit = uart_mxc_port2_exit,
+#ifdef CONFIG_SERIAL_IMX_UART3_USE_RTSCTS
+	.flags = IMXUART_HAVE_RTSCTS,
+#else
+	.flags = 0,
+#endif
+};
+
+
+/* APF27 has an onboard Ethernet PHY */
+#ifdef CONFIG_FEC_OLD
+static int mxc_fec_pins[] = {
+	PD0_AIN_FEC_TXD0,
+	PD1_AIN_FEC_TXD1,
+	PD2_AIN_FEC_TXD2,
+	PD3_AIN_FEC_TXD3,
+	PD4_AOUT_FEC_RX_ER,
+	PD5_AOUT_FEC_RXD1,
+	PD6_AOUT_FEC_RXD2,
+	PD7_AOUT_FEC_RXD3,
+	PD8_AF_FEC_MDIO,
+	PD9_AIN_FEC_MDC,
+	PD10_AOUT_FEC_CRS,
+	PD11_AOUT_FEC_TX_CLK,
+	PD12_AOUT_FEC_RXD0,
+	PD13_AOUT_FEC_RX_DV,
+	PD14_AOUT_FEC_CLR,
+	PD15_AOUT_FEC_COL,
+	PD16_AIN_FEC_TX_ER,
+	PF23_AIN_FEC_TX_EN
+};
+
+static void gpio_fec_active(void)
+{
+	mxc_gpio_setup_multiple_pins(mxc_fec_pins, ARRAY_SIZE(mxc_fec_pins), "FEC");
+}
+#endif /* CONFIG_FEC_OLD */
+
+
+/* APF27 has an onboard PHY (ISP1504) on OTG USB port */
+static int mxc_usbotg_pins[] = {
+	PE0_PF_USBOTG_NXT,
+	PE1_PF_USBOTG_STP,
+	PE2_PF_USBOTG_DIR,
+	PE24_PF_USBOTG_CLK,
+	PE25_PF_USBOTG_DATA7,
+	PC7_PF_USBOTG_DATA5,
+	PC8_PF_USBOTG_DATA6,
+	PC9_PF_USBOTG_DATA0,
+	PC10_PF_USBOTG_DATA2,
+	PC11_PF_USBOTG_DATA1,
+	PC12_PF_USBOTG_DATA4,
+	PC13_PF_USBOTG_DATA3,
+};
+
+static int isp1504_check_presence(void __iomem *view)
+{
+	int vid, pid;
+
+	vid = (ulpi_read(ISP1504_VID_HIGH, view) << 8) |
+		 ulpi_read(ISP1504_VID_LOW, view);
+	pid = (ulpi_read(ISP1504_PID_HIGH, view) << 8) |
+		 ulpi_read(ISP1504_PID_LOW, view);
+
+	pr_info("ULPI OTG Vendor ID 0x%x    Product ID 0x%x\n", vid, pid);
+	if (vid != 0x4cc || pid != 0x1504) {
+		pr_err("No ISP1504 found\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int isp1504_set_vbus_power(void __iomem *view, int on)
+{
+	int ret = 0;
+
+	ret = isp1504_check_presence(view);
+	if (ret)
+		return ret;
+
+	if (on) {
+		/* force disconnection of the DM/DP signals. This
+			avoid powering the connected device through these lines */
+		ulpi_set(RESET, ISP1504_FCNCTL, view);
+		mdelay(10); /*wait until the supply is really down*/
+		ulpi_clear(RESET, ISP1504_FCNCTL, view);
+		mdelay(1);
+
+		ret = ulpi_set(DRV_VBUS_EXT |	/* enable external Vbus */
+			    DRV_VBUS |		/* enable internal Vbus */
+			    USE_EXT_VBUS_IND |	/* use external indicator */
+			    CHRG_VBUS,		/* charge Vbus */
+			    ISP1504_OTGCTL, view);
+	} else {
+		ret = ulpi_clear(DRV_VBUS_EXT |	/* disable external Vbus */
+			      DRV_VBUS,		/* disable internal Vbus */
+			      ISP1504_OTGCTL, view);
+
+		ret |= ulpi_set(USE_EXT_VBUS_IND | /* use external indicator */
+			    DISCHRG_VBUS,	   /* discharge Vbus */
+			    ISP1504_OTGCTL, view);
+	}
+
+	return ret;
+}
+
+static int isp1504_set_device(void __iomem *view)
+{
+	int ret = 0;
+
+	ret = isp1504_check_presence(view);
+	if (ret)
+		return ret;
+
+	ret = ulpi_clear(0x06, ISP1504_OTGCTL, view);
+
+	return ret;
+}
+
+static void isp1504_suspend(void __iomem *view)
+{
+	/* isp1504_set_vbus_power(view, 0); needed ? */
+	ulpi_clear(SUSPENDM, ISP1504_FCNCTL, view);
+}
+
+static void isp1504_resume(void __iomem *view)
+{
+	/* uggly but the STP line must be set to 1 before the first PHY access
+	   in order to wake up the ULPI clock of the PHY. */
+	gpio_set_value(GPIO_PORTE | 1, 1);
+	/* deassert STP (gpio mode) */
+	mxc_gpio_mode(GPIO_PORTE | 1  | GPIO_OUT | GPIO_GPIO);
+	mdelay(1);
+	/* STP now managed by the USB host ctrl */
+	mxc_gpio_mode(PE1_PF_USBOTG_STP);
+}
+
+#define UOG_USBCMD	0x140
+#define UOG_ULPIVIEW	0x170
+#define UOG_PORTSC1	0x184
+#define USB_CTRL	0x600
+#define PORTSC_PTS_MASK	(3 << 30)
+#define PORTSC_PTS_ULPI (2 << 30)
+
+static void apf27_usbotg_reset(void)
+{
+	uint32_t temp;
+
+	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + UOG_USBCMD);
+	temp |= 0x02;
+	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + UOG_USBCMD);
+	pr_debug("reset controller: 0x%08x\n", temp);
+	mdelay(10);
+}
+
+static int otg_mode_host = 1;
+
+static int __init apf27_otg_mode(char *options)
+{
+	if (!strcmp(options, "host"))
+		otg_mode_host = 1;
+	else if (!strcmp(options, "device"))
+		otg_mode_host = 0;
+	else {
+		pr_info("otg_mode neither \"host\" nor \"device\". "
+			"Defaulting to host\n");
+	}
+
+	return 0;
+}
+__setup("otg_mode=", apf27_otg_mode);
+
+static int apf27_usbotg_init(struct platform_device *pdev)
+{
+	int ret;
+	uint32_t temp;
+
+	ret = mxc_gpio_setup_multiple_pins(mxc_usbotg_pins,
+			ARRAY_SIZE(mxc_usbotg_pins), "USB OTG");
+	if (ret)
+		return ret;
+
+	/* Tweak power/wake up handling */
+	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + USB_CTRL);
+	temp &= ~( (3 << 29) | 1 );
+	temp |= (1 << 24) | (1 << 27) | (1 << 28);
+	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + USB_CTRL);
+
+	/* Select ULPI PHY */
+	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + UOG_PORTSC1);
+	temp = (temp & ~PORTSC_PTS_MASK) | PORTSC_PTS_ULPI;
+	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + UOG_PORTSC1);
+	mdelay(10);
+
+	apf27_usbotg_reset();
+
+	if (otg_mode_host) {
+		ret = isp1504_set_vbus_power((void __iomem *)(IO_ADDRESS(OTG_BASE_ADDR + UOG_ULPIVIEW)), 1);
+	} else {
+		ret = isp1504_set_device((void __iomem *)(IO_ADDRESS(OTG_BASE_ADDR + UOG_ULPIVIEW)));
+	}
+
+	if (ret)
+		mxc_gpio_release_multiple_pins(mxc_usbotg_pins,
+			ARRAY_SIZE(mxc_usbotg_pins));
+
+	return ret;
+}
+
+struct mxc_usb2_platform_data ehci0_pdata = {
+	.init = apf27_usbotg_init,
+};
+
+static struct fsl_usb2_platform_data otg_device_pdata = {
+	.init = apf27_usbotg_init,
+	.operating_mode = FSL_USB2_DR_DEVICE,
+	.phy_mode = FSL_USB2_PHY_ULPI,
+};
+
+
+/* APF27 frequency scaling stuff */
+#if defined(CONFIG_CPU_FREQ_IMX27) || defined(CONFIG_CPU_FREQ_IMX27_MODULE)
+
+static struct clk *mpll_main_0;
+static struct clk *mpll_main_1;
+static struct clk *cpu;
+
+static int apf27_cpufreq_init(struct platform_device *pd)
+{
+	mpll_main_0 = clk_get(NULL, "mpll_main.0");
+	mpll_main_1 = clk_get(NULL, "mpll_main.1");
+	cpu = clk_get(NULL, "cpu_clk");
+
+	if (IS_ERR(mpll_main_0) || IS_ERR(mpll_main_1) || IS_ERR(cpu)) {
+		printk("Cant get one of the required clocks\n");
+		/* FIXME error handling */
+	}
+
+	/* Switch Qvdd (=CPU core supply) to 1.45V (voltage for max core speed) */
+	/* The APF27 don't have a PMIC, so 1.45V is already here */
+
+	if (clk_get_rate(mpll_main_0) < 399000000) {
+		printk(KERN_INFO "Found MPLL running below ~400Mhz. Tuning "
+				"right now.\n");
+		/* here we should setup max frequencies, if not already setup by
+		   the bootloader, but in our case we fully trust our U-Boot ;-) */
+	}
+
+	return 0;
+}
+
+static int apf27_cpufreq_exit(struct platform_device *pd)
+{
+	clk_put(mpll_main_0);
+	clk_put(mpll_main_1);
+	clk_put(cpu);
+
+	return 0;
+}
+
+static int apf27_cpufreq_transit(unsigned long freq)
+{
+	uint32_t cscr;
+	struct clk *new_clk;
+
+	cscr = __raw_readl(CCM_CSCR);
+
+	switch(freq) {
+	case 133000:
+		/* AHB *can* run at 133MHz */
+		cscr &= ~CCM_CSCR_AHB_MASK;
+		cscr |= 0x01 << CCM_CSCR_AHB_OFFSET;	/* AHBDIV = 2 */
+
+		cscr &= ~CCM_CSCR_ARM_MASK;
+		cscr |= 0x01 << CCM_CSCR_ARM_OFFSET;	/* 133MHz */
+		cscr &= ~CCM_CSCR_ARM_SRC;
+		new_clk = mpll_main_1;
+		break;
+
+	case 266000:
+		/* AHB *can* run at 133MHz */
+		cscr &= ~CCM_CSCR_AHB_MASK;
+		cscr |= 0x01 << CCM_CSCR_AHB_OFFSET;	/* AHBDIV = 2 */
+
+		cscr &= ~CCM_CSCR_ARM_MASK;
+		cscr |= 0x00 << CCM_CSCR_ARM_OFFSET;	/* 266MHz speed */
+		cscr &= ~CCM_CSCR_ARM_SRC;
+		new_clk = mpll_main_1;
+		break;
+
+	case 400000:
+		/* AHB *must* run at 133MHz */
+		cscr &= ~CCM_CSCR_AHB_MASK;
+		cscr |= 0x01 << CCM_CSCR_AHB_OFFSET;	/* AHBDIV = 2 */
+
+		cscr &= ~CCM_CSCR_ARM_MASK;
+		cscr |= 0x00 << CCM_CSCR_ARM_OFFSET;	/* full speed */
+		cscr |= CCM_CSCR_ARM_SRC;
+		new_clk = mpll_main_0;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	__raw_writel(cscr, CCM_CSCR);
+	clk_set_parent(cpu, new_clk);
+
+	return 0;
+}
+
+static struct cpufreq_frequency_table apf27_freq_table[] = {
+	{0x01, .frequency = 133000 }, /* with 400MHz MPLL * 2 / (3*2) @ 1.45V Qvdd */
+	{0x02, .frequency = 266000 }, /* with 400MHz MPLL * 2 / (3*1) @ 1.45V Qvdd */
+	{0x03, .frequency = 400000 }, /* with 400MHz MPLL * 2 / (2*1) @ 1.45V Qvdd */
+	{0, CPUFREQ_TABLE_END}
+};
+
+static struct cpufreq_platform_data apf27_cpufreq_platform_data = {
+	.freq_table = apf27_freq_table,
+	.freq_entries = ARRAY_SIZE(apf27_freq_table),
+	.init = apf27_cpufreq_init,
+	.exit = apf27_cpufreq_exit,
+	.transit = apf27_cpufreq_transit
+};
+
+static struct platform_device apf27_cpu_frequency_device = {
+	.name = "imx_cpufreq",
+	.id = 0,
+	.dev = {
+		.platform_data = &apf27_cpufreq_platform_data,
+	}
+};
+# define CPU_FREQUENCY &apf27_cpu_frequency_device,
+#else
+# define CPU_FREQUENCY
+#endif /* CONFIG_CPU_FREQ_IMX27 */
+
+
+static struct platform_device *platform_devices[] __initdata = {
+	CPU_FREQUENCY
+#ifdef CONFIG_MXC_VPU
+	&mxc_vpu_device,
+#endif
+};
+
+
+/* APF27 power management stuff */
+
+static void apf27_pwr_ctl_active(void)
+{
+#ifdef CONFIG_FB_MXC
+	apf27_lcd_startup();
+#endif
+}
+
+#ifdef CONFIG_PM
+
+#ifdef APF27_PM_DEBUG
+#define CCM_PCCR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x20)
+#define CCM_PCCR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x24)
+
+static void apf27_dump_clocks(void)
+{
+	printk("CSCR:   0x%08x\n", __raw_readl(CCM_CSCR));
+	printk("MPCTL0: 0x%08x\n", __raw_readl(CCM_MPCTL0));
+	printk("MPCTL1: 0x%08x\n", __raw_readl(CCM_MPCTL1));
+	printk("SPCTL0: 0x%08x\n", __raw_readl(CCM_SPCTL0));
+	printk("SPCTL1: 0x%08x\n", __raw_readl(CCM_SPCTL1));
+	printk("OSC26:  0x%08x\n", __raw_readl(CCM_OSC26MCTL));
+	printk("PCDR0:  0x%08x\n", __raw_readl(CCM_PCDR0));
+	printk("PCDR1:  0x%08x\n", __raw_readl(CCM_PCDR1));
+	printk("PCCR0:  0x%08x\n", __raw_readl(CCM_PCCR0));
+	printk("PCCR1:  0x%08x\n", __raw_readl(CCM_PCCR1));
+	printk("CCSR:   0x%08x\n", __raw_readl(CCM_CCSR));
+}
+
+char port[6] = {'A', 'B', 'C', 'D', 'E', 'F'};
+
+static void dump_gpio_port(int id)
+{
+	u32 reg;
+
+	reg =  __raw_readl(VA_GPIO_BASE + MXC_DDIR(id));
+	printk("DDIR_%c: 0x%08x\n", port[id], reg);
+	reg =  __raw_readl(VA_GPIO_BASE + MXC_DR(id));
+	printk("DR_%c: 0x%08x\n", port[id], reg);
+	reg =  __raw_readl(VA_GPIO_BASE + MXC_GIUS(id));
+	printk("GIUS_%c: 0x%08x\n", port[id], reg);
+	reg =  __raw_readl(VA_GPIO_BASE + MXC_OCR1(id));
+	printk("OCR1_%c: 0x%08x\n", port[id], reg);
+	reg =  __raw_readl(VA_GPIO_BASE + MXC_OCR2(id));
+	printk("OCR2_%c: 0x%08x\n", port[id], reg);
+	reg =  __raw_readl(VA_GPIO_BASE + MXC_PUEN(id));
+	printk("PUEN_%c: 0x%08x\n", port[id], reg);
+	printk("---\n");
+}
+
+static void dump_gpios(void)
+{
+	int i;
+
+	printk("*************************\n");
+	for (i=0; i<6; i++) {
+		dump_gpio_port(i);
+	}
+}
+
+/*	    DDIR         OCR1        OCR2        DR         GIUS        PUEN */
+u32 gpio_val[6][6] = {
+	{0x00000000, 0x00000000, 0xF000FFFF, 0x00000000, 0xFFFFFFFF, 0xFFFFFFFF}, /* A */
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xFFFFFFF3, 0xFFFFFFFF}, /* B */
+	{0x000003F8, 0x3FFFC000, 0x00000000, 0x00000000, 0xFFFFFFFF, 0xFFFFFC07}, /* C */
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xFFFFFFFF, 0xFFFFFFFF}, /* D */
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xFFFFCCFF, 0xFFFFFFFF}, /* E */
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xFFFFFFFF, 0xFFFFFFFF}, /* F */
+};
+
+static void force_gpio_port(int id)
+{
+	__raw_writel(gpio_val[id][0], VA_GPIO_BASE + MXC_DDIR(id));
+	__raw_writel(gpio_val[id][1], VA_GPIO_BASE + MXC_OCR1(id));
+	__raw_writel(gpio_val[id][2], VA_GPIO_BASE + MXC_OCR2(id));
+	__raw_writel(gpio_val[id][3], VA_GPIO_BASE + MXC_DR(id));
+	__raw_writel(gpio_val[id][4], VA_GPIO_BASE + MXC_GIUS(id));
+	__raw_writel(gpio_val[id][5], VA_GPIO_BASE + MXC_PUEN(id));
+}
+
+static void apf27_force_gpios(void)
+{
+	force_gpio_port(0);
+	force_gpio_port(1);
+	force_gpio_port(3);
+}
+#endif /* APF27_PM_DEBUG */
+
+static int apf27_pm_suspend(struct sys_device *sd, pm_message_t state)
+{
+	printk("___ %s\n", __func__);
+
+#ifdef CONFIG_USB_EHCI_MXC
+	isp1504_suspend((void __iomem *)(IO_ADDRESS(OTG_BASE_ADDR + 0x170)));
+#endif
+	apf27_baseboard_suspend();
+#ifdef APF27_PM_DEBUG
+	apf27_force_gpios();
+	apf27_dump_clocks();
+	dump_gpios();
+#endif
+	__raw_writel(0x0c090c0A, IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x1c)); /* WBCR */
+
+	return 0;
+}
+
+static int apf27_pm_resume(struct sys_device *sd)
+{
+	printk("___ %s\n", __func__);
+
+#ifdef CONFIG_USB_EHCI_MXC
+	isp1504_resume((void __iomem *)(IO_ADDRESS(OTG_BASE_ADDR + 0x170)));
+#endif
+	apf27_baseboard_resume();
+
+	return 0;
+}
+
+#else
+# define apf27_pm_suspend NULL
+# define apf27_pm_resume NULL
+#endif /* CONFIG_PM */
+
+static struct sysdev_class apf27_pm_sysclass = {
+	.name		= "mach-apf27",
+	.suspend	= apf27_pm_suspend,
+	.resume		= apf27_pm_resume,
+};
+
+static struct sys_device apf27_pm_sysdev = {
+	.cls		= &apf27_pm_sysclass,
+};
+
+
+static void __init apf27_init(void)
+{
+	sysdev_class_register(&apf27_pm_sysclass);
+	sysdev_register(&apf27_pm_sysdev);
+
+	/* Init apf27 power management related pins */
+	apf27_pwr_ctl_active();
+
+#ifdef CONFIG_FEC_OLD
+	gpio_fec_active();
+#endif
+	/* UART1 and UART3 have "on module" transceivers */
+	mxc_register_device(&mxc_uart_device0, &uart0_pdata); /* console */
+	mxc_register_device(&mxc_uart_device2, &uart2_pdata);
+
+	mxc_register_device(&mxc_nand_device, &apf27_nand_board_info);
+
+#ifdef CONFIG_PWM
+	mxc_register_device(&mxc_pwm_device0, &apf27_pwm_0_data);
+#endif
+#ifdef CONFIG_WATCHDOG
+	mxc_register_device(&mxc_wdt, NULL);
+#endif
+	if (otg_mode_host) {
+		mxc_register_device(&mxc_otg_host, &ehci0_pdata);
+	} else {
+		mxc_register_device(&mxc_otg_udc_device, &otg_device_pdata);
+	}
+#ifdef CONFIG_I2C
+	mxc_register_device(&imx_i2c_device1, &apf27_i2c_1_data);
+	i2c_register_board_info(1, apf27_i2c_devices_bus1,
+				ARRAY_SIZE(apf27_i2c_devices_bus1));
+#endif
+	platform_add_devices(platform_devices, ARRAY_SIZE(platform_devices));
+
+	printk("i.MX27 chip revision: %d\n", mx27_revision() );
+
+	apf27_baseboard_init();
+}
+
+static void __init apf27_timer_init(void)
+{
+	mxc_clocks_init(26000000); /* ext ref even if not used */
+	mxc_timer_init("gpt_clk.0");
+}
+
+struct sys_timer apf27_timer = {
+	.init = apf27_timer_init,
+};
+
+void __init apf27_map_io(void)
+{
+	mxc_map_io();
+}
+
+MACHINE_START(APF27, "Armadeus APF27")
+	/* Maintainer: Julien Boibessot <julien.boibessot@armadeus.com> */
+	.phys_io        = AIPI_BASE_ADDR,
+	.io_pg_offst    = ((AIPI_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params    = PHYS_OFFSET + 0x100,
+	.map_io         = apf27_map_io,
+	.init_irq       = mxc_init_irq,
+	.init_machine   = apf27_init,
+	.timer          = &apf27_timer,
+MACHINE_END
Index: linux-2.6.29.6/arch/arm/mach-mx2/apf27-dev.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.6/arch/arm/mach-mx2/apf27-dev.c	2014-01-22 17:48:57.000000000 +0100
@@ -0,0 +1,1178 @@
+ /*
+ * apf27-dev.c
+ * Support for AFP27 module's development baseboard
+ *
+ * Copyright (C) 2009 Armadeus Systems
+ * Authors: Julien Boibessot <julien.boibessot@armadeus.com>
+ *          Nicolas Colombain <nicolas.colombain@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <asm/mach/flash.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spidev.h>
+#include <linux/gpio_keys.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <linux/serial.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/cpufreq.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/io.h>
+#include <asm/mach/arch.h>
+#include <asm/mach-types.h>
+#include <asm/mach/time.h>
+// #include <asm/arch/clock.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/iomux-mx1-mx2.h>
+#include <mach/gpio.h>
+#include <mach/imx_i2c.h>
+//#include <mach/imx_spi.h>
+#include <../mach-imx/include/mach/spi_imx.h>
+#include <mach/imx-uart.h>
+#include <mach/mmc.h>
+#ifdef CONFIG_FB_MXC /* Freescale Framebuffer */
+#include <mach/imx_fb.h>
+#include <mach/imxfb.h>
+#endif
+#include <linux/fb.h>
+#include <mach/mxc_nand.h>
+#include <mach/mxc_ehci.h>
+#include <mach/ulpi.h>
+#include <linux/spi/max1027.h>
+#include <linux/spi/tsc2102.h>
+#include "../../../drivers/net/can/mcp251x.h"
+#include "../../../drivers/armadeus/pwm/pwm.h"
+#include <media/ad9889.h>
+#include <mach/imx_dam.h>
+#include <mach/imx_sound.h>
+#include <mach/imx_ssi.h>
+#include <mach/imx-alsa.h>
+#include <mach/imx_cam.h>
+#include <media/soc_camera.h>
+#if defined(CONFIG_CPU_FREQ_IMX27) || defined(CONFIG_CPU_FREQ_IMX27_MODULE)
+#include "cpufreq_imx.h"
+#endif
+#include <mach/board-apf27.h>
+#include <asm/mach/map.h>
+
+#include "devices.h"
+#include "crm_regs.h"
+
+#ifdef CONFIG_FB_MXC
+extern void apf27_lcd_init(void);
+#endif
+#ifdef CONFIG_MACH_APF27_DEV_EXT
+extern void apf27dev_extension_init(void);
+extern void apf27dev_extension_resume(void);
+extern void apf27dev_extension_suspend(void);
+#endif
+
+#ifdef CONFIG_ARMADEUS_MAX1027_MODULE
+#define CONFIG_ARMADEUS_MAX1027 1
+#endif
+#ifdef CONFIG_SPI_TSC2102_MODULE
+#define CONFIG_SPI_TSC2102 1
+#endif
+#ifdef CONFIG_CAN_MCP251X_MODULE
+#define CONFIG_CAN_MCP251X 1
+#endif
+#ifdef CONFIG_SPI_SPIDEV_MODULE
+#define CONFIG_SPI_SPIDEV 1
+#endif
+#ifdef CONFIG_IMX_BACKLIGHT_MODULE
+#define CONFIG_IMX_BACKLIGHT
+#endif
+#ifdef CONFIG_VIDEO_AD9889_MODULE
+#define CONFIG_VIDEO_AD9889 1
+#endif
+#ifdef CONFIG_VIDEO_MX27_MODULE
+#define CONFIG_VIDEO_MX27 1
+#endif
+#ifdef CONFIG_ARMADEUS_PWM_DRIVER_MODULE
+#define CONFIG_PWM
+#endif
+
+
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+static struct gpio_keys_button apf27dev_gpio_keys[] = {
+	{
+		.code = BTN_EXTRA, /* See include/linux/input.h */
+		.gpio = (GPIO_PORTF | 13), /* GPIO number */
+		.active_low = 1,
+		.desc = "s1", /* Button description*/
+		.wakeup = 0,
+	},
+};
+
+static struct gpio_keys_platform_data apf27dev_gpio_keys_data = {
+	.buttons = apf27dev_gpio_keys,
+	.nbuttons = ARRAY_SIZE(apf27dev_gpio_keys),
+};
+
+static struct platform_device apf27dev_gpio_keys_device = {
+	.name = "gpio-keys",
+	.id = -1,
+	.dev = {
+		.platform_data = &apf27dev_gpio_keys_data,
+	},
+};
+#endif /* CONFIG_KEYBOARD_GPIO */
+
+#if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led apf27dev_led[] = {
+	{
+		.name = "apfdev:green:user",
+		.default_trigger = "heartbeat",
+		.gpio = (GPIO_PORTF | 14),
+		.active_low = 1,
+	},
+};
+
+static struct gpio_led_platform_data apf27dev_led_data = {
+	.num_leds	= ARRAY_SIZE(apf27dev_led),
+	.leds		= apf27dev_led
+};
+
+static struct platform_device apf27dev_led_dev = {
+	.name		= "leds-gpio",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &apf27dev_led_data,
+	},
+};
+#endif /* CONFIG_LEDS_GPIO */
+
+#ifdef CONFIG_I2C
+
+/* APF27Dev makes I2C1 bus available */
+static int mxc_i2c0_pins[] = {
+	PD17_PF_I2C_DATA,
+	PD18_PF_I2C_CLK
+};
+
+static int apf27_i2c_0_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_i2c0_pins, ARRAY_SIZE(mxc_i2c0_pins),
+						"I2C1");
+}
+
+static int apf27_i2c_0_exit(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_i2c0_pins, ARRAY_SIZE(mxc_i2c0_pins));
+
+	return 0;
+}
+
+static struct imx_i2c_platform_data apf27_i2c_0_data = {
+	.max_clk = 400000,
+	.init = apf27_i2c_0_init,
+	.exit = apf27_i2c_0_exit,
+};
+
+/* I2C1 devices: RTC & Optionnal Camera */
+static struct soc_camera_link ov96xx_iclink; /* declared later */
+static struct soc_camera_link mt9m111_iclink; /* declared later */
+static struct soc_camera_link ov7670_iclink; /* declared later */
+
+static struct i2c_board_info apf27dev_i2c_devices_bus0[] = {
+	[0] = {
+		/* APF27Dev has an RTC */
+		.type = "ds1374",
+		.flags = 0,  /* FIXME */
+		.addr = 0x68,	/* E0=0, E1=1, E2=0 */
+		.platform_data = NULL,
+		.irq = 0
+	},
+	[1] = {
+		.type = "ov96xx",
+		.addr = 0x30,
+		.platform_data = &ov96xx_iclink,
+	},
+	[2] = {
+		.type = "mt9m111",
+		.addr = 0x5d,
+		.platform_data = &mt9m111_iclink,
+	},
+	[3] = {
+		.type = "ov7670",
+		.addr = 0x21,
+		.platform_data = &ov7670_iclink,
+	},
+};
+
+
+/* APF27Dev has an optionnal HDMI video output (controlled with I2C2) */
+# ifdef CONFIG_VIDEO_AD9889
+#define AD9889_INT 15
+
+static int ad9889_pins[] = {
+	(GPIO_PORTC | GPIO_IN | GPIO_GPIO | AD9889_INT),
+};
+
+static int ad9889_init(void)
+{
+	return mxc_gpio_setup_multiple_pins(ad9889_pins, ARRAY_SIZE(ad9889_pins),
+						"AD9889");
+}
+
+static int ad9889_exit(void)
+{
+	mxc_gpio_release_multiple_pins(ad9889_pins, ARRAY_SIZE(ad9889_pins));
+
+	return 0;
+}
+
+struct ad9889_fb_data {
+	struct fb_var_screeninfo var;
+	int PA31_GIUS_old_state;
+};
+
+static struct ad9889_fb_data apf27_ad9889_fb_data;
+extern void acquire_console_sem(void);
+extern void release_console_sem(void);
+
+static void ad9889_display_connected(void)
+{
+	struct fb_var_screeninfo temp_var;
+	struct fb_info *info = registered_fb[0];
+
+	apf27_ad9889_fb_data.PA31_GIUS_old_state = 0;
+	/* make sure the LCD OE_ACD pin is correctly configured */
+	if (__raw_readl(VA_GPIO_BASE + MXC_GIUS(0)) & 0x80000000) {
+		apf27_ad9889_fb_data.PA31_GIUS_old_state = 1;
+		mxc_gpio_mode(PA31_PF_OE_ACD);
+	}
+
+	/* save old FB params */
+	memcpy(&apf27_ad9889_fb_data.var, &info->var, sizeof(struct fb_var_screeninfo));
+	memcpy(&temp_var, &info->var, sizeof(struct fb_var_screeninfo));
+
+	/* set new FB params */
+	temp_var.xres = 640;
+	temp_var.yres = 480;
+	temp_var.xres_virtual = 640;
+	temp_var.yres_virtual = 480;
+	temp_var.pixclock = 37538;
+	temp_var.left_margin = 47;
+	temp_var.right_margin = 47; /* at least 3 & 1 */
+	temp_var.upper_margin = 33;
+	temp_var.lower_margin = 10;
+	temp_var.hsync_len = 63;
+	temp_var.vsync_len = 2;
+# ifdef CONFIG_FB_MXC
+	temp_var.sync = FB_SYNC_OE_ACT_HIGH; /* -> Will change PCR */
+# endif
+	temp_var.vmode = FB_VMODE_NONINTERLACED,
+	temp_var.nonstd = 0;
+
+	acquire_console_sem();
+	/* tel the FB client that params have been changed */
+	info->flags |= FBINFO_MISC_USEREVENT;
+	/* set new params */
+	fb_set_var(info, &temp_var);
+	info->flags &= ~FBINFO_MISC_USEREVENT;
+	release_console_sem();
+}
+
+static void ad9889_display_disconnected(void)
+{
+	struct fb_info *info = registered_fb[0];
+
+	/* restore LCD OE_ACD pin */
+	if (apf27_ad9889_fb_data.PA31_GIUS_old_state)
+		mxc_gpio_mode(GPIO_PORTA | 31 | GPIO_OUT| GPIO_GPIO);
+
+	acquire_console_sem();
+	/* inform the console that the FB params have been changed */
+	info->flags |= FBINFO_MISC_USEREVENT;
+	/* restore old FB params */
+	fb_set_var(info, &apf27_ad9889_fb_data.var);
+	info->flags &= ~FBINFO_MISC_USEREVENT;
+	release_console_sem();
+}
+
+static struct ad9889_config apf27_ad9889_config = {
+	.init = ad9889_init,
+	.exit = ad9889_exit,
+	.display_connected = ad9889_display_connected,
+	.display_disconnected = ad9889_display_disconnected,
+	.data = &apf27_ad9889_fb_data,
+	.EDID_I2C_addr = 0x3f
+};
+# endif /* CONFIG_VIDEO_AD9889 */
+
+/* I2C2 devices */
+static struct i2c_board_info apf27dev_i2c_devices_bus1[] = {
+# ifdef CONFIG_VIDEO_AD9889
+	[0] = {
+		.type = "ad9889",
+		.flags = 0,
+		.addr = 0x39,
+		.platform_data = &apf27_ad9889_config,
+		.irq = IRQ_GPIOC(AD9889_INT)
+	},
+# endif /* CONFIG_VIDEO_AD9889 */
+};
+#endif /* CONFIG_I2C */
+
+
+/* UART2 signals are available on J8 connector (multiplexed with Keypad) */
+#ifdef CONFIG_SERIAL_IMX_UART2
+
+static int mxc_uart1_pins[] = {
+#ifdef CONFIG_SERIAL_IMX_UART2_USE_RTSCTS
+	PE3_PF_UART2_CTS,
+	PE4_PF_UART2_RTS,
+#endif
+	PE6_PF_UART2_TXD,
+	PE7_PF_UART2_RXD,
+};
+
+static int uart_mxc_port1_init(struct platform_device *pdev)
+{
+	int res = mxc_gpio_setup_multiple_pins(mxc_uart1_pins,
+			ARRAY_SIZE(mxc_uart1_pins), "UART2");
+
+	return res;
+}
+
+static int uart_mxc_port1_exit(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_uart1_pins, ARRAY_SIZE(mxc_uart1_pins));
+
+	return 0;
+}
+
+static struct imxuart_platform_data uart1_pdata = {
+	.init = uart_mxc_port1_init,
+	.exit = uart_mxc_port1_exit,
+#ifdef CONFIG_SERIAL_IMX_UART2_USE_RTSCTS
+	.flags = IMXUART_HAVE_RTSCTS,
+#else
+	.flags = 0,
+#endif
+};
+#endif /* CONFIG_SERIAL_IMX_UART2 */
+
+
+/* UART5 signals are available on J9 connector (multiplexed with CSI) */
+#ifdef CONFIG_SERIAL_IMX_UART5
+
+static int mxc_uart4_pins[] = {
+	PB19_AF_UART5_RXD,
+	PB18_AF_UART5_TXD,
+#ifdef CONFIG_SERIAL_IMX_UART5_USE_RTSCTS
+	PB20_AF_UART5_CTS,
+	PB21_AF_UART5_RTS,
+#endif
+};
+
+static int uart_mxc_port4_init(struct platform_device *pdev)
+{
+	int res = mxc_gpio_setup_multiple_pins(mxc_uart4_pins,
+			ARRAY_SIZE(mxc_uart4_pins), "UART5");
+
+	return res;
+}
+
+static int uart_mxc_port4_exit(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_uart4_pins,
+			ARRAY_SIZE(mxc_uart4_pins));
+
+	return 0;
+}
+
+static struct imxuart_platform_data uart4_pdata = {
+	.init = uart_mxc_port4_init,
+	.exit = uart_mxc_port4_exit,
+#ifdef CONFIG_SERIAL_IMX_UART5_USE_RTSCTS
+	.flags = IMXUART_HAVE_RTSCTS,
+#else
+	.flags = 0,
+#endif
+};
+#endif /* CONFIG_SERIAL_IMX_UART5 */
+
+/* UART6 signals are available on J9 connector (multiplexed with CSI) */
+#ifdef CONFIG_SERIAL_IMX_UART6
+
+static int mxc_uart5_pins[] = {
+	PB10_AF_UART6_TXD,
+	PB11_AF_UART6_RXD,
+#ifdef CONFIG_SERIAL_IMX_UART6_USE_RTSCTS
+	PB12_AF_UART6_CTS,
+	PB13_AF_UART6_RTS,
+#endif
+};
+
+static int uart_mxc_port5_init(struct platform_device *pdev)
+{
+	int res = mxc_gpio_setup_multiple_pins(mxc_uart5_pins,
+			ARRAY_SIZE(mxc_uart5_pins), "UART6");
+
+	return res;
+}
+
+static int uart_mxc_port5_exit(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_uart5_pins, ARRAY_SIZE(mxc_uart5_pins));
+
+	return 0;
+}
+
+static struct imxuart_platform_data uart5_pdata = {
+	.init = uart_mxc_port5_init,
+	.exit = uart_mxc_port5_exit,
+#ifdef CONFIG_SERIAL_IMX_UART6_USE_RTSCTS
+	.flags = IMXUART_HAVE_RTSCTS,
+#else
+	.flags = 0,
+#endif
+};
+#endif /* CONFIG_SERIAL_IMX_UART6 */
+
+
+/* SPI ports declarations */
+#ifdef CONFIG_SPI_MXC_SELECT1
+static int mxc_cspi0_pins[] = {
+	/* PD28_PF_CSPI1_SS0, Preferably use CS pin as GPIO */
+	PD29_PF_CSPI1_SCLK,
+	PD30_PF_CSPI1_MISO,
+	PD31_PF_CSPI1_MOSI
+};
+#endif /* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+static int mxc_cspi1_pins[] = {
+	/* PD19_PF_CSPI2_SS2,
+	PD20_PF_CSPI2_SS1, Preferably use CS pin as GPIO
+	PD21_PF_CSPI2_SS0, */
+	PD22_PF_CSPI2_SCLK,
+	PD23_PF_CSPI2_MISO,
+	PD24_PF_CSPI2_MOSI
+};
+#endif /* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+static int mxc_cspi2_pins[] = {
+	/*
+	PE21_AF_CSPI3_SS,
+	Preferably use CS pin as GPIO
+	*/
+	PE23_AF_CSPI3_SCLK,
+	PE18_AF_CSPI3_MISO,
+	PE22_AF_CSPI3_MOSI
+};
+#endif /* CONFIG_SPI_MXC_SELECT3 */
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+static int gpio_spi0_active(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_cspi0_pins,
+			ARRAY_SIZE(mxc_cspi0_pins), "CSPI1");
+}
+
+static int gpio_spi0_inactive(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_cspi0_pins, ARRAY_SIZE(mxc_cspi0_pins));
+	return 0;
+}
+#endif /* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+static int gpio_spi1_active(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_cspi1_pins,
+			ARRAY_SIZE(mxc_cspi1_pins), "CSPI2");
+}
+
+static int gpio_spi1_inactive(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_cspi1_pins, ARRAY_SIZE(mxc_cspi1_pins));
+	return 0;
+}
+#endif /* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+static int gpio_spi2_active(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_cspi2_pins, ARRAY_SIZE(mxc_cspi2_pins), "CSPI3");
+}
+
+static int gpio_spi2_inactive(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_cspi2_pins, ARRAY_SIZE(mxc_cspi2_pins));
+	return 0;
+}
+#endif /* CONFIG_SPI_MXC_SELECT3 */
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+static struct spi_imx_master imx_spi0_master_info = {
+	.num_chipselect	= 1,
+	.enable_dma     = 0,
+	.init = gpio_spi0_active,
+	.exit = gpio_spi0_inactive,
+};
+#endif /* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+static struct spi_imx_master imx_spi1_master_info = {
+	.num_chipselect	= 3,
+	.enable_dma     = 0,
+	.init = gpio_spi1_active,
+	.exit = gpio_spi1_inactive,
+};
+#endif /* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+static struct spi_imx_master imx_spi2_master_info = {
+	.num_chipselect	= 1,
+	.enable_dma     = 0,
+	.init = gpio_spi2_active,
+	.exit = gpio_spi2_inactive,
+};
+#endif /* CONFIG_SPI_MXC_SELECT3 */
+
+
+
+/* APF27Dev has an optionnal 7 channels 10 bits ADC (SPI1) */
+#ifdef CONFIG_ARMADEUS_MAX1027
+#define MAX1027_EOC_INT 15
+#define MAX1027_CNVST 14
+#define MAX1027_CS (GPIO_PORTD | 28)
+
+static int max1027_pins[] = {
+	(MAX1027_CS | GPIO_OUT | GPIO_GPIO),
+	(GPIO_PORTE | GPIO_IN | GPIO_GPIO | MAX1027_EOC_INT),
+	(GPIO_PORTE | GPIO_OUT | GPIO_GPIO | MAX1027_CNVST),
+};
+
+static int max1027_init(struct spi_device *spi)
+{
+	gpio_set_value(MAX1027_CS, 1);
+	return mxc_gpio_setup_multiple_pins(max1027_pins, ARRAY_SIZE(max1027_pins), "MAX1027");
+}
+
+static int max1027_exit(struct spi_device *spi)
+{
+	mxc_gpio_release_multiple_pins(max1027_pins, ARRAY_SIZE(max1027_pins));
+	return 0;
+}
+
+static void max1027_cs(u32 command)
+{
+	if (command == SPI_CS_DEASSERT)
+		gpio_set_value(MAX1027_CS, 1);
+	else
+		gpio_set_value(MAX1027_CS, 0);
+}
+
+static struct spi_imx_chip max1027_hw = {
+	.cs_control = max1027_cs,
+};
+
+static struct max1027_config apf27_max1027_config = {
+	.conv = MAX1027_CONV_DEFAULT,
+	.setup = MAX1027_SETUP_DEFAULT,
+	.avg = MAX1027_AVG_DEFAULT,
+	.cnvst_pin = (int)(MAX1027_CNVST|GPIO_PORTE),
+	.init = max1027_init,
+	.exit = max1027_exit
+};
+#endif /* CONFIG_ARMADEUS_MAX1027 */
+
+/* APF27Dev has a SPI Touchscreen controller */
+#define TSC2101_INT 17
+#define TSC2101_CS (GPIO_PORTD | 21)	/* SPI2_SS0 used as GPIO */
+
+/* CS can be used as GPIO too, if communication with TSC is deactivated (thanks
+   to TXB0108 chip (U23). INT pin can't and so must be reserved in any case */
+static int tsc2101_pins[] = {
+        (TSC2101_CS | GPIO_OUT | GPIO_GPIO),
+};
+static int tsc2101_fixed_pins[] = {
+	(GPIO_PORTF | TSC2101_INT | GPIO_IN | GPIO_GPIO), /* configure INT pin as GPIO */
+};
+
+static int tsc2101_init_gpio(void)
+{
+	/* Initialize CS high */
+	gpio_set_value(TSC2101_CS, 1);
+
+	return mxc_gpio_setup_multiple_pins(tsc2101_pins, ARRAY_SIZE(tsc2101_pins),
+						"TSC2101");
+}
+
+static int tsc2101_init_fixed_gpio(void)
+{
+        return mxc_gpio_setup_multiple_pins(tsc2101_fixed_pins,
+					ARRAY_SIZE(tsc2101_fixed_pins), "TSC2101");
+}
+
+static void tsc2101_release_gpio(void)
+{
+        mxc_gpio_release_multiple_pins(tsc2101_pins, ARRAY_SIZE(tsc2101_pins));
+}
+
+static void tsc2101_cs(u32 command)
+{
+	if (command == SPI_CS_DEASSERT)
+		gpio_set_value(TSC2101_CS, 1);
+	else
+		gpio_set_value(TSC2101_CS, 0);
+}
+
+static struct spi_imx_chip tsc2101_hw = {
+	.cs_control = tsc2101_cs,
+};
+
+static struct tsc210x_config apf27_tsc2101_config = {
+	.mclk =	12288000, /* MCLK value in Master mode */
+	.use_internal = 1, /* -> use internal voltage reference */
+	.monitor = TSC_BAT1 | TSC_AUX | TSC_TEMP,
+	.init = tsc2101_init_gpio,
+	.exit = tsc2101_release_gpio,
+};
+
+
+/* APF27Dev has an optional CAN Bus controller */
+#ifdef CONFIG_CAN_MCP251X
+
+#define CAN_MCP251X_INT 19
+#define MCP251X_CS (GPIO_PORTD | 20)
+
+static int mcp251x_pins[] = {
+	(GPIO_PORTD | CAN_MCP251X_INT | GPIO_IN | GPIO_GPIO), /* IRQ pin as GPIO */
+	(MCP251X_CS | GPIO_OUT | GPIO_GPIO),
+};
+
+static void mcp251x_init_irq(void)
+{
+	gpio_set_value(MCP251X_CS, 1);
+	mxc_gpio_setup_multiple_pins(mcp251x_pins, ARRAY_SIZE(mcp251x_pins), "MCP251x");
+}
+
+static void mcp251x_cs(u32 command)
+{
+	if (command == SPI_CS_DEASSERT)
+		gpio_set_value(MCP251X_CS, 1);
+	else
+		gpio_set_value(MCP251X_CS, 0);
+}
+
+static struct spi_imx_chip mcp251X_hw = {
+	.cs_control		= mcp251x_cs,
+};
+
+static struct mcp251x_platform_data apf27_mcp251x_config = {
+	.oscillator_frequency  = 16000000,
+	.board_specific_setup  = mcp251x_init_irq,
+	.device_reset          = NULL,
+	.transceiver_enable    = NULL,
+};
+#endif /* CONFIG_CAN_MCP251X */
+
+
+/* SPI2 can be used as userspace general SPI bus (CS 2) */
+#ifdef CONFIG_SPI_SPIDEV
+#define SPIDEV_CS (GPIO_PORTB | 17)
+
+static int spidev_pins[] = {
+	(SPIDEV_CS | GPIO_OUT | GPIO_GPIO),
+};
+
+static int spidev_init_gpio(void)
+{
+	gpio_set_value(SPIDEV_CS, 1);
+	return mxc_gpio_setup_multiple_pins(spidev_pins, ARRAY_SIZE(spidev_pins), "spidev");
+}
+
+/* Chip select command for spidev */
+static void spidev_cs(u32 command)
+{
+	if (command == SPI_CS_DEASSERT)
+		gpio_set_value(SPIDEV_CS, 1);
+	else
+		gpio_set_value(SPIDEV_CS, 0);
+}
+
+static struct spi_imx_chip spidev_hw = {
+	.cs_control     = spidev_cs,
+};
+
+static struct spidev_platform_data apf27_spidev_config = {
+	.init = spidev_init_gpio,
+};
+#endif /* CONFIG_SPI_SPIDEV */
+
+static struct spi_board_info spi_board_info[] __initdata = {
+#ifdef CONFIG_ARMADEUS_MAX1027
+	{
+		.modalias		= "max1027",
+		.controller_data 	= &max1027_hw,
+		.max_speed_hz		= 8000000,
+		.bus_num		= 0, /* SPI1 */
+		.irq			= IRQ_GPIOE(MAX1027_EOC_INT),
+		.chip_select		= 0, /* SS0 */
+		.mode 			= 0,
+		.platform_data		= &apf27_max1027_config,
+	},
+#endif /* CONFIG_ARMADEUS_MAX1027 */
+#ifdef CONFIG_SPI_TSC2102
+	{
+		.modalias		= "tsc210x",
+		.controller_data 	= &tsc2101_hw,
+		.max_speed_hz		= 8000000,
+		.bus_num		= 1, /* SPI2 */
+		.irq			= IRQ_GPIOF(TSC2101_INT),
+		.chip_select		= 0,
+		.mode 			= 0,
+		.platform_data		= &apf27_tsc2101_config,
+	},
+#endif /* CONFIG_SPI_TSC2102 */
+#ifdef CONFIG_CAN_MCP251X
+	{
+		.modalias		= "mcp251x",
+		.controller_data	= &mcp251X_hw,
+		.max_speed_hz		= 8000000, /* 8MHz */
+		.bus_num		= 1, /* SPI2 */
+		.mode			= 0,
+		.chip_select		= 1,
+		.irq			= IRQ_GPIOD(CAN_MCP251X_INT),
+		.platform_data		= &apf27_mcp251x_config,
+	},
+#endif /* CONFIG_CAN_MCP251X */
+#ifdef CONFIG_SPI_SPIDEV
+	{
+		.modalias		= "spidev",
+		.controller_data	= &spidev_hw,
+		.max_speed_hz		= 8000000, /* 8MHz */
+		.bus_num		= 1, /* SPI2 */
+		.mode			= SPI_MODE_1,
+		.chip_select		= 2,
+		.platform_data		= &apf27_spidev_config,
+	},
+#endif /* CONFIG_SPI_SPIDEV */
+};
+
+
+/* APF27Dev adds an USB PHY on i.MX27 USB_HOST port 2 */
+#ifdef CONFIG_USB_EHCI_MXC
+static int mxc_usbh1_pins[] = {
+	PB22_PF_USBH1_SUSP,
+	PB23_PF_USB_PWR,
+	PB24_PF_USB_OC_B,
+	PB25_PF_USBH1_RCV,
+	PB26_PF_USBH1_FS,
+	PB27_PF_USBH1_OE_B,
+	PB28_PF_USBH1_TXDM,
+	PB29_PF_USBH1_TXDP,
+	PB30_PF_USBH1_RXDM,
+	PB31_PF_USBH1_RXDP
+};
+
+static int apf27_usbh1_init(struct platform_device *pdev)
+{
+	int ret;
+	uint32_t temp;
+
+	ret = mxc_gpio_setup_multiple_pins(mxc_usbh1_pins,
+			ARRAY_SIZE(mxc_usbh1_pins), "usbh1");
+	if (ret)
+		return ret;
+
+	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
+	pr_debug("USB_CTRL before: 0x%08x\n", temp);
+	temp &= ~( (3 << 13) | (1 << 8) |  1 );
+	temp |=  (1 << 4) | (1 << 11) ;
+	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + 0x600);
+	pr_debug("USB_CTRL after: 0x%08x\n", temp);
+
+	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + 0x384);
+	pr_debug("PORTSC1 before: 0x%08x\n", temp);
+	temp &= ~(3 << 30);
+	temp |= 3 << 30;
+	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + 0x384);
+	pr_debug("PORTSC1 after: 0x%08x\n", temp);
+	mdelay(10);
+
+	temp = readl(IO_ADDRESS(OTG_BASE_ADDR) + 0x340);
+	temp |= 0x02; /* reset controller */
+	writel(temp, IO_ADDRESS(OTG_BASE_ADDR) + 0x340);
+	pr_debug("reset controller: 0x%08x\n", temp);
+	mdelay(10);
+
+	return ret;
+}
+
+struct mxc_usb2_platform_data ehci1_pdata = {
+	.init = apf27_usbh1_init,
+};
+#endif /* CONFIG_USB_EHCI_MXC */
+
+
+#if defined(CONFIG_SND_IMX_TSC2102) || defined(CONFIG_SND_IMX_TSC2102_MODULE)
+static struct imx_alsa_codec_config tsc2101_alsa_pdata;
+
+static struct resource ssi_resources[] = {
+	[0] = {
+		.start	= SSI1_BASE_ADDR,
+		.end	= SSI1_BASE_ADDR + 0x6F,
+		.flags	= IORESOURCE_MEM
+	},
+};
+
+static struct platform_device tsc2101_alsa_device = {
+	.name           = "tsc210x-alsa",
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(ssi_resources),
+	.resource       = ssi_resources,
+	.dev            = {
+				.platform_data = &tsc2101_alsa_pdata,
+			}
+};
+# define ALSA_SOUND &tsc2101_alsa_device,
+#else
+# define ALSA_SOUND
+#endif /* CONFIG_SND_IMX_TSC2102 || CONFIG_SND_IMX_TSC2102_MODULE */
+
+static struct platform_device *platform_devices[] __initdata = {
+#if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
+	&apf27dev_led_dev,
+#endif
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+	&apf27dev_gpio_keys_device,
+#endif
+	ALSA_SOUND
+};
+
+
+/* SSI1 port is directly connected to TSC2101 and can't be used for
+   anything else */
+static int mxc_ssi1_pins[] = {
+	PC20_PF_SSI1_FS,
+	PC21_PF_SSI1_RXD,
+	PC22_PF_SSI1_TXD,
+	PC23_PF_SSI1_CLK,
+};
+
+static int gpio_ssi1_active(struct platform_device *pdev)
+{
+	int err;
+
+	err = mxc_gpio_setup_multiple_pins(mxc_ssi1_pins,
+					ARRAY_SIZE(mxc_ssi1_pins), "mx2-sound");
+	if (err < 0)
+		pr_err("Failed to register SSI pins\n");
+
+	return err;
+}
+
+static int gpio_ssi1_inactive(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_ssi1_pins, ARRAY_SIZE(mxc_ssi1_pins));
+	return 0;
+}
+
+static struct imx_ssi_platform_data apf27_ssi0_pdata = {
+	.init = gpio_ssi1_active,
+	.exit = gpio_ssi1_inactive
+};
+
+static int apf27_late_init(void)
+{
+	mxc_register_device(&mxc_dam_device, NULL);
+	mxc_register_device(&imx_ssi_device0, &apf27_ssi0_pdata);
+
+	return 0;
+}
+
+late_initcall(apf27_late_init);
+
+
+/* APF27Dev has a microSD connector */
+#ifdef CONFIG_MMC_MXC
+static int mxc_sdhc2_pins[] = {
+	PB4_PF_SDHC2_D0,
+	PB5_PF_SDHC2_D1,
+	PB6_PF_SDHC2_D2,
+	PB7_PF_SDHC2_D3,
+	PB8_PF_SDHC2_CMD,
+	PB9_PF_SDHC2_CLK,
+};
+
+static int apf27_sdhc2_init(struct device *dev, irq_handler_t detect_irq, void *data)
+{
+	int ret;
+
+	mxc_gpio_setup_multiple_pins(mxc_sdhc2_pins, ARRAY_SIZE(mxc_sdhc2_pins), "SDHC2");
+
+	ret = request_irq(IRQ_GPIOC(14), detect_irq, 0, "imx-mmc-detect", data);
+	if (ret)
+		goto out_release_gpio;
+	set_irq_type(IRQ_GPIOC(14), IRQ_TYPE_EDGE_BOTH);
+
+	return 0;
+
+out_release_gpio:
+	mxc_gpio_release_multiple_pins(mxc_sdhc2_pins, ARRAY_SIZE(mxc_sdhc2_pins));
+
+	return ret;
+}
+
+static void apf27_sdhc2_exit(struct device *dev, void *data)
+{
+	free_irq(IRQ_GPIOC(14), data);
+	mxc_gpio_release_multiple_pins(mxc_sdhc2_pins, ARRAY_SIZE(mxc_sdhc2_pins));
+}
+
+static struct imxmmc_platform_data apf27_sdhc2_pdata = {
+	.init = apf27_sdhc2_init,
+	.exit = apf27_sdhc2_exit,
+};
+
+static inline void apf27dev_init_mmc(void)
+{
+	mxc_register_device(&mxc_sdhc_device1, &apf27_sdhc2_pdata);
+}
+#endif /* CONFIG_MMC_MXC */
+
+
+/* APF27Dev can have an optional Camera module extension using i.MX27 CSI */
+#ifdef CONFIG_VIDEO_MX27
+
+static int apf27dev_csi_pins[] = {
+	PB10_PF_CSI_D0,
+	PB11_PF_CSI_D1,
+	PB12_PF_CSI_D2,
+	PB13_PF_CSI_D3,
+	PB14_PF_CSI_D4,
+	PB15_PF_CSI_MCLK,
+	PB16_PF_CSI_PIXCLK,
+	PB17_PF_CSI_D5,
+	PB18_PF_CSI_D6,
+	PB19_PF_CSI_D7,
+	PB20_PF_CSI_VSYNC,
+	PB21_PF_CSI_HSYNC
+};
+
+static int apf27dev_camera_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(apf27dev_csi_pins,
+				ARRAY_SIZE(apf27dev_csi_pins), "CSI");
+}
+
+static int apf27dev_camera_exit(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(apf27dev_csi_pins, ARRAY_SIZE(apf27dev_csi_pins));
+
+	return 0;
+}
+
+struct mx27_camera_platform_data apf27_camera = {
+	.init = apf27dev_camera_init,
+	.exit = apf27dev_camera_exit,
+	.clk  = 26600000,
+	.flags = MX27_CAMERA_HSYNC_HIGH | MX27_CAMERA_GATED_CLOCK |
+			MX27_CAMERA_SWAP16,
+};
+
+static int ov96xx_power(struct device *dev, int state)
+{
+        printk(KERN_DEBUG "*** %s %d (not implemented)\n", __func__, state);
+
+        return 0;
+}
+
+static struct soc_camera_link ov96xx_iclink = {
+        .bus_id = 0,
+        .power = ov96xx_power,
+};
+
+static int mt9m111_power(struct device *dev, int state)
+{
+        printk(KERN_DEBUG "*** %s %d (not implemented)\n", __func__, state);
+
+        return 0;
+}
+
+static struct soc_camera_link mt9m111_iclink = {
+        .bus_id = 0,
+        .power = mt9m111_power,
+};
+
+static int ov7670_power(struct device *dev, int state)
+{
+        printk(KERN_DEBUG "*** %s %d (not implemented)\n", __func__, state);
+
+        return 0;
+}
+
+static struct soc_camera_link ov7670_iclink = {
+        .bus_id = 0,
+        .power = ov7670_power,
+};
+
+#endif /* CONFIG_VIDEO_MX27 */
+
+
+/* APF27Dev power management stuff */
+
+#define APF27DEV_USER_SWITCH		(GPIO_PORTF | 13)
+#define APF27DEV_USER_SWITCH_IRQ	(IRQ_GPIOF(13))
+#define APF27DEV_USER_LED		(GPIO_PORTF | 14)
+#define APF27DEV_POWER_DOWN_NOT		(GPIO_PORTF | 16)
+
+static int apf27dev_pwr_ctl_pins[] = {
+	(APF27DEV_POWER_DOWN_NOT | GPIO_OUT | GPIO_GPIO),
+#ifdef CONFIG_USE_APF27DEV_IMX_SWITCH_FOR_PM
+	(APF27DEV_USER_SWITCH | GPIO_IN | GPIO_GPIO),
+#endif
+#ifdef CONFIG_USE_APF27DEV_IMX_LED_FOR_PM
+	(APF27DEV_USER_LED | GPIO_OUT | GPIO_GPIO),
+#endif
+};
+
+void apf27_baseboard_resume(void)
+{
+#ifdef CONFIG_MACH_APF27_DEV_EXT
+	apf27dev_extension_resume();
+#endif
+	gpio_set_value(APF27DEV_POWER_DOWN_NOT, 1);
+#ifdef CONFIG_USE_APF27DEV_IMX_LED_FOR_PM
+	gpio_set_value(GPIO_PORTF | 14, 0);
+#endif
+}
+
+void apf27_baseboard_suspend(void)
+{
+#ifdef CONFIG_MACH_APF27_DEV_EXT
+	apf27dev_extension_suspend();
+#endif
+	gpio_set_value(APF27DEV_POWER_DOWN_NOT, 0);
+#ifdef CONFIG_USE_APF27DEV_IMX_LED_FOR_PM
+	gpio_set_value(GPIO_PORTF | 14, 1);
+#endif
+}
+
+#ifdef CONFIG_USE_APF27DEV_IMX_SWITCH_FOR_PM
+static irqreturn_t apf27dev_user_switch_irq_handler(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+#endif
+
+static int apf27dev_pwr_ctrl_gpio_active(void)
+{
+	int err;
+
+	err = mxc_gpio_setup_multiple_pins(apf27dev_pwr_ctl_pins,
+					ARRAY_SIZE(apf27dev_pwr_ctl_pins), "pwr-ctl");
+	if (err < 0)
+		pr_err("Failed to register power control pins !\n");
+
+	gpio_set_value(APF27DEV_POWER_DOWN_NOT, 1);
+#ifdef CONFIG_USE_APF27DEV_IMX_LED_FOR_PM
+	gpio_set_value(GPIO_PORTF | 14, 0);
+#endif
+#ifdef CONFIG_USE_APF27DEV_IMX_SWITCH_FOR_PM
+	err = request_irq(APF27DEV_USER_SWITCH_IRQ, apf27dev_user_switch_irq_handler,
+				IRQF_TRIGGER_FALLING,
+				"PM irq", NULL);
+	if (err < 0)
+		pr_err("Failed to register PM irq !\n");
+#endif
+
+	return err;
+}
+
+void __init apf27_baseboard_init(void)
+{
+	printk("    Registering APF27_Dev ressources:");
+
+#if defined(CONFIG_FB_MXC) || defined(CONFIG_FB_IMX)
+	/* APF27Dev has an LCD connector */
+	apf27_lcd_init();
+#endif
+
+	apf27dev_pwr_ctrl_gpio_active();
+
+#ifdef CONFIG_SERIAL_IMX_UART2
+	mxc_register_device(&mxc_uart_device1, &uart1_pdata);
+#endif
+#ifdef CONFIG_SERIAL_IMX_UART5
+	mxc_register_device(&mxc_uart_device4, &uart4_pdata);
+#endif
+#ifdef CONFIG_SERIAL_IMX_UART6
+	mxc_register_device(&mxc_uart_device5, &uart5_pdata);
+#endif
+#ifdef CONFIG_USB_EHCI_MXC
+	mxc_register_device(&mxc_ehci1, &ehci1_pdata);
+#endif
+#ifdef CONFIG_I2C
+	mxc_register_device(&imx_i2c_device0, &apf27_i2c_0_data);
+	i2c_register_board_info(0, apf27dev_i2c_devices_bus0,
+				ARRAY_SIZE(apf27dev_i2c_devices_bus0));
+	i2c_register_board_info(1, apf27dev_i2c_devices_bus1,
+				ARRAY_SIZE(apf27dev_i2c_devices_bus1));
+#endif
+#ifdef CONFIG_SPI_MXC_SELECT1
+	mxc_register_device(&mxc_spi_device0, &imx_spi0_master_info);
+#endif
+#ifdef CONFIG_SPI_MXC_SELECT2
+	mxc_register_device(&mxc_spi_device1, &imx_spi1_master_info);
+#endif
+#ifdef CONFIG_SPI_MXC_SELECT3
+	mxc_register_device(&mxc_spi_device2, &imx_spi2_master_info);
+#endif
+
+
+	platform_add_devices(platform_devices, ARRAY_SIZE(platform_devices));
+
+#ifdef CONFIG_SPI_TSC2102
+	/* Due to an hardware "bug", force TSC2101 ChipSelect at startup
+	   (on some APF27Dev boards CS stays low, due to TXB0108 chip (U23))
+	   and too weak i.MX27 internal pullup resistors */
+	tsc2101_init_gpio();
+	tsc2101_release_gpio();
+	/* Reserve "fixed" GPIOs */
+	tsc2101_init_fixed_gpio();
+#endif
+#if defined (CONFIG_ARMADEUS_MAX1027) || defined (CONFIG_SPI_TSC2102) || defined (CONFIG_CAN_MCP251X) || defined(CONFIG_SPI_SPIDEV)
+	spi_register_board_info(spi_board_info,
+				ARRAY_SIZE(spi_board_info));
+#endif
+#ifdef CONFIG_MMC_MXC
+	apf27dev_init_mmc();
+#endif
+#ifdef CONFIG_VIDEO_MX27
+	mxc_register_device(&mx27_camera_device, &apf27_camera);
+#endif
+#ifdef CONFIG_MACH_APF27_DEV_EXT
+	apf27dev_extension_init();
+#endif
+
+	printk("done\n");
+}
+
Index: linux-2.6.29.6/arch/arm/mach-mx2/apf27-lcd.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.6/arch/arm/mach-mx2/apf27-lcd.c	2014-01-22 16:39:52.332884647 +0100
@@ -0,0 +1,220 @@
+/*
+ * apf27-lcd.c
+ *
+ * Handle support of multiple LCDs on the APF27Dev
+ *
+ * Copyright (C) 2009 Armadeus Systems
+ * Authors: Julien Boibessot <julien.boibessot@armadeus.com>
+ *          Nicolas Colombain <nicolas.colombain@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+
+#include <mach/iomux-mx1-mx2.h>
+#include <mach/gpio.h>
+#ifdef CONFIG_FB_MXC /* Freescale Framebuffer */
+#include <mach/imx_fb.h>
+#include <mach/imxfb.h>
+#endif
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <mach/common.h>
+#include "devices.h"
+
+
+#ifdef CONFIG_IMX_BACKLIGHT_MODULE
+#define CONFIG_IMX_BACKLIGHT
+#endif
+
+#ifdef CONFIG_FB_IMX_OPTREX_T51638D084_TFT
+# define LCD_NAME	"Optrex-T51638D084"
+/* PS is used as LCD Display ON/OFF */
+# define LCD_USES_PS_AS_GPIO
+/* activates LCD at startup */
+# define LCD_POWER_GPIO	(GPIO_PORTA | 26)
+# define LCD_POWER_ON	(1)
+#endif
+
+#ifdef CONFIG_FB_IMX_SHARP_LQ057_TFT
+# define LCD_NAME	"Sharp-LQ057"
+/* CONTRAST is used as backlight's ON/OFF */
+# define LCD_USES_CONTRAST_AS_GPIO
+/* activates backlight at startup */
+# define LCD_BACKLIGHT_GPIO	(GPIO_PORTA | 30)
+# define LCD_BACKLIGHT_ON	(0)
+#endif
+
+#ifdef CONFIG_FB_IMX_SHARP_LQ043_TFT
+# define LCD_NAME	"Sharp-LQ043"
+/* OE_ACD is used as LCD Display ON/OFF */
+# define LCD_USES_OE_ACD_AS_GPIO
+/* activates LCD at startup */
+# define LCD_POWER_GPIO (GPIO_PORTA | 31)
+# define LCD_POWER_ON	(1)
+#endif
+
+#ifdef CONFIG_FB_IMX_CHIMEI_LW700AT9003_TFT
+# define LCD_NAME	"Chimei-LW700AT9003"
+#endif
+
+#ifdef CONFIG_FB_IMX_HITACHI_TX12D17VM1BDP_TFT
+# define LCD_NAME	"Hitachi-TX12D17VM1BDP"
+#endif
+
+/* Please always let the custom LCD in this (last) position: */
+#ifdef CONFIG_FB_IMX_CUSTOM_LCD
+# define LCD_NAME	"Custom" /* Clone of LQ043 by default */
+/* OE_ACD is used as LCD Display ON/OFF */
+# define LCD_USES_OE_ACD_AS_GPIO
+/* activates LCD at startup */
+# define LCD_POWER_GPIO (GPIO_PORTA | 31)
+# define LCD_POWER_ON	(1)
+#endif
+/* Please let these 2 lines here
+*/
+
+#if defined(CONFIG_FB_MXC) || defined(CONFIG_FB_IMX)
+static int mxc_lcd_pins[] = {
+	PA5_PF_LSCLK,
+	PA6_PF_LD0,
+	PA7_PF_LD1,
+	PA8_PF_LD2,
+	PA9_PF_LD3,
+	PA10_PF_LD4,
+	PA11_PF_LD5,
+	PA12_PF_LD6,
+	PA13_PF_LD7,
+	PA14_PF_LD8,
+	PA15_PF_LD9,
+	PA16_PF_LD10,
+	PA17_PF_LD11,
+	PA18_PF_LD12,
+	PA19_PF_LD13,
+	PA20_PF_LD14,
+	PA21_PF_LD15,
+	PA22_PF_LD16,
+	PA23_PF_LD17,
+	PA24_PF_REV,
+	PA25_PF_CLS,
+#ifdef LCD_USES_PS_AS_GPIO
+	(GPIO_PORTA | 26 | GPIO_OUT| GPIO_GPIO),
+#else
+	PA26_PF_PS,
+#endif
+	PA27_PF_SPL_SPR,
+	PA28_PF_HSYNC,
+	PA29_PF_VSYNC,
+#ifdef LCD_USES_CONTRAST_AS_GPIO
+	(GPIO_PORTA | 30 | GPIO_OUT| GPIO_GPIO),
+#else
+	PA30_PF_CONTRAST,
+#endif
+#ifdef LCD_USES_OE_ACD_AS_GPIO
+	(GPIO_PORTA | 31 | GPIO_OUT| GPIO_GPIO)
+#else
+	PA31_PF_OE_ACD
+#endif
+};
+
+static int apf27_fb_init(struct platform_device *pdev)
+{
+#ifdef CONFIG_FB_MXC
+# ifdef LCD_POWER_GPIO
+	/* activates LCD power at startup */
+	gpio_set_value(LCD_POWER_GPIO, LCD_POWER_ON);
+# endif
+# ifdef LCD_BACKLIGHT_GPIO
+	/* activates backlight at startup */
+	gpio_set_value(LCD_BACKLIGHT_GPIO, LCD_BACKLIGHT_ON);
+# endif
+#endif
+
+	return mxc_gpio_setup_multiple_pins(mxc_lcd_pins, ARRAY_SIZE(mxc_lcd_pins), "LCD");
+}
+
+static int apf27_fb_exit(struct platform_device *pdev)
+{
+	mxc_gpio_release_multiple_pins(mxc_lcd_pins, ARRAY_SIZE(mxc_lcd_pins));
+
+	return 0;
+}
+
+/* Freescale driver */
+#ifdef CONFIG_FB_MXC
+static struct mxc_fb_platform_data apf27_fb_data = {
+	.mode = LCD_NAME,
+	.init = apf27_fb_init,
+	.exit = apf27_fb_exit,
+};
+#endif
+
+/* Mainline driver */
+#ifdef CONFIG_FB_IMX
+#include "../mach-imx/apf9328_lcd_config.h"
+#endif
+
+# ifdef CONFIG_IMX_BACKLIGHT
+static struct imxbl_machinfo imx_bl_machinfo = {
+	.max_intensity      = 0xff,
+	.default_intensity  = 0x90,
+	.limit_mask         = 0x7f, /* when battery is low */
+	/* set_bl_intensity = put a function here if you want to overload default one, */
+};
+
+static struct platform_device imxbl_device = {
+	.name       = "imx-bl",
+	.dev        = {
+		/* .parent = &imxfb_device.dev, crash kernel even if EXPORT_SYMBOL() is done in generic.c */
+		.platform_data  = &imx_bl_machinfo,
+	},
+	.id        = 0,
+};
+# endif /* CONFIG_IMX_BACKLIGHT */
+
+#endif /* CONFIG_FB_MXC || CONFIG_FB_IMX */
+
+
+#ifdef CONFIG_IMX_BACKLIGHT
+static struct platform_device *platform_devices[] __initdata = {
+	&imxbl_device,
+};
+#endif
+
+void apf27_lcd_startup(void)
+{
+	int i;
+
+	/* force LCD data/control lines to 0 before powering the LCD
+	otherwise start up conditions may not be respected */
+	for (i = 5; i <=  31; i++) {
+		if (i != 30) {
+			gpio_set_value(GPIO_PORTA | i, 0);
+			mxc_gpio_mode(GPIO_PORTA | i | GPIO_OUT| GPIO_GPIO);
+		}
+	}
+	/* wait a few milli */
+	mdelay(100);
+}
+
+void apf27_lcd_init(void)
+{
+#ifdef CONFIG_IMX_BACKLIGHT
+	platform_add_devices(platform_devices, ARRAY_SIZE(platform_devices));
+#endif
+#if defined(CONFIG_FB_MXC) || defined(CONFIG_FB_IMX)
+	mxc_register_device(&mxc_fb_device, &apf27_fb_data);
+#endif
+}
+
Index: linux-2.6.29.6/arch/arm/mach-mx2/apf27-dev-ext-apw.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.6/arch/arm/mach-mx2/apf27-dev-ext-apw.c	2014-01-22 16:39:52.332884647 +0100
@@ -0,0 +1,190 @@
+ /*
+ * apf27-dev-ext-apw.c
+ * Support for AFP27Dev's wireless extension board (APW).
+ *
+ * Copyright (C) 2009-2010 Armadeus Systems
+ * Authors: Julien Boibessot <julien.boibessot@armadeus.com>
+ *          Nicolas Colombain <nicolas.colombain@armadeus.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <mach/common.h>
+#include <mach/iomux-mx1-mx2.h>
+#include <mach/gpio.h>
+#include <mach/mmc.h>
+#include "devices.h"
+
+
+/* An optional GSM module can be added to wireless extension board */
+#ifdef CONFIG_MACH_APF27_DEV_EXT_WIRELESS_GSM
+
+#define GSM_POK_IN	(GPIO_PORTE | 11)	/* UART3_RTS */
+
+static int apw_gsm_pins[] = {
+	(GSM_POK_IN | GPIO_OUT | GPIO_GPIO) /* GSM_PWR_ON_not */
+};
+
+static int apw_gsm_init(void)
+{
+	int res = mxc_gpio_setup_multiple_pins(apw_gsm_pins,
+			ARRAY_SIZE(apw_gsm_pins), "GSM");
+	gpio_set_value(GSM_POK_IN, 0); /* start GSM */
+	mdelay(5000);
+	gpio_set_value(GSM_POK_IN, 1); /* start GSM */
+
+	return res;
+}
+#if 0
+static int apw_gsm_exit(void)
+{
+	mxc_gpio_release_multiple_pins(apw_gsm_pins, ARRAY_SIZE(apw_gsm_pins));
+
+	return 0;
+}
+#endif
+#endif /* CONFIG_MACH_APF27_DEV_EXT_WIRELESS_GSM */
+
+
+/* An optionnal GPS module can be mounted on wireless extension board */
+#ifdef CONFIG_MACH_APF27_DEV_EXT_WIRELESS_GPS
+
+#define GPS_WAKEUP	(GPIO_PORTB | 20)	/* CSI_VSYNC_UART5_CTS */
+#define GPS_TIMEPULSE	(GPIO_PORTB | 21)	/* CSI_HSYNC_UART5_RTS */
+
+static int apw_gps_pins[] = {
+	(GPS_WAKEUP | GPIO_OUT | GPIO_GPIO),
+	(GPS_TIMEPULSE | GPIO_IN | GPIO_GPIO),
+};
+
+static int apw_gps_init(void)
+{
+	int res = mxc_gpio_setup_multiple_pins(apw_gps_pins,
+			ARRAY_SIZE(apw_gps_pins), "GPS");
+	gpio_set_value(GPS_WAKEUP, 1); /* start GPS */
+
+	return res;
+}
+#if 0
+static int apw_gps_exit(void)
+{
+	mxc_gpio_release_multiple_pins(apw_gps_pins, ARRAY_SIZE(apw_gps_pins));
+
+	return 0;
+}
+#endif
+#endif /* CONFIG_MACH_APF27_DEV_EXT_WIRELESS_GPS */
+
+
+/* An optional Bluetooth + WiFi module (Wi2Wi) can be mounted on wireless
+   extension board */
+#ifdef CONFIG_MACH_APF27_DEV_EXT_WIRELESS_BT_WIFI
+
+#define BT_RESETn	(GPIO_PORTB | 14)	/* shared with CSI_D4;
+						   driven by userspace */
+#define WIFI_PWRDNn	(GPIO_PORTE | 10)	/* UART3_CTS */
+
+static int apw_bt_wifi_pins[] = {
+	(WIFI_PWRDNn | GPIO_OUT | GPIO_GPIO),
+};
+
+/* SDHC1 is used for WiFi */
+static int mxc_sdhc1_pins[] = {
+	PE18_PF_SDHC1_D0,
+	PE19_PF_SDHC1_D1,
+	PE20_PF_SDHC1_D2,
+	PE21_PF_SDHC1_D3,
+	PE22_PF_SDHC1_CMD,
+	PE22_PF_SDHC1_CLK,
+};
+
+static int apw_sdhc1_init(struct device *dev, irq_handler_t handler, void *data)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_sdhc1_pins,
+				ARRAY_SIZE(mxc_sdhc1_pins),
+				"SDHC1");
+}
+
+static void apw_sdhc1_exit(struct device *pdev, void *data)
+{
+	mxc_gpio_release_multiple_pins(mxc_sdhc1_pins, ARRAY_SIZE(mxc_sdhc1_pins));
+}
+
+static struct imxmmc_platform_data apw_sdhc1_pdata = {
+	.init = apw_sdhc1_init,
+	.exit = apw_sdhc1_exit,
+};
+
+/* UART6 is used for Bluetooth (init done in apf27-dev.c depending on
+   Linux config) */
+
+static int apw_bt_wifi_init(void)
+{
+	int res;
+
+	gpio_set_value(WIFI_PWRDNn, 1);	/* WiFi on */
+	res = mxc_gpio_setup_multiple_pins(apw_bt_wifi_pins,
+			ARRAY_SIZE(apw_bt_wifi_pins), "BT_WIFI");
+	if (!res)
+		mxc_register_device(&mxc_sdhc_device0, &apw_sdhc1_pdata);
+
+	return res;
+}
+#endif /* CONFIG_MACH_APF27_DEV_EXT_WIRELESS_BT_WIFI */
+
+
+void apf27dev_extension_resume(void)
+{
+#ifdef CONFIG_PM
+# ifdef CONFIG_MACH_APF27_DEV_EXT_WIRELESS_WIFI
+	gpio_set_value(WIFI_PWRDNn, 1);
+# endif
+# ifdef CONFIG_MACH_APF27_DEV_EXT_WIRELESS_GPS
+	gpio_set_value(GPS_WAKEUP, 1);
+# endif
+#endif
+}
+
+void apf27dev_extension_suspend(void)
+{
+#ifdef CONFIG_PM
+# ifdef CONFIG_MACH_APF27_DEV_EXT_WIRELESS_WIFI
+	gpio_set_value(WIFI_PWRDNn, 0);
+# endif
+# ifdef CONFIG_MACH_APF27_DEV_EXT_WIRELESS_GPS
+	gpio_set_value(GPS_WAKEUP, 0);
+# endif
+#endif
+}
+
+
+void __init apf27dev_extension_init(void)
+{
+	printk("    Registering APW ressources:");
+
+#ifdef CONFIG_MACH_APF27_DEV_EXT_WIRELESS_GSM
+	apw_gsm_init();
+#endif
+#ifdef CONFIG_MACH_APF27_DEV_EXT_WIRELESS_GPS
+	apw_gps_init();
+#endif
+#ifdef CONFIG_MACH_APF27_DEV_EXT_WIRELESS_BT_WIFI
+	apw_bt_wifi_init();
+#endif
+
+	printk("done\n");
+}
+
