Index: linux-2.6.29.6/sound/arm/imx-alsa.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.6/sound/arm/imx-alsa.c	2010-03-25 12:28:12.000000000 +0100
@@ -0,0 +1,666 @@
+/*
+ * sound/arm/imx-alsa.c
+ *
+ * Alsa Driver for i.MX1/i.MX2 SSI
+ *
+ * Copyright (C) 2008 Armadeus Systems <nicolas.colombain@armadeus.com>
+ *                                     <julien.boibessot@armadeus.com>
+ * Based on omap-alsa.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#define DEBUG
+
+#include <linux/platform_device.h>
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+
+#include <mach/imx-alsa.h>
+#include <linux/dma-mapping.h>
+
+#ifdef CONFIG_ARCH_MX2
+#include <mach/dma-mx1-mx2.h>
+#include <mach/imx_sound.h>
+#include "imx2-dam.h"
+#else
+#include <mach/imx-dma.h>
+#endif
+#include "imx-ssi.h"
+
+#include "devdma.h"
+
+#define DRIVER_NAME	"imx-pcm"
+#define DRIVER_VERSION	"0.4"
+#define TSC_MASTER
+
+
+MODULE_AUTHOR("Nicolas Colombain / Julien Boibessot - Armadeus Systems");
+MODULE_DESCRIPTION("i.MX1/L/2 PCM driver for ALSA");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:imx-pcm");
+
+static struct snd_card_imx_codec 	*alsa_codec		= NULL;
+static struct imx_alsa_codec_config	*alsa_codec_config	= NULL;
+
+
+/* Called by the DMA framework when a period has elapsed */
+static void snd_imx_dma_progression(int channel, void *data,
+					struct scatterlist *sg)
+{
+	struct audio_stream *s = data;
+	struct snd_pcm_substream *substream = s->stream;
+	struct snd_pcm_runtime *runtime;
+
+	runtime = substream->runtime;
+
+	pr_debug("DMA ");
+	if (sg) {
+/*		channel_info->offset = (unsigned long)sg->dma_address -
+					(unsigned long)channel_info->base;*/
+		s->periods++;
+		s->periods %= runtime->periods;
+		snd_pcm_period_elapsed(substream);
+	}
+}
+
+/* Called when the DMA unit has finished the buffer.
+ * It should not happen, but whith a playback or capturing
+ * size of 2^32 bytes it will happen!
+ */
+static void snd_imx_dma_callback(int channel, void *data)
+{
+	struct audio_stream *s = data;
+	struct snd_pcm_substream *substream = s->stream;
+
+	pr_err("%s shouldn't be called\n", __func__);
+
+	/* report period's end */
+	snd_pcm_period_elapsed(substream);
+}
+
+/* Called by the DMA framework when an error has occured */
+static void snd_imx_dma_err_handler(int channel, void *data, int err)
+{
+	pr_debug("%s %d %d\n", __func__, channel, err);
+
+	printk("DMA timeout on channel %d -%s%s%s%s%s\n",
+		 channel,
+		 err & IMX_DMA_ERR_BURST ?    " burst":"",
+		 err & IMX_DMA_ERR_REQUEST ?  " request":"",
+		 err & IMX_DMA_ERR_TRANSFER ? " transfer":"",
+		 err & IMX_DMA_ERR_BUFFER ?   " buffer":"",
+		 err & IMX_DMA_ERR_TIMEOUT ?  " hw_chain_watchdog":"");
+
+	imx_dma_disable(channel);
+}
+
+/* configure DMA channel of a given substream */
+static int snd_imx_dma_request(struct audio_stream *s)
+{
+	int err=0, chan=0;
+
+	chan = imx_dma_request_by_prio(DRIVER_NAME, DMA_PRIO_HIGH);
+	if (chan < 0) {
+		printk(KERN_ERR "Unable to grab a DMA channel\n");
+		err = chan;
+		goto on_error_1;
+	}
+	s->dma_dev = chan;
+
+	err = imx_dma_setup_handlers(s->dma_dev,
+					snd_imx_dma_callback,
+					snd_imx_dma_err_handler, s);
+	if (err < 0) {
+		printk(KERN_ERR "Unable to setup DMA handler for channel %d\n", s->dma_dev);
+		err = -EIO;
+		goto on_error_2;
+	}
+
+	err = imx_dma_setup_progression_handler(s->dma_dev,
+						snd_imx_dma_progression);
+	if (err != 0) {
+		pr_err("Failed to setup the DMA handler\n");
+		err = -EIO;
+		goto on_error_2;
+	}
+
+	pr_debug("snd_imx_dma_request done (%d)\n", s->dma_dev);
+	imx_dma_disable(s->dma_dev);
+
+	return 0;
+
+on_error_2:
+	imx_dma_free(s->dma_dev);
+on_error_1:
+	return err;
+}
+
+/*
+ *  This function should calculate the current position of the dma in the
+ *  buffer. It will help alsa middle layer to continue update the buffer.
+ *  Its correctness is crucial for good functioning.
+ */
+static u_int audio_get_dma_pos(struct audio_stream *s)
+{
+	struct snd_pcm_substream *substream = s->stream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int offset;
+	unsigned long flags;
+
+	/* this must be called w/ interrupts locked as requested in dma.c */
+	spin_lock_irqsave(&s->dma_lock, flags);
+
+	/* For the current period let's see where we are */
+	spin_unlock_irqrestore(&s->dma_lock, flags);
+
+	/* Now, the position related to the end of that period */
+// 	offset = bytes_to_frames(runtime, s->offset) + (runtime->period_size >> 1); //bytes_to_frames(runtime, count);
+	if (s->dma_in_progress) {
+		offset = (runtime->period_size * (s->periods)) + (runtime->period_size >> 1);
+		if (offset >= runtime->buffer_size)
+			offset = runtime->period_size >> 1;
+	} else {
+		offset = (runtime->period_size * (s->periods));
+		if (offset >= runtime->buffer_size)
+			offset = 0;
+	}
+/*	pr_debug("%s: Period=%d/%d Off=%d psize=%d bsize=%d (%d)\n", __func__,
+		s->periods, runtime->periods, offset, runtime->period_size,
+		runtime->buffer_size, bytes_to_frames(runtime, s->offset)); */
+
+	return offset;
+}
+
+/*
+ * Alsa section
+ * PCM settings and callbacks
+ */
+static int snd_imx_alsa_trigger(struct snd_pcm_substream * substream, int cmd)
+{
+	struct snd_card_imx_codec *chip = snd_pcm_substream_chip(substream);
+	int stream_id = substream->pstr->stream;
+	struct audio_stream *s = &chip->s[stream_id];
+
+	pr_debug("%s called: ", __func__);
+
+	/* note: local interrupts are already disabled in the midlevel code */
+	spin_lock(&s->dma_lock);
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+			pr_debug("START\n");
+			imx_dma_enable(s->dma_dev);
+			break;
+
+		case SNDRV_PCM_TRIGGER_STOP:
+			pr_debug("STOP\n");
+			imx_dma_disable(s->dma_dev);
+			break;
+
+		default:
+			printk("ALSA trigger 0x%x not supported (yet?)\n", cmd);
+			return -EINVAL;
+			break;
+	}
+	spin_unlock(&s->dma_lock);
+
+	/* SSI activation done here */
+	return imx_ssi_trigger(substream, cmd, /*channel_info->ssi*/0);
+}
+
+static int snd_imx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_card_imx_codec *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct audio_stream *channel_info = &chip->s[substream->pstr->stream];
+// 	int stream_id = substream->pstr->stream;
+	unsigned int dma_chan = channel_info->dma_dev;
+	int err = -EINVAL;
+	void __iomem *fifo_io;
+
+	pr_debug("%s called\n", __func__);
+
+	/* set requested samplerate */
+	alsa_codec_config->codec_set_samplerate(runtime->rate);
+	chip->samplerate = runtime->rate;
+
+	channel_info->period = 0;
+	channel_info->periods = 0;
+
+#ifdef TSC_MASTER
+	imx_ssi_setup_unit_to_iis_slave(0);
+#else
+	imx_ssi_setup_unit_to_iis_master(0);
+#endif
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		fifo_io = imx_ssi_get_dma_tx_address(/*channel_info->ssi*/0, 0);
+		err = imx_dma_setup_sg(dma_chan, channel_info->sg_list,
+				       channel_info->sg_count,
+				       -1, /* TODO largest possible size */
+				       (unsigned int)fifo_io,
+				       DMA_MODE_WRITE);
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		fifo_io = imx_ssi_get_dma_rx_address(/*channel_info->ssi*/0, 0);
+		err = imx_dma_setup_sg(dma_chan, channel_info->sg_list,
+				       channel_info->sg_count,
+				       -1, /* TODO largest possible size */
+				       (unsigned int)fifo_io,
+				       DMA_MODE_READ);
+	}
+	if (err < 0) {
+		pr_err("Can't setup scatter/gather DMA\n");
+		return err;
+	}
+
+	imx_ssi_prepare(substream, /*channel_info->ssi*/0);
+
+	return 0;
+}
+
+static snd_pcm_uframes_t snd_imx_alsa_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_card_imx_codec *chip = snd_pcm_substream_chip(substream);
+
+	return audio_get_dma_pos(&chip->s[substream->pstr->stream]);
+}
+
+static int snd_imx_pcm_open(struct snd_pcm_substream * substream)
+{
+	struct snd_card_imx_codec *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int stream_id = substream->pstr->stream;
+	int err, dma_req;
+	char *type;
+	unsigned int burstlen;
+
+	type = (stream_id == SNDRV_PCM_STREAM_PLAYBACK ? "Playback" : "Capture");
+	pr_debug("%s %s stream @: 0x%x\n", __func__, type, (unsigned int)substream);
+
+	chip->s[stream_id].stream = substream;
+	alsa_codec_config->codec_clock_on();
+	if (stream_id == SNDRV_PCM_STREAM_PLAYBACK) {
+		runtime->hw = *(alsa_codec_config->snd_imx_alsa_playback);
+		burstlen = SSI_TXFIFO_WM * 2; /* TODO: what if samples != 16 bits ? */
+		dma_req = imx_ssi_get_dma_tx_channel(0, 0);
+		pr_debug("imx_ssi_get_dma_tx_channel = %d\n", dma_req);
+		if (dma_req < 0)
+			return dma_req;
+	} else {
+		runtime->hw = *(alsa_codec_config->snd_imx_alsa_capture);
+		burstlen = SSI_RXFIFO_WM * 2; /* TODO: what if samples != 16 bits ? */
+		dma_req = imx_ssi_get_dma_rx_channel(0, 0);
+		pr_debug("imx_ssi_get_dma_rx_channel = %d\n", dma_req);
+		if (dma_req < 0)
+			return dma_req;
+	}
+	if ((err = snd_pcm_hw_constraint_integer(runtime,
+					   SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+
+	if ((err = snd_pcm_hw_constraint_list(runtime,
+					0,
+					SNDRV_PCM_HW_PARAM_RATE,
+					alsa_codec_config->hw_constraints_rates)) < 0)
+		return err;
+
+	/* request DMA channel */
+	err = snd_imx_dma_request(&chip->s[stream_id]);
+	if (err < 0)
+		return err;
+
+	/* configure i.MX DMA control register for given channel */
+	err = imx_dma_config_channel(chip->s[stream_id].dma_dev,
+				IMX_DMA_MEMSIZE_16 | IMX_DMA_TYPE_FIFO,
+				IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
+				dma_req, 1);
+	if (err < 0) {
+		printk("Cannot configure DMA for %s channel\n", type);
+	}
+
+	/* configure DMA burst length for channel */
+	imx_dma_config_burstlen(chip->s[stream_id].dma_dev, burstlen);
+	pr_debug("Burstlen for DMA channel %u is now: %u\n", chip->s[stream_id].dma_dev, burstlen);
+
+#ifdef CONFIG_ARCH_MX2
+	/* route sound paths */
+	mx2_dam_configure_sync_slave(1, 1);
+#endif
+
+	return 0;
+}
+
+static int snd_imx_pcm_close(struct snd_pcm_substream * substream)
+{
+	struct snd_card_imx_codec *chip = snd_pcm_substream_chip(substream);
+	int stream_id = substream->pstr->stream;
+	struct audio_stream *channel_info = &chip->s[substream->pstr->stream];
+
+	ADEBUG();
+
+	imx_dma_disable(chip->s[stream_id].dma_dev);
+	imx_dma_free(chip->s[stream_id].dma_dev);
+
+	alsa_codec_config->codec_clock_off();
+
+	if (channel_info->sg_list != NULL)
+		kfree(channel_info->sg_list);
+
+	chip->s[substream->pstr->stream].stream = NULL;
+
+	return 0;
+}
+
+/* HW params & free */
+static int snd_imx_pcm_hw_params(struct snd_pcm_substream * substream,
+				   struct snd_pcm_hw_params * hw_params)
+{
+	struct snd_card_imx_codec *chip = snd_pcm_substream_chip(substream);
+	struct audio_stream *channel_info = &chip->s[substream->pstr->stream];
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned char *dma_adr;
+	int err = -EINVAL, i;
+
+	pr_debug("%s called\n", __func__);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		err = devdma_hw_alloc(chip->card->dev, substream,
+					params_buffer_bytes(hw_params));
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		err = devdma_hw_alloc(chip->card->dev, substream,
+					params_buffer_bytes(hw_params));
+	if (err < 0)
+		return err;
+
+	pr_debug("DMA area: 0x%p, addr: 0x%p, size: %u\n",
+		runtime->dma_area, (void*)runtime->dma_addr, runtime->dma_bytes);
+
+	/* channel_info->base = (void*)runtime->dma_addr; ?? why isn't it already done ?? */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		channel_info->base = (void*)dma_map_single(NULL,
+						(void*)runtime->dma_area,
+						runtime->dma_bytes,
+						DMA_TO_DEVICE);
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		channel_info->base = (void*)dma_map_single(NULL,
+						(void*)runtime->dma_area,
+						runtime->dma_bytes,
+						DMA_FROM_DEVICE);
+	}
+	pr_debug("DMA phys: 0x%p\n", channel_info->base);
+	channel_info->adr = runtime->dma_area ;
+	channel_info->offset = 0;
+	channel_info->size = params_buffer_bytes(hw_params);
+	channel_info->periods = params_periods(hw_params);
+	channel_info->period = params_period_bytes(hw_params);
+
+	pr_debug("Size: %d periods: %d period_size: %d\n", channel_info->size, channel_info->periods, channel_info->period);
+	dma_adr = channel_info->base;
+
+	if (channel_info->sg_count != channel_info->periods) {
+		if (channel_info->sg_list)
+			kfree(channel_info->sg_list);
+		/* using sg_alloc_table() instead? */
+		channel_info->sg_list = kcalloc(channel_info->periods + 1,
+				sizeof(struct scatterlist), GFP_KERNEL);
+		pr_debug("Allocating scatter/gather list with %d+1 entries\n",
+				channel_info->periods);
+		if (!channel_info->sg_list)
+			return -ENOMEM;
+		channel_info->sg_count = channel_info->periods + 1;
+	} else
+		pr_debug("Reuse previous scatter/gather memory\n");
+
+	sg_init_table(channel_info->sg_list, channel_info->sg_count);
+
+	for (i = 0; i < channel_info->periods; i++) {
+		channel_info->sg_list[i].page_link = 0;
+		channel_info->sg_list[i].offset = 0;	/* FIXME */
+		channel_info->sg_list[i].dma_address = (dma_addr_t)dma_adr;
+		channel_info->sg_list[i].length = channel_info->period;
+
+		dma_adr += channel_info->period;
+	}
+
+	/* close the loop */
+	sg_chain(channel_info->sg_list, channel_info->sg_count, channel_info->sg_list);
+
+	pr_debug("Activating %d periods with %d bytes each\n",
+			channel_info->periods, channel_info->period);
+
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+static int snd_imx_pcm_hw_free(struct snd_pcm_substream * substream)
+{
+	struct snd_card_imx_codec *chip = snd_pcm_substream_chip(substream);
+	struct audio_stream *channel_info = &chip->s[substream->pstr->stream];
+// 	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	pr_debug("%s called\n", __func__);
+
+	if (channel_info->sg_list != NULL) {
+		kfree(channel_info->sg_list);
+		channel_info->sg_list = NULL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		devdma_hw_free(chip->card->dev, substream);
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		devdma_hw_free(chip->card->dev, substream);
+
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/* pcm operations */
+static struct snd_pcm_ops snd_card_imx_ops = {
+	.open =		snd_imx_pcm_open,
+	.close =	snd_imx_pcm_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_imx_pcm_hw_params,
+	.hw_free =	snd_imx_pcm_hw_free,
+	.prepare =	snd_imx_pcm_prepare,
+	.trigger =	snd_imx_alsa_trigger,
+	.pointer =	snd_imx_alsa_pointer,
+};
+
+/*
+ *  Alsa init and exit section
+ *
+ *  Inits pcm alsa structures, allocate the alsa buffer, suspend, resume
+ */
+#define CHIP_NAME "i.MX SSI"
+static int __init snd_imx_new_pcm(struct snd_card_imx_codec *imx_alsa,
+					int device)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	err = snd_pcm_new(imx_alsa->card,
+			  CHIP_NAME,
+			  device,
+			  1,	/* one playback stream */
+			  1,	/* one capture stream */
+			  &pcm);
+
+	if (err < 0)
+		return err;
+
+	/* sets up initial buffer with continuous allocation */
+	snd_pcm_lib_preallocate_pages_for_all(pcm,
+				SNDRV_DMA_TYPE_CONTINUOUS,
+				snd_dma_continuous_data(GFP_KERNEL),
+				32 * 1024,
+				32 * 1024);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_card_imx_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_card_imx_ops);
+	pcm->private_data = imx_alsa;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, CHIP_NAME);
+
+	imx_alsa->pcm = pcm;
+
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+int snd_imx_alsa_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_card_imx_codec *chip;
+	struct snd_card *card = platform_get_drvdata(pdev);
+
+	if (card->power_state != SNDRV_CTL_POWER_D3hot) {
+		chip = card->private_data;
+		if (chip->card->power_state != SNDRV_CTL_POWER_D3hot) {
+			snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
+			snd_pcm_suspend_all(chip->pcm);
+			/* Mutes and turn clock off */
+			alsa_codec_config->codec_clock_off();
+			snd_tsc210x_suspend_mixer();
+		}
+	}
+
+	return 0;
+}
+
+int snd_imx_alsa_resume(struct platform_device *pdev)
+{
+	struct snd_card_imx_codec *chip;
+	struct snd_card *card = platform_get_drvdata(pdev);
+
+	if (card->power_state != SNDRV_CTL_POWER_D0) {
+		chip = card->private_data;
+		if (chip->card->power_state != SNDRV_CTL_POWER_D0) {
+			snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
+			alsa_codec_config->codec_clock_on();
+			snd_tsc210x_resume_mixer();
+		}
+	}
+
+	return 0;
+}
+#endif	/* CONFIG_PM */
+
+
+/*
+ * Inits alsa soundcard structure.
+ * Called by the probe method in codec after function pointers has been set.
+ */
+int snd_imx_alsa_post_probe(struct platform_device *pdev, struct imx_alsa_codec_config *config)
+{
+	int err = 0;
+	struct snd_card *card;
+	struct imx_sound_platform_data *pdata;
+
+	pr_debug("%s\n", __func__);
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL) {
+		pr_err("No platform data available. Giving up\n");
+		err = -ENODEV;
+		goto nodev1;
+	}
+
+	alsa_codec_config = config;
+	if (alsa_codec_config == NULL) {
+		pr_err("No config data available. Giving up\n");
+		err = -ENODEV;
+		goto nodev1;
+	}
+	alsa_codec_config->codec_clock_setup();
+	alsa_codec_config->codec_clock_on();
+
+	if (alsa_codec_config->codec_configure_dev)
+		alsa_codec_config->codec_configure_dev();
+
+	alsa_codec_config->codec_clock_off();
+
+	/* instantiate a new soundcard */
+	card = snd_card_new(-1, "IMX-ALSA", THIS_MODULE, sizeof(*alsa_codec));
+	if (card == NULL)
+		goto nodev1;
+	alsa_codec = card->private_data;
+	alsa_codec->card = card;
+
+	alsa_codec->samplerate = alsa_codec_config->get_default_samplerate();
+	spin_lock_init(&alsa_codec->s[0].dma_lock);
+	spin_lock_init(&alsa_codec->s[1].dma_lock);
+
+	/* add it a mixer */
+	if ((err = snd_imx_mixer(alsa_codec)) < 0)
+		goto nodev2;
+
+	/* add it a PCM interface */
+	if ((err = snd_imx_new_pcm(alsa_codec, 0)) < 0)
+		goto nodev2;
+
+	strcpy(card->driver, "i.MX");
+	sprintf(card->shortname, "i.MX+%s audio", alsa_codec_config->name);
+	sprintf(card->longname, "Freescale i.MX with %s codec", alsa_codec_config->name);
+
+	snd_card_set_dev(card, &pdev->dev);
+
+	/* register the created soundcard */
+	err = snd_card_register(card);
+	if (err < 0) {
+		pr_err("Cannot register sound card. Giving up\n");
+		goto nodev2;
+	}
+
+	pr_info("i.MX1/L/2 audio support v" DRIVER_VERSION " initialized\n");
+	platform_set_drvdata(pdev, card);
+
+	/* activate the external SSI pins (should be done in imx-ssi !?) */
+	if (pdata->init)
+		pdata->init(pdev);
+
+	return 0;
+
+nodev2:
+	snd_card_free(card);
+nodev1:
+	return err;
+}
+
+int snd_imx_alsa_remove(struct platform_device *pdev)
+{
+	struct snd_card *card = platform_get_drvdata(pdev);
+	struct snd_card_imx_codec *chip = card->private_data;
+
+	snd_card_free(card);
+
+	alsa_codec = NULL;
+	card->private_data = NULL;
+	kfree(chip);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
Index: linux-2.6.29.6/sound/arm/imx-alsa-dma.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.6/sound/arm/imx-alsa-dma.h	2010-03-25 12:28:12.000000000 +0100
@@ -0,0 +1,46 @@
+/*
+ * linux/sound/arm/imx/imx-alsa-dma.h
+ *
+ * Common audio DMA handling for the iMX processors
+ *
+ * Copyright (C) 2008 Nicolas Colombain <nicolas.colombain@armadeus.com>
+ * Copyright (C) 2006 Mika Laitio <lamikr@cc.jyu.fi>
+ * Copyright (C) 2005 Instituto Nokia de Tecnologia - INdT - Manaus Brazil
+ * Copyright (C) 2004 Texas Instruments, Inc.
+ * Copyright (C) 2000, 2001 Nicolas Pitre <nico@cam.org>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+
+#ifndef __IMX_AUDIO_ALSA_DMA_H
+#define __IMX_AUDIO_ALSA_DMA_H
+
+/************************** INCLUDES *************************************/
+
+#include <asm/arch/imx-alsa.h>
+
+/************************** GLOBAL DATA STRUCTURES *********************************/
+
+typedef void (*dma_callback_t) (int lch, u16 ch_status, void *data);
+
+/**************** ARCH SPECIFIC FUNCIONS *******************************************/
+
+void imx_clear_alsa_sound_dma(struct audio_stream * s);
+
+/*int imx_request_alsa_sound_dma(int device_id, const char *device_name,
+			   void *data, int **channels);*/
+//int imx_free_alsa_sound_dma(void *data, int **channels);
+
+int imx_start_alsa_sound_dma(struct audio_stream *s, dma_addr_t dma_ptr,  u_int dma_size);
+
+void imx_stop_alsa_sound_dma(struct audio_stream *s);
+
+#endif
+
Index: linux-2.6.29.6/sound/arm/imx-alsa-tsc2102.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.6/sound/arm/imx-alsa-tsc2102.c	2010-03-29 15:33:48.000000000 +0200
@@ -0,0 +1,441 @@
+/*
+ * sound/arm/imx-alsa-tsc2102.c
+ *
+ * Alsa codec driver for TSC210x chip on i.MX platforms.
+ *
+ * Copyright (c) 2008 Jorasse  <jorasse@armadeus.com>
+ * Code based on the TSC2101 ALSA driver for omap platforms.
+ * Copyright (c) 2006 Andrzej Zaborowski  <balrog@zabor.org>
+ * Code based on the TSC2101 ALSA driver.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/soundcard.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#ifdef CONFIG_PM
+# include <linux/pm.h>
+#endif
+#include <linux/spi/tsc2102.h>
+#ifdef CONFIG_DEBUG_FS
+# include <linux/debugfs.h>
+# include <linux/seq_file.h>
+#endif
+
+#include <mach/hardware.h>
+#include <mach/imx-alsa.h>
+
+#include "imx-alsa-tsc2102.h"
+
+static struct clk *tsc2102_bclk = 0;
+
+/*
+ * Hardware capabilities
+ */
+
+/* DAC sampling rates (BCLK = 12 MHz) */
+static unsigned int rates[] = {
+	7350, 8000, 8820, 9600, 11025, 12000, 14700,
+	16000, 22050, 24000, 29400, 32000, 44100, 48000,
+};
+
+static struct snd_pcm_hw_constraint_list tsc2102_hw_constraints_rates = {
+	.count = ARRAY_SIZE(rates),
+	.list = rates,
+	.mask = 0,
+};
+
+#define IMX_SSI_RATES \
+		(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
+		SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
+		SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+		SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_KNOT)
+
+static struct snd_pcm_hardware tsc210x_snd_imx_alsa_playback = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED |
+					SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP |
+					SNDRV_PCM_INFO_MMAP_VALID,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= IMX_SSI_RATES,
+	.rate_min		= 8000,
+	.rate_max		= 48000,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 32 * 1024,
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 8 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 255,
+	.fifo_size		= 0,
+};
+
+/* Only TSC2101 has (mono) audio in capability */
+static struct snd_pcm_hardware tsc2101_snd_imx_alsa_capture = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED |
+					SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP |
+					SNDRV_PCM_INFO_MMAP_VALID,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= IMX_SSI_RATES,
+	.rate_min		= 8000,
+	.rate_max		= 48000,
+	.channels_min		= 2,	/* even if TSC is sampling mono input, it uses the 2 I2S channels to transmit data */
+	.channels_max		= 2,
+	.buffer_bytes_max	= 32 * 1024,
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 8 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 255,
+	.fifo_size		= 0,
+};
+
+/*
+ * ALSA operations according to board file
+ */
+
+static long current_rate = 0;
+
+/*
+ * Sample rate changing
+ */
+static void tsc2102_set_samplerate(long sample_rate)
+{
+	pr_debug("%s %li\n", __func__, sample_rate);
+
+#ifndef TSC_MASTER
+	int clkgdv = 0;
+	u16 srgr1, srgr2;
+#endif
+
+	if (sample_rate == current_rate)
+		return;
+	current_rate = 0;
+
+#if 0
+	/* Wait for any frames to complete */
+	udelay(125);
+#endif
+	/* Set the sample rate on the TSC */
+	if (tsc210x_set_rate(sample_rate)) {
+		printk("error setting TSC at %u Hz sample rate\n", (unsigned int)sample_rate);
+		return;
+	}
+
+#ifdef TSC_MASTER
+
+#else
+	/* Set the sample rate on the i.MX SSI */
+	printk("erreur 1");
+	imx_get_perclk3();
+	clkgdv = CODEC_CLOCK / (sample_rate * (DEFAULT_BITPERSAMPLE * 2 - 1));
+	if (clkgdv)
+		srgr1 = (FWID(DEFAULT_BITPERSAMPLE - 1) | CLKGDV(clkgdv));
+	else
+		return;
+	xxxxx
+	/* Stereo Mode */
+	srgr2 = (CLKSM | FSGM | FPER(DEFAULT_BITPERSAMPLE * 2 - 1));
+#endif
+
+	current_rate = sample_rate;
+}
+
+static void tsc2102_configure(void)
+{
+	pr_debug("%s\n", __func__);
+
+	tsc210x_dac_power(1);
+
+#ifdef TSC_MASTER
+	tsc210x_set_i2s_master(1);
+#else
+#error "to be implemented"
+	tsc210x_set_i2s_master(0);
+#endif
+}
+
+/*
+ * Do clock framework bclk search
+ */
+static void tsc2102_clock_setup(void)
+{
+	/*tsc2102_bclk = clk_get(0, "bclk"); no clock management*/
+}
+
+/*
+ * Do some sanity checks, set clock rate, start it.
+ */
+static int tsc2102_clock_on(void)
+{
+/*	int err;
+no clock management*/
+
+#ifdef TSC_MASTER
+
+#endif
+
+/*	if (clk_get_usecount(tsc2102_bclk) > 0 &&
+			clk_get_rate(tsc2102_bclk) != CODEC_CLOCK) {
+		printk(KERN_WARNING
+			"BCLK already in use at %d Hz. We change it to %d Hz\n",
+			(uint) clk_get_rate(tsc2102_bclk), CODEC_CLOCK);
+
+		err = clk_set_rate(tsc2102_bclk, CODEC_CLOCK);
+		if (err) {
+			printk(KERN_WARNING "Cannot set BCLK clock rate "
+				"for TSC2102 codec, error code = %d\n", err);
+		}
+	}
+
+	clk_enable(tsc2102_bclk);
+no clock management*/
+
+	/* Clock disabled when SSI disabled */
+	//?? SSI_SOR |= 0x40;
+
+	return 0;
+}
+
+/*
+ * Turn off the audio codec and then stop the clock.
+ */
+static int tsc2102_clock_off(void)
+{
+	DPRINTK("clock use count = %d\n", clk_get_usecount(tsc2102_bclk));
+
+/*	clk_disable(tsc2102_bclk);
+no clock management */
+
+	/* Clock enabled when SSI disabled */
+	//?? SSI_SOR &= ~0x40;
+
+	return 0;
+}
+
+static int tsc2102_get_default_samplerate(void)
+{
+	return DEFAULT_SAMPLE_RATE;
+}
+
+
+#ifdef CONFIG_PM
+static int snd_imx_alsa_tsc2102_suspend(struct platform_device *pdev,
+			pm_message_t state)
+{
+	tsc210x_dac_power(0);
+	current_rate = 0;
+
+	return snd_imx_alsa_suspend(pdev, state);
+}
+
+static int snd_imx_alsa_tsc2102_resume(struct platform_device *pdev)
+{
+	tsc210x_dac_power(1);
+
+#ifdef TSC_MASTER
+	tsc210x_set_i2s_master(1);
+#else
+	tsc210x_set_i2s_master(0);
+#endif
+
+	return snd_imx_alsa_resume(pdev);
+}
+#endif /* CONFIG_PM */
+
+
+#ifdef CONFIG_DEBUG_FS
+static int tsc210x_debug_show(struct seq_file *s, void *unused)
+{
+	seq_printf(s, "TSC210x registers content:\n");
+
+	seq_printf(s, "TSC2102_AUDIO1_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_AUDIO1_CTRL));
+	seq_printf(s, "TSC210X_DAC_GAIN_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC210X_DAC_GAIN_CTRL));
+
+	if (tsc210x_is_tsc2101()) {
+		seq_printf(s, "TSC2101_HEADSET_AUX_PGA_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_HEADSET_AUX_PGA_CTRL));
+		seq_printf(s, "TSC2101_MIXER_PGA_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_MIXER_PGA_CTRL));
+	}
+	seq_printf(s, "TSC2102_AUDIO2_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_AUDIO2_CTRL));
+	seq_printf(s, "TSC210X_CODEC_POWER_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC210X_CODEC_POWER_CTRL));
+	seq_printf(s, "TSC2102_AUDIO3_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_AUDIO3_CTRL));
+
+	seq_printf(s, "TSC2102_LCH_BASS_BOOST_N0 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_LCH_BASS_BOOST_N0));
+	seq_printf(s, "TSC2102_LCH_BASS_BOOST_N1 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_LCH_BASS_BOOST_N1));
+	seq_printf(s, "TSC2102_LCH_BASS_BOOST_N2 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_LCH_BASS_BOOST_N2));
+	seq_printf(s, "TSC2102_LCH_BASS_BOOST_N3 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_LCH_BASS_BOOST_N3));
+	seq_printf(s, "TSC2102_LCH_BASS_BOOST_N4 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_LCH_BASS_BOOST_N4));
+	seq_printf(s, "TSC2102_LCH_BASS_BOOST_N5 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_LCH_BASS_BOOST_N5));
+	seq_printf(s, "TSC2102_LCH_BASS_BOOST_D1 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_LCH_BASS_BOOST_D1));
+	seq_printf(s, "TSC2102_LCH_BASS_BOOST_D2 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_LCH_BASS_BOOST_D2));
+	seq_printf(s, "TSC2102_LCH_BASS_BOOST_D4 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_LCH_BASS_BOOST_D4));
+	seq_printf(s, "TSC2102_LCH_BASS_BOOST_D5 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_LCH_BASS_BOOST_D5));
+	seq_printf(s, "TSC2102_RCH_BASS_BOOST_N0 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_RCH_BASS_BOOST_N0));
+	seq_printf(s, "TSC2102_RCH_BASS_BOOST_N1 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_RCH_BASS_BOOST_N1));
+	seq_printf(s, "TSC2102_RCH_BASS_BOOST_N2 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_RCH_BASS_BOOST_N2));
+	seq_printf(s, "TSC2102_RCH_BASS_BOOST_N3 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_RCH_BASS_BOOST_N3));
+	seq_printf(s, "TSC2102_RCH_BASS_BOOST_N4 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_RCH_BASS_BOOST_N4));
+	seq_printf(s, "TSC2102_RCH_BASS_BOOST_N5 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_RCH_BASS_BOOST_N5));
+	seq_printf(s, "TSC2102_RCH_BASS_BOOST_D1 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_RCH_BASS_BOOST_D1));
+	seq_printf(s, "TSC2102_RCH_BASS_BOOST_D2 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_RCH_BASS_BOOST_D2));
+	seq_printf(s, "TSC2102_RCH_BASS_BOOST_D4 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_RCH_BASS_BOOST_D4));
+	seq_printf(s, "TSC2102_RCH_BASS_BOOST_D5 = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_RCH_BASS_BOOST_D5));
+
+	seq_printf(s, "TSC210X_PLL1_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC210X_PLL1_CTRL));
+	seq_printf(s, "TSC210X_PLL2_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC210X_PLL2_CTRL));
+	seq_printf(s, "TSC2102_AUDIO4_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2102_AUDIO4_CTRL));
+	if (tsc210x_is_tsc2101()) {
+		seq_printf(s, "TSC2101_HANDSET_PGA_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_HANDSET_PGA_CTRL));
+		seq_printf(s, "TSC2101_CELL_BUZZER_PGA_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_CELL_BUZZER_PGA_CTRL));
+		seq_printf(s, "TSC2101_AUDIO5_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_AUDIO5_CTRL));
+		seq_printf(s, "TSC2101_AUDIO6_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_AUDIO6_CTRL));
+		seq_printf(s, "TSC2101_AUDIO7_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_AUDIO7_CTRL));
+		seq_printf(s, "TSC2101_GPIO_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_GPIO_CTRL));
+		seq_printf(s, "TSC2101_AGP_CP_IN_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_AGP_CPIN_CTRL));
+		seq_printf(s, "TSC2101_POWERDOWN_STATUS = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_POWERDOWN_STATUS));
+		seq_printf(s, "TSC2101_MIC_AGC_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_MIC_AGC_CTRL));
+		seq_printf(s, "TSC2101_CELL_PHONE_AGC_CTRL = 0x%04x\n",
+			tsc210x_read_reg(TSC2101_CELL_PHONE_AGC_CTRL));
+	}
+
+	return 0;
+}
+
+static int tsc210x_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, tsc210x_debug_show, NULL);
+}
+
+static const struct file_operations tsc210x_debug_operations = {
+	.open		= tsc210x_debug_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int tsc210x_debugfs_init(void)
+{
+	/* /sys/kernel/debug/tsc210x */
+	(void) debugfs_create_file("tsc210x", S_IFREG | S_IRUGO, NULL, NULL,
+			&tsc210x_debug_operations);
+
+	return 0;
+}
+#endif /* CONFIG_DEBUG_FS */
+
+
+static int __init snd_imx_alsa_tsc210x_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct imx_alsa_codec_config *codec_cfg;
+
+	printk("*** %s\n", __func__);
+
+	codec_cfg = kmalloc(sizeof(*codec_cfg), GFP_KERNEL);
+	if (codec_cfg) {
+		codec_cfg->name = "TSC210x";
+		codec_cfg->hw_constraints_rates   =
+				&tsc2102_hw_constraints_rates;
+		codec_cfg->snd_imx_alsa_playback  =
+				&tsc210x_snd_imx_alsa_playback;
+		codec_cfg->snd_imx_alsa_capture =
+				&tsc2101_snd_imx_alsa_capture;
+		codec_cfg->codec_configure_dev    = tsc2102_configure;
+		codec_cfg->codec_set_samplerate   = tsc2102_set_samplerate;
+		codec_cfg->codec_clock_setup      = tsc2102_clock_setup;
+		codec_cfg->codec_clock_on         = tsc2102_clock_on;
+		codec_cfg->codec_clock_off        = tsc2102_clock_off;
+		codec_cfg->get_default_samplerate =
+				tsc2102_get_default_samplerate;
+		/* forward codec config to PCM layer */
+		ret = snd_imx_alsa_post_probe(pdev, codec_cfg);
+	} else {
+		ret = -ENODEV;
+	}
+
+#ifdef CONFIG_DEBUG_FS
+	tsc210x_debugfs_init();
+#endif
+
+	return ret;
+}
+
+static int snd_imx_alsa_tsc210x_remove(struct platform_device *pdev)
+{
+	tsc210x_dac_power(0);
+
+	return snd_imx_alsa_remove(pdev);
+}
+
+static struct platform_driver imx_alsa_driver = {
+	.probe		= snd_imx_alsa_tsc210x_probe,
+	.remove 	= snd_imx_alsa_tsc210x_remove,
+#ifdef CONFIG_PM
+	.suspend	= snd_imx_alsa_tsc2102_suspend,
+	.resume		= snd_imx_alsa_tsc2102_resume,
+#endif
+	.driver		= {
+		.name	= "tsc210x-alsa",
+	},
+};
+
+static int __init imx_alsa_tsc210x_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&imx_alsa_driver);
+
+	return err;
+}
+
+static void __exit imx_alsa_tsc210x_exit(void)
+{
+	platform_driver_unregister(&imx_alsa_driver);
+}
+
+module_init(imx_alsa_tsc210x_init);
+module_exit(imx_alsa_tsc210x_exit);
+
Index: linux-2.6.29.6/sound/arm/imx-alsa-tsc2102.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.6/sound/arm/imx-alsa-tsc2102.h	2010-03-29 15:01:58.000000000 +0200
@@ -0,0 +1,51 @@
+/*
+ * sound/arm/imx-alsa-tsc2102.h
+ *
+ * Alsa codec driver for TSC2102 chip for IMX1 platforms.
+ *
+ * Copyright (c) 2008 Jorasse  <jorasse@armadeus.com>
+ * Code based on the TSC2101 ALSA driver for omap platforms.
+ * Copyright (c) 2006 Andrzej Zaborowski  <balrog@zabor.org>
+ * Code based on the TSC2101 ALSA driver.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#ifndef IMX_ALSA_TSC2102_H_
+#define IMX_ALSA_TSC2102_H_
+
+#include <linux/types.h>
+
+/* Define to set the TSC as the master, otherwise slave */
+#define TSC_MASTER
+
+/*
+ * Audio related macros
+ */
+#ifndef DEFAULT_BITPERSAMPLE
+#define DEFAULT_BITPERSAMPLE		16
+#endif
+
+#define DEFAULT_SAMPLE_RATE		48000
+#define CODEC_CLOCK			16000000
+#define AUDIO_MCBSP			OMAP_MCBSP1 /* to remove */
+
+/*
+ * ALSA mixer related macros
+ */
+#define OUTPUT_VOLUME_MIN		0x7f	/* 1111111 = -63.5 dB */
+#define OUTPUT_VOLUME_MAX		0x00	/* 0000000 */
+#define OUTPUT_VOLUME_RANGE		(OUTPUT_VOLUME_MIN - OUTPUT_VOLUME_MAX)
+#define DEFAULT_OUTPUT_VOLUME		90	/* Default output volume */
+
+#define INPUT_HND_VOLUME_RANGE		(0x7f)
+#define DEFAULT_INPUT_HND_VOLUME	50
+#define INPUT_HEAD_VOLUME_RANGE		(0x7f)
+#define DEFAULT_INPUT_HEAD_VOLUME	50
+
+
+#endif	/* IMX_ALSA_TSC2102_H_ */
+
Index: linux-2.6.29.6/sound/arm/imx-alsa-tsc2102-mixer.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.6/sound/arm/imx-alsa-tsc2102-mixer.c	2010-03-30 15:49:07.000000000 +0200
@@ -0,0 +1,553 @@
+/*
+ * sound/arm/imx-alsa-tsc2102-mixer.c
+ *
+ * Alsa mixer driver for TSC210x chips.
+ *
+ * Copyright (c) 2008 Armadeus systems - Jorasse <jorasse@armadeus.com>
+ * Code based on the TSC2101 ALSA driver for omap platforms.
+ * Copyright (c) 2006 Andrzej Zaborowski  <balrog@zabor.org>
+ * Code based on the TSC2101 ALSA driver.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/spi/tsc2102.h>
+
+#include <mach/imx-alsa.h>
+
+#include <sound/initval.h>
+#include <sound/control.h>
+
+#include "imx-alsa-tsc2102.h"
+
+
+/* Audio Out: */
+static int vol[2], mute[2], filter[2];
+/* Audio In: */
+static int hnd_vol, hnd_mute, head_vol, head_mute;
+
+/*
+ * Converts the Alsa mixer volume (0 - 100) to actual Digital
+ * Gain Control (DGC) value that can be written or read from the
+ * TSC2102 registers.
+ *
+ * Note that the number "OUTPUT_VOLUME_MAX" is smaller than
+ * OUTPUT_VOLUME_MIN because DGC works as a volume decreaser.  (The
+ * higher the value sent to DAC, the more the volume of controlled
+ * channel is decreased)
+ */
+static void set_dac_gain_stereo(int left_ch, int right_ch)
+{
+	int lch, rch;
+
+	if (left_ch > 100) {
+		vol[0] = 100;
+	} else if (left_ch < 0) {
+		vol[0] = 0;
+	} else {
+		vol[0] = left_ch;
+	}
+	lch = OUTPUT_VOLUME_MIN - vol[0] *
+		(OUTPUT_VOLUME_MIN - OUTPUT_VOLUME_MAX) / 100;
+
+	if (right_ch > 100) {
+		vol[1] = 100;
+	} else if (right_ch < 0) {
+		vol[1] = 0;
+	} else {
+		vol[1] = right_ch;
+	}
+	rch = OUTPUT_VOLUME_MIN - vol[1] *
+		(OUTPUT_VOLUME_MIN - OUTPUT_VOLUME_MAX) / 100;
+
+	tsc210x_set_dac_volume(lch, rch);
+}
+
+/* Audio In is amplified, not attenuated like Audio Out */
+static void set_handset_volume(int volume)
+{
+	uint8_t gain;
+
+	if (volume > 100) {
+		hnd_vol = 100;
+	} else if (volume < 0) {
+		hnd_vol = 0;
+	} else {
+		hnd_vol = volume;
+	}
+	gain = (hnd_vol * INPUT_HND_VOLUME_RANGE) / 100;
+
+	tsc2101_set_handset_gain(gain);
+}
+
+static void set_headset_volume(int volume)
+{
+	uint8_t gain;
+
+	if (volume > 100) {
+		head_vol = 100;
+	} else if (volume < 0) {
+		head_vol = 0;
+	} else {
+		head_vol = volume;
+	}
+	gain = (head_vol * INPUT_HEAD_VOLUME_RANGE) / 100;
+
+	tsc2101_set_headset_gain(gain);
+}
+
+void init_playback_targets(void)
+{
+	set_dac_gain_stereo(DEFAULT_OUTPUT_VOLUME, DEFAULT_OUTPUT_VOLUME);
+	if (tsc210x_is_tsc2101())
+		set_handset_volume(DEFAULT_INPUT_HND_VOLUME);
+
+	/* unmute Audio Out */
+	tsc210x_set_dac_mute(0, 0);
+	mute[0] = mute[1] = 0;
+	/* mute Audio In */
+	if (tsc210x_is_tsc2101()) {
+		tsc2101_handset_mute(1);
+		hnd_mute = 1;
+	}
+
+	filter[0] = filter[1] = 0;
+}
+
+/*
+ * Initializes TSC210x and playback target.
+ */
+static void snd_tsc210x_init_mixer(void)
+{
+	FN_IN;
+
+	init_playback_targets();
+
+	FN_OUT(0);
+}
+
+static int __pcm_playback_volume_info(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type			= SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count			= 2;
+	uinfo->value.integer.min	= 0;
+	uinfo->value.integer.max	= 100;
+
+	return 0;
+}
+
+static int __pcm_playback_volume_get(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = vol[0];	/* L */
+	ucontrol->value.integer.value[1] = vol[1];	/* R */
+
+	return 0;
+}
+
+static int __pcm_playback_volume_put(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	set_dac_gain_stereo(
+			ucontrol->value.integer.value[0],	/* L */
+			ucontrol->value.integer.value[1]);	/* R */
+
+	return 1;
+}
+
+static int __pcm_playback_switch_info(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type			= SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count			= 2;
+	uinfo->value.integer.min	= 0;
+	uinfo->value.integer.max	= 1;
+
+	return 0;
+}
+
+static int __pcm_playback_switch_get(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = !mute[0];		/* L */
+	ucontrol->value.integer.value[1] = !mute[1];		/* R */
+
+	return 0;
+}
+
+static int __pcm_playback_switch_put(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	mute[0] = (ucontrol->value.integer.value[0] == 0);	/* L */
+	mute[1] = (ucontrol->value.integer.value[1] == 0);	/* R */
+
+	tsc210x_set_dac_mute(mute[0], mute[1]);
+
+	return 1;
+}
+
+static int __pcm_playback_deemphasis_info(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type			= SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count			= 1;
+	uinfo->value.integer.min	= 0;
+	uinfo->value.integer.max	= 1;
+
+	return 0;
+}
+
+static int __pcm_playback_deemphasis_get(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = filter[0];
+
+	return 0;
+}
+
+static int __pcm_playback_deemphasis_put(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	filter[0] = (ucontrol->value.integer.value[0] > 0);
+	tsc210x_set_deemphasis(filter[0]);
+
+	return 1;
+}
+
+static int __pcm_playback_bassboost_info(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type			= SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count			= 1;
+	uinfo->value.integer.min	= 0;
+	uinfo->value.integer.max	= 1;
+
+	return 0;
+}
+
+static int __pcm_playback_bassboost_get(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = filter[1];
+
+	return 0;
+}
+
+static int __pcm_playback_bassboost_put(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	filter[1] = (ucontrol->value.integer.value[0] > 0);
+	tsc210x_set_bassboost(filter[1]);
+
+	return 1;
+}
+
+/* Capture controls (only available on TSC2101) */
+
+static int __capture_mux_enum_info(struct snd_kcontrol *kcontrol,
+                          struct snd_ctl_elem_info *uinfo)
+{
+          static char *texts[3] = {
+                  "Headset", "Handset", "None"
+          };
+          uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+          uinfo->count = 1;
+          uinfo->value.enumerated.items = 3;
+          if (uinfo->value.enumerated.item > 2)
+                  uinfo->value.enumerated.item = 2;
+          strcpy(uinfo->value.enumerated.name,
+                 texts[uinfo->value.enumerated.item]);
+          return 0;
+}
+
+static int __capture_mux_enum_get(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = tsc2101_get_micsel();
+
+	return 0;
+}
+
+static int __capture_mux_enum_put(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	tsc2101_set_micsel((uint8_t)(ucontrol->value.integer.value[0]));
+
+	return 1;
+}
+
+static int __handset_capture_volume_info(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type			= SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count			= 1;	/* Mono */
+	uinfo->value.integer.min	= 0;
+	uinfo->value.integer.max	= 100;
+
+	return 0;
+}
+
+static int __handset_capture_volume_get(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = hnd_vol;
+
+	return 0;
+}
+
+static int __handset_capture_volume_put(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	set_handset_volume(ucontrol->value.integer.value[0]); /* hnd_vol mod. here */
+
+	return 1;
+}
+
+static int __handset_capture_switch_info(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type			= SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count			= 1;
+	uinfo->value.integer.min	= 0;
+	uinfo->value.integer.max	= 1;
+
+	return 0;
+}
+
+static int __handset_capture_switch_get(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = !hnd_mute;
+
+	return 0;
+}
+
+static int __handset_capture_switch_put(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	hnd_mute = (ucontrol->value.integer.value[0] == 0);
+	tsc2101_handset_mute(hnd_mute);
+
+	return 1;
+}
+
+static int __headset_capture_volume_info(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type			= SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count			= 1;	/* Mono */
+	uinfo->value.integer.min	= 0;
+	uinfo->value.integer.max	= 100;
+
+	return 0;
+}
+
+static int __headset_capture_volume_get(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = head_vol;
+
+	return 0;
+}
+
+static int __headset_capture_volume_put(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	set_headset_volume(ucontrol->value.integer.value[0]); /* head_vol mod. here */
+
+	return 1;
+}
+
+static int __headset_capture_switch_info(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type			= SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count			= 1;
+	uinfo->value.integer.min	= 0;
+	uinfo->value.integer.max	= 1;
+
+	return 0;
+}
+
+static int __headset_capture_switch_get(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = !head_mute;
+
+	return 0;
+}
+
+static int __headset_capture_switch_put(
+		struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	head_mute = (ucontrol->value.integer.value[0] == 0);
+	tsc2101_headset_mute(head_mute);
+
+	return 1;
+}
+
+
+static struct snd_kcontrol_new tsc210x_control[] __devinitdata = {
+	{
+		.name	= "Master Playback Volume",
+		.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+		.index	= 0,
+		.access	= SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info	= __pcm_playback_volume_info,
+		.get	= __pcm_playback_volume_get,
+		.put	= __pcm_playback_volume_put,
+	},
+	{
+		.name	= "Master Playback Switch",
+		.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+		.index	= 0,
+		.access	= SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info	= __pcm_playback_switch_info,
+		.get	= __pcm_playback_switch_get,
+		.put	= __pcm_playback_switch_put,
+	},
+	{
+		.name	= "De-emphasis Filter Switch",
+		.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+		.index	= 0,
+		.access	= SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info	= __pcm_playback_deemphasis_info,
+		.get	= __pcm_playback_deemphasis_get,
+		.put	= __pcm_playback_deemphasis_put,
+	},
+	{
+		.name	= "Bass-boost Filter Switch",
+		.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+		.index	= 0,
+		.access	= SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info	= __pcm_playback_bassboost_info,
+		.get	= __pcm_playback_bassboost_get,
+		.put	= __pcm_playback_bassboost_put,
+	},
+};
+
+static struct snd_kcontrol_new tsc2101_control[] __devinitdata = {
+	{
+		.name	= "Mic Capture Route",
+		.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+		.info	= __capture_mux_enum_info,
+		.get	= __capture_mux_enum_get,
+		.put	= __capture_mux_enum_put,
+	},
+	{
+		.name	= "Handset Capture Volume",
+		.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+		.index	= 0,
+		.access	= SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info	= __handset_capture_volume_info,
+		.get	= __handset_capture_volume_get,
+		.put	= __handset_capture_volume_put,
+	},
+	{
+		.name	= "Handset Capture Switch",
+		.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+		.index	= 0,
+		.access	= SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info	= __handset_capture_switch_info,
+		.get	= __handset_capture_switch_get,
+		.put	= __handset_capture_switch_put,
+	},
+	{
+		.name	= "Headset Capture Volume",
+		.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+		.index	= 0,
+		.access	= SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info	= __headset_capture_volume_info,
+		.get	= __headset_capture_volume_get,
+		.put	= __headset_capture_volume_put,
+	},
+	{
+		.name	= "Headset Capture Switch",
+		.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+		.index	= 0,
+		.access	= SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info	= __headset_capture_switch_info,
+		.get	= __headset_capture_switch_get,
+		.put	= __headset_capture_switch_put,
+	},
+};
+
+
+#ifdef CONFIG_PM
+void snd_tsc210x_suspend_mixer(void)
+{
+	/* Nothing to do */
+}
+
+void snd_tsc210x_resume_mixer(void)
+{
+	/* The chip was reset, restore the last used values */
+	set_dac_gain_stereo(vol[0], vol[1]);
+	if (tsc210x_is_tsc2101())
+		set_handset_volume(hnd_vol);
+
+	tsc210x_set_dac_mute(mute[0], mute[1]);
+	if (tsc210x_is_tsc2101())
+		tsc2101_handset_mute(hnd_mute);
+
+	tsc210x_set_deemphasis(filter[0]);
+	tsc210x_set_bassboost(filter[1]);
+}
+#endif
+
+
+/* To be called by upper layer to add a tsc210x mixer to a given soundcard */
+int snd_imx_mixer(struct snd_card_imx_codec *tsc210x)
+{
+	int i, err;
+
+	if (!tsc210x)
+		return -EINVAL;
+
+	/* TSC2102/TSC2101 common part */
+	for (i = 0; i < ARRAY_SIZE(tsc210x_control); i ++) {
+		err = snd_ctl_add(tsc210x->card,
+				  snd_ctl_new1(&tsc210x_control[i],
+				  tsc210x->card));
+		if (err < 0)
+			return err;
+	}
+
+	/* TSC2101 specific part */
+	if (tsc210x_is_tsc2101()) {
+		for (i = 0; i < ARRAY_SIZE(tsc2101_control); i ++) {
+			err = snd_ctl_add(tsc210x->card,
+					  snd_ctl_new1(&tsc2101_control[i],
+					  tsc210x->card));
+			if (err < 0)
+				return err;
+		}
+	}
+	snd_tsc210x_init_mixer();
+
+	return 0;
+}
+
+MODULE_AUTHOR("Andrzej Zaborowski, Eric Jarrige, Julien Boibessot");
+MODULE_DESCRIPTION("Mixer interface driver for TI TSC210x chips.");
+MODULE_LICENSE("GPL");
