Signed-off-by: Eric Jarrige <eric.jarrige@armadeus.org>
Signed-off-by: Nicolas Colombain <nicolas.colombain@armadeus.com>
Signed-off-by: Philippe Reynes <tremyfr@yahoo.fr>
---
 board/armadeus/apf51/Makefile |   43 ++
 board/armadeus/apf51/apf51.c  | 1222 +++++++++++++++++++++++++++++++++++++++++
 board/armadeus/apf51/fpga.c   |  266 +++++++++
 board/armadeus/apf51/fpga.h   |   39 ++
 boards.cfg                    |    1 +
 5 files changed, 1571 insertions(+), 0 deletions(-)
 create mode 100644 board/armadeus/apf51/Makefile
 create mode 100644 board/armadeus/apf51/apf51.c
 create mode 100644 board/armadeus/apf51/fpga.c
 create mode 100644 board/armadeus/apf51/fpga.h

diff --git a/board/armadeus/apf51/Makefile b/board/armadeus/apf51/Makefile
new file mode 100644
index 0000000..9d94f74
--- /dev/null
+++ b/board/armadeus/apf51/Makefile
@@ -0,0 +1,43 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2009 Freescale Semiconductor, Inc.
+# (C) Copyright 2010 Eric Jarrige, Armadeus Project
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	 = $(obj)lib$(BOARD).o
+
+COBJS	:= apf51.o fpga.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/armadeus/apf51/apf51.c b/board/armadeus/apf51/apf51.c
new file mode 100644
index 0000000..8ff1381
--- /dev/null
+++ b/board/armadeus/apf51/apf51.c
@@ -0,0 +1,1157 @@
+/*
+ * (C) Copyright 2010-2013 Eric Jarrige, Armadeus Project
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <asm/armv7.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/iomux-mx51.h>
+#include <asm/arch/regs_esdctl.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/errno.h>
+#include <i2c.h>
+#include <jffs2/jffs2.h>
+#include <fsl_esdhc.h>
+#include "fpga.h"
+#include <nand.h>
+#include <mmc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+unsigned long boot_verb;
+
+u32 get_board_rev(void)
+{
+
+	struct iim_regs *iim = (struct iim_regs *)IMX_IIM_BASE;
+
+	return readl(&iim->bank[1].fuse_regs[0x0f]) & 0x1f;
+}
+
+int get_num_ram_bank(void)
+{
+	struct iim_regs *iim = (struct iim_regs *)IMX_IIM_BASE;
+	int nr_dram_banks = 1;
+
+	if ((get_board_rev() > 0) && (CONFIG_NR_DRAM_BANKS > 1))
+		nr_dram_banks += readl(&iim->bank[1].fuse_regs[0x10]) & 0x01;
+	else
+		nr_dram_banks = CONFIG_NR_DRAM_POPULATED;
+
+	return nr_dram_banks;
+}
+
+int dram_init(void)
+{
+
+	gd->ram_size = get_ram_size((void *)CSD0_BASE_ADDR, PHYS_SDRAM_1_SIZE);
+	if (get_num_ram_bank() > 1) {
+		gd->ram_size +=
+			get_ram_size((void *)CSD1_BASE_ADDR, PHYS_SDRAM_2_SIZE);
+	}
+
+	return 0;
+}
+
+void dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = CSD0_BASE_ADDR;
+	gd->bd->bi_dram[0].size = gd->ram_size / get_num_ram_bank();
+	if (CONFIG_NR_DRAM_BANKS > 1) {
+		gd->bd->bi_dram[1].start = CSD1_BASE_ADDR;
+		gd->bd->bi_dram[1].size = gd->ram_size
+					- gd->bd->bi_dram[0].size;
+	}
+
+}
+
+void setup_usb(void)
+{
+	/*
+	 * Configure iomux for USB interfaces
+	 */
+#define USB_PAD_CFG		(PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE |\
+				 PAD_CTL_PUE_KEEPER | PAD_CTL_100K_PU |	\
+				 PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST)
+	/*
+	 * usboh1
+	 */
+	mxc_request_iomux(MX51_PIN_USBH1_CLK, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_USBH1_DIR, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_USBH1_STP, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_USBH1_NXT, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_USBH1_DATA0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_USBH1_DATA1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_USBH1_DATA2, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_USBH1_DATA3, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_USBH1_DATA4, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_USBH1_DATA5, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_USBH1_DATA6, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_USBH1_DATA7, IOMUX_CONFIG_ALT0);
+
+	mxc_iomux_set_pad(MX51_PIN_USBH1_CLK, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_DIR, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_STP, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_NXT, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_DATA0, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_DATA1, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_DATA2, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_DATA3, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_DATA4, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_DATA5, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_DATA6, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_USBH1_DATA7, USB_PAD_CFG);
+	/*
+	 * usboh2
+	 */
+	mxc_request_iomux(MX51_PIN_EIM_D16, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_EIM_D17, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_EIM_D18, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_EIM_D19, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_EIM_D20, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_EIM_D21, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_EIM_D22, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_EIM_D23, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_EIM_A24, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_EIM_A25, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_EIM_A27, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_GPIO1_8, IOMUX_CONFIG_ALT1);
+	mxc_request_iomux(MX51_PIN_GPIO1_9, IOMUX_CONFIG_ALT1);
+
+	mxc_iomux_set_pad(MX51_PIN_EIM_D16, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_D17, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_D18, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_D19, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_D20, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_D21, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_D22, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_D23, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_A24, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_A25, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_A26, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_A27, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_GPIO1_8, USB_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_GPIO1_9, USB_PAD_CFG);
+}
+
+void setup_uart(void)
+{
+	/*
+	 * Configure iomux for UART interfaces
+	 */
+#define UART_PAD_CFG		(PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE |\
+				 PAD_CTL_PUE_PULL | PAD_CTL_100K_PU |	\
+				 PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST)
+	/*
+	 * uart1
+	 */
+	mxc_request_iomux(MX51_PIN_UART1_RTS, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_UART1_CTS, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_UART1_RXD, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_UART1_TXD, IOMUX_CONFIG_ALT0);
+
+	mxc_iomux_set_pad(MX51_PIN_UART1_RTS, UART_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_UART1_CTS, UART_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_UART1_RXD, UART_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_UART1_TXD, UART_PAD_CFG);
+
+	/*
+	 * uart2
+	 */
+	mxc_request_iomux(MX51_PIN_EIM_D25, IOMUX_CONFIG_ALT4);
+	mxc_request_iomux(MX51_PIN_EIM_D26, IOMUX_CONFIG_ALT4);
+	mxc_request_iomux(MX51_PIN_UART2_RXD, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_UART2_TXD, IOMUX_CONFIG_ALT0);
+
+	mxc_iomux_set_pad(MX51_PIN_EIM_D25, UART_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_D26, UART_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_UART2_RXD, UART_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_UART2_TXD, UART_PAD_CFG);
+
+	mxc_iomux_set_input(MX51_UART2_IPP_UART_RXD_MUX_SELECT_INPUT,
+			    INPUT_CTL_PATH2);
+	mxc_iomux_set_input(MX51_UART2_IPP_UART_RTS_B_SELECT_INPUT,
+			    INPUT_CTL_PATH3);
+	/*
+	 * uart3
+	 */
+	mxc_request_iomux(MX51_PIN_UART3_RXD, IOMUX_CONFIG_ALT1);
+	mxc_request_iomux(MX51_PIN_UART3_TXD, IOMUX_CONFIG_ALT1);
+
+	mxc_iomux_set_pad(MX51_PIN_UART3_RXD, UART_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_UART3_TXD, UART_PAD_CFG);
+
+	mxc_iomux_set_input(MX51_UART3_IPP_UART_RXD_MUX_SELECT_INPUT,
+			    INPUT_CTL_PATH4);
+}
+
+void setup_audio(void)
+{
+	/*
+	 * Configure iomux for audio interfaces
+	 */
+#define AUD_PAD_CFG		(PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE |\
+				 PAD_CTL_PUE_KEEPER | PAD_CTL_100K_PU |	\
+				 PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST)
+	/*
+	 * audmux3
+	 */
+	mxc_request_iomux(MX51_PIN_AUD3_BB_TXD, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_AUD3_BB_RXD, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_AUD3_BB_CK, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_AUD3_BB_FS, IOMUX_CONFIG_ALT0);
+
+	mxc_iomux_set_pad(MX51_PIN_AUD3_BB_TXD, AUD_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_AUD3_BB_RXD, AUD_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_AUD3_BB_CK, AUD_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_AUD3_BB_FS, AUD_PAD_CFG);
+	/*
+	 * audmux5
+	 */
+	mxc_request_iomux(MX51_PIN_EIM_EB2, IOMUX_CONFIG_ALT6);
+	mxc_request_iomux(MX51_PIN_EIM_EB3, IOMUX_CONFIG_ALT6);
+	mxc_request_iomux(MX51_PIN_EIM_CS2, IOMUX_CONFIG_ALT6);
+	mxc_request_iomux(MX51_PIN_EIM_CS3, IOMUX_CONFIG_ALT6);
+	mxc_request_iomux(MX51_PIN_EIM_CS4, IOMUX_CONFIG_ALT6);
+	mxc_request_iomux(MX51_PIN_EIM_CS5, IOMUX_CONFIG_ALT6);
+
+	mxc_iomux_set_pad(MX51_PIN_EIM_EB2, AUD_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_EB3, AUD_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_CS2, AUD_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_CS3, AUD_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_CS4, AUD_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_CS5, AUD_PAD_CFG);
+
+	mxc_iomux_set_input(MX51_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT,
+			    INPUT_CTL_PATH1);
+	mxc_iomux_set_input(MX51_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT,
+			    INPUT_CTL_PATH1);
+	/*
+	 * audmux6
+	 */
+	mxc_request_iomux(MX51_PIN_EIM_D28, IOMUX_CONFIG_ALT5);
+	mxc_request_iomux(MX51_PIN_EIM_D29, IOMUX_CONFIG_ALT5);
+	mxc_request_iomux(MX51_PIN_EIM_D30, IOMUX_CONFIG_ALT5);
+	mxc_request_iomux(MX51_PIN_EIM_D31, IOMUX_CONFIG_ALT5);
+
+	mxc_iomux_set_pad(MX51_PIN_EIM_D28, AUD_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_D29, AUD_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_D30, AUD_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_EIM_D31, AUD_PAD_CFG);
+}
+
+void setup_csi(void)
+{
+	/*
+	 * Configure iomux for CSI interfaces
+	 */
+#define CSI_PAD_CFG		(PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE |\
+				 PAD_CTL_PUE_KEEPER | PAD_CTL_100K_PU |	\
+				 PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST)
+	/*
+	 * csi1
+	 */
+	mxc_request_iomux(MX51_PIN_CSI1_D8, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_D9, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_D10, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_D11, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_D12, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_D13, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_D14, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_D15, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_D16, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_D17, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_D18, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_D19, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_VSYNC, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_HSYNC, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_PIXCLK, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSI1_MCLK, IOMUX_CONFIG_ALT0);
+
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D8, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D9, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D10, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D11, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D12, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D13, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D14, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D15, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D16, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D17, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D18, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_D19, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_VSYNC, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_HSYNC, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_PIXCLK, CSI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_CSI1_MCLK, CSI_PAD_CFG);
+}
+
+void setup_eim(void)
+{
+struct weim *weim = (struct weim *)WEIM_BASE_ADDR;
+	/*
+	 * Configure iomux for EIM interface
+	 */
+	mxc_request_iomux(MX51_PIN_EIM_DA0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA2, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA3, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA4, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA5, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA6, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA7, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA8, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA9, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA10, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA11, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA12, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA13, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA14, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DA15, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_EB0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_EB1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_OE, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_CS0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_CS1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_EIM_DTACK, IOMUX_CONFIG_ALT0);
+/* missing in DS mxc_request_iomux(MX51_PIN_EIM_WAIT, IOMUX_CONFIG_ALT0); */
+	mxc_request_iomux(MX51_PIN_EIM_LBA, IOMUX_CONFIG_ALT0);
+/* missing in DS mxc_request_iomux(MX51_PIN_EIM_BCLK, IOMUX_CONFIG_ALT0); */
+/* missing in DS mxc_request_iomux(MX51_PIN_EIM_RW , IOMUX_CONFIG_ALT0); */
+
+	/*
+	 * Configure Register for each chip select
+	 */
+	writel(ACFG_WCR_VALUE, &weim->wcr);
+	writel(ACFG_WIAR_VALUE, &weim->wiar);
+
+	writel(ACFG_CS1GCR1_VALUE, &weim->cs1gcr1);
+	writel(ACFG_CS2GCR1_VALUE, &weim->cs2gcr1);
+	writel(ACFG_CS3GCR1_VALUE, &weim->cs3gcr1);
+	writel(ACFG_CS4GCR1_VALUE, &weim->cs4gcr1);
+	writel(ACFG_CS5GCR1_VALUE, &weim->cs5gcr1);
+
+	writel(ACFG_CS1GCR2_VALUE, &weim->cs1gcr2);
+	writel(ACFG_CS2GCR2_VALUE, &weim->cs2gcr2);
+	writel(ACFG_CS3GCR2_VALUE, &weim->cs3gcr2);
+	writel(ACFG_CS4GCR2_VALUE, &weim->cs4gcr2);
+	writel(ACFG_CS5GCR2_VALUE, &weim->cs5gcr2);
+
+	writel(ACFG_CS1RCR1_VALUE, &weim->cs1rcr1);
+	writel(ACFG_CS2RCR1_VALUE, &weim->cs2rcr1);
+	writel(ACFG_CS3RCR1_VALUE, &weim->cs3rcr1);
+	writel(ACFG_CS4RCR1_VALUE, &weim->cs4rcr1);
+	writel(ACFG_CS5RCR1_VALUE, &weim->cs5rcr1);
+
+	writel(ACFG_CS1RCR2_VALUE, &weim->cs1rcr2);
+	writel(ACFG_CS2RCR2_VALUE, &weim->cs2rcr2);
+	writel(ACFG_CS3RCR2_VALUE, &weim->cs3rcr2);
+	writel(ACFG_CS4RCR2_VALUE, &weim->cs4rcr2);
+	writel(ACFG_CS5RCR2_VALUE, &weim->cs5rcr2);
+
+	writel(ACFG_CS1WCR1_VALUE, &weim->cs1wcr1);
+	writel(ACFG_CS2WCR1_VALUE, &weim->cs2wcr1);
+	writel(ACFG_CS3WCR1_VALUE, &weim->cs3wcr1);
+	writel(ACFG_CS4WCR1_VALUE, &weim->cs4wcr1);
+	writel(ACFG_CS5WCR1_VALUE, &weim->cs5wcr1);
+
+	writel(ACFG_CS1WCR2_VALUE, &weim->cs1wcr2);
+	writel(ACFG_CS2WCR2_VALUE, &weim->cs2wcr2);
+	writel(ACFG_CS3WCR2_VALUE, &weim->cs3wcr2);
+	writel(ACFG_CS4WCR2_VALUE, &weim->cs4wcr2);
+	writel(ACFG_CS5WCR2_VALUE, &weim->cs5wcr2);
+
+}
+
+void setup_keypad(void)
+{
+	/*
+	 * Configure iomux for KEYPAD interfaces
+	 */
+	mxc_request_iomux(MX51_PIN_KEY_ROW0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_ROW1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_ROW2, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_ROW3, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_COL0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_COL1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_COL2, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_COL3, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_COL4, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_COL5, IOMUX_CONFIG_ALT0);
+}
+
+void setup_misc(void)
+{
+	/*
+	 * Configure iomux for misc interfaces
+	 */
+#define GPIO_PAD_CFG		(PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE |\
+				 PAD_CTL_PUE_KEEPER | PAD_CTL_100K_PU |	\
+				 PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST)
+
+	/* pwm 1 & 2 */
+	mxc_request_iomux(MX51_PIN_GPIO1_2, IOMUX_CONFIG_ALT1);
+	mxc_iomux_set_pad(MX51_PIN_GPIO1_2, GPIO_PAD_CFG);
+
+	mxc_request_iomux(MX51_PIN_GPIO1_3, IOMUX_CONFIG_ALT1);
+	mxc_iomux_set_pad(MX51_PIN_GPIO1_3, GPIO_PAD_CFG);
+
+	/* touch detect# */
+	mxc_request_iomux(MX51_PIN_GPIO1_4, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_GPIO1_4, GPIO_PAD_CFG);
+
+	/* clko */
+	mxc_request_iomux(MX51_PIN_GPIO1_5, IOMUX_CONFIG_ALT5);
+	mxc_iomux_set_pad(MX51_PIN_GPIO1_5, GPIO_PAD_CFG);
+
+	/* touch eoc# */
+	mxc_request_iomux(MX51_PIN_GPIO1_6, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_GPIO1_6, GPIO_PAD_CFG);
+
+	/* PMIC IRQ */
+	mxc_request_iomux(MX51_PIN_GPIO1_7, IOMUX_CONFIG_ALT0);
+
+	/* FEC PHY RST# */
+	mxc_request_iomux(MX51_PIN_DI1_PIN11, IOMUX_CONFIG_ALT4);
+	mxc_iomux_set_pad(MX51_PIN_DI1_PIN11, GPIO_PAD_CFG);
+
+	/* USBHOST RST# */
+	mxc_request_iomux(MX51_PIN_DI1_PIN12, IOMUX_CONFIG_ALT4);
+	mxc_iomux_set_pad(MX51_PIN_DI1_PIN12, GPIO_PAD_CFG);
+
+	/* PMIC SLEEP# */
+	mxc_request_iomux(MX51_PIN_DISPB2_SER_CLK, IOMUX_CONFIG_ALT4);
+	mxc_iomux_set_pad(MX51_PIN_DISPB2_SER_CLK, GPIO_PAD_CFG);
+
+	/* PMIC OFF# */
+	mxc_request_iomux(MX51_PIN_DISPB2_SER_RS, IOMUX_CONFIG_ALT4);
+	mxc_iomux_set_pad(MX51_PIN_DISPB2_SER_RS, GPIO_PAD_CFG);
+}
+
+void setup_fpga(void)
+{
+	/* FPGA PWR */
+	mxc_request_iomux(ACFG_FPGA_PWR, IOMUX_CONFIG_ALT4);
+	mxc_iomux_set_pad(ACFG_FPGA_PWR, GPIO_PAD_CFG);
+
+	/* FPGA SUSPEND */
+	mxc_request_iomux(ACFG_FPGA_SUSPEND, IOMUX_CONFIG_ALT4);
+	mxc_iomux_set_pad(ACFG_FPGA_SUSPEND, GPIO_PAD_CFG);
+
+	/* FPGA PROG */
+	mxc_request_iomux(ACFG_FPGA_PRG, IOMUX_CONFIG_ALT3);
+	mxc_iomux_set_pad(ACFG_FPGA_PRG, GPIO_PAD_CFG);
+
+	/* FPGA DONE */
+	mxc_request_iomux(ACFG_FPGA_DONE, IOMUX_CONFIG_ALT3);
+	mxc_iomux_set_pad(ACFG_FPGA_DONE, GPIO_PAD_CFG);
+
+	/* FPGA INIT# */
+	mxc_request_iomux(ACFG_FPGA_INIT, IOMUX_CONFIG_ALT3);
+	mxc_iomux_set_pad(ACFG_FPGA_INIT, GPIO_PAD_CFG);
+
+}
+
+void setup_display(void)
+{
+	/*
+	 * Configure iomux for display 1 interface
+	 */
+	mxc_request_iomux(MX51_PIN_DI1_D1_CS, IOMUX_CONFIG_ALT4);
+/* missing in DS mxc_request_iomux(MX51_PIN_DI1_DISP_CLK, IOMUX_CONFIG_ALT0);*/
+	mxc_request_iomux(MX51_PIN_DI1_PIN2, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DI1_PIN3, IOMUX_CONFIG_ALT0);
+/* missing in DS mxc_request_iomux(MX51_PIN_DI1_PIN15, IOMUX_CONFIG_ALT0);*/
+
+	mxc_request_iomux(MX51_PIN_DISP1_DAT0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT2, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT3, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT4, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT5, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT6, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT7, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT8, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT9, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT10, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT11, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT12, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT13, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT14, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT15, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT16, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT17, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT18, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT19, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT20, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT21, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT22, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_DISP1_DAT23, IOMUX_CONFIG_ALT0);
+}
+
+void setup_nfc(void)
+{
+	/*
+	 * Configure iomux for NFC interface
+	 */
+#define NAND_PAD47K_CFG		(PAD_CTL_DRV_VOT_HIGH | PAD_CTL_HYS_NONE | \
+				PAD_CTL_PKE_ENABLE | PAD_CTL_47K_PU |	\
+				PAD_CTL_DRV_HIGH)
+
+#define NAND_PAD100K_CFG	(PAD_CTL_DRV_VOT_HIGH | PAD_CTL_HYS_NONE | \
+				PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PU | \
+				PAD_CTL_DRV_HIGH)
+
+	mxc_request_iomux(MX51_PIN_NANDF_WE_B, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_WE_B, NAND_PAD47K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_RE_B, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_RE_B, NAND_PAD47K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_ALE, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_ALE, NAND_PAD47K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_CLE, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_CLE, NAND_PAD47K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_WP_B, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_WP_B, NAND_PAD100K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_RB0, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_RB0, PAD_CTL_DRV_VOT_HIGH |
+				PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE |
+				PAD_CTL_PUE_PULL | PAD_CTL_100K_PU);
+
+	mxc_request_iomux(MX51_PIN_NANDF_CS0, IOMUX_CONFIG_ALT0);
+
+	/* MX51_PIN_NANDF_RDY_INT */
+
+	mxc_request_iomux(MX51_PIN_NANDF_D0, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D0, NAND_PAD100K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_D1, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D1, NAND_PAD100K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_D2, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D2, NAND_PAD100K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_D3, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D3, NAND_PAD100K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_D4, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D4, NAND_PAD100K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_D5, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D5, NAND_PAD100K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_D6, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D6, NAND_PAD100K_CFG);
+
+	mxc_request_iomux(MX51_PIN_NANDF_D7, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D7, NAND_PAD100K_CFG);
+}
+
+void setup_spi_io(void)
+{
+	/*
+	 * Configure iomux for SPI interface
+	 */
+#define CSPI_PAD_CFG		(PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | \
+				PAD_CTL_PUE_KEEPER | PAD_CTL_100K_PU |	\
+				PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST)
+	/*
+	 * ECSPI1
+	 */
+	mxc_request_iomux(MX51_PIN_CSPI1_MOSI, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSPI1_MISO, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSPI1_SS0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSPI1_SS1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSPI1_RDY, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_CSPI1_SCLK, IOMUX_CONFIG_ALT0);
+
+	/*
+	 * ECSPI2
+	 */
+	mxc_request_iomux(MX51_PIN_NANDF_RB1, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_NANDF_RB2, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_NANDF_RB3, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_NANDF_D12, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_NANDF_D13, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_NANDF_D14, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX51_PIN_NANDF_D15, IOMUX_CONFIG_ALT2);
+
+	mxc_iomux_set_pad(MX51_PIN_NANDF_RB1, CSPI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_RB2, CSPI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_RB3, CSPI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D12, CSPI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D13, CSPI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D14, CSPI_PAD_CFG);
+	mxc_iomux_set_pad(MX51_PIN_NANDF_D15, CSPI_PAD_CFG);
+
+	mxc_iomux_set_input(MX51_CSPI_IPP_IND_SS_B_1_SELECT_INPUT,
+			    INPUT_CTL_PATH1);
+}
+
+#ifdef CONFIG_I2C_MXC
+#define I2C_PAD_CFG	(PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | \
+	PAD_CTL_ODE_OPENDRAIN_ENABLE | PAD_CTL_100K_PU | PAD_CTL_HYS_ENABLE)
+
+static void setup_i2c(unsigned int module_base)
+{
+	/*
+	 * Configure iomux for I2C interfaces
+	 */
+	switch (module_base) {
+	case I2C1_BASE_ADDR:
+		/* SCL */
+		mxc_request_iomux(MX51_PIN_I2C1_CLK,
+				  IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+
+		/* SDA */
+		mxc_request_iomux(MX51_PIN_I2C1_DAT,
+				  IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+		break;
+
+	case I2C2_BASE_ADDR:	/* do not use without disabling UART3 first */
+		/* SCL */
+		mxc_request_iomux(MX51_PIN_EIM_D24,
+				  IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION);
+
+		/* SDA */
+		mxc_request_iomux(MX51_PIN_EIM_D27,
+				  IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION);
+		mxc_iomux_set_input(MX51_I2C2_IPP_SDA_IN_SELECT_INPUT,
+				    INPUT_CTL_PATH0);
+		break;
+
+	default:
+		printf("Invalid I2C base: 0x%x\n", module_base);
+		break;
+	}
+}
+#endif
+
+static void setup_fec(void)
+{
+#ifdef CONFIG_FEC_MXC
+#define CFG_FEC_PAD		(PAD_CTL_DRV_MEDIUM | PAD_CTL_PUE_KEEPER | \
+				 PAD_CTL_HYS_ENABLE | PAD_CTL_DRV_VOT_HIGH)
+
+	gpio_set_value(CONFIG_SYS_PHY_RESET_GPIO, 0);
+	gpio_direction_output(CONFIG_SYS_PHY_RESET_GPIO, 0);
+
+	/* FEC TX_ER muxed with DI_GP3 */
+	mxc_request_iomux(MX51_PIN_DI_GP3, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DI_GP3, CFG_FEC_PAD);
+
+	/* FEC CRS muxed with DI2_PIN4 */
+	mxc_request_iomux(MX51_PIN_DI2_PIN4, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DI2_PIN4, CFG_FEC_PAD);
+
+	/* FEC MDC muxed with DI2_PIN2 */
+	mxc_request_iomux(MX51_PIN_DI2_PIN2, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DI2_PIN2, CFG_FEC_PAD);
+
+	/* FEC MDIO muxed with DI2_PIN3 */
+	mxc_request_iomux(MX51_PIN_DI2_PIN3, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DI2_PIN3, CFG_FEC_PAD);
+
+	/* FEC RDATA[1] muxed with DI2_DISP_CLK */
+	mxc_request_iomux(MX51_PIN_DI2_DISP_CLK, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DI2_DISP_CLK, CFG_FEC_PAD);
+
+	/* FEC RDATA[2] muxed with DI_GP4 */
+	mxc_request_iomux(MX51_PIN_DI_GP4, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DI_GP4, CFG_FEC_PAD);
+
+	/* FEC RDATA[3] muxed with DISP2_DAT0 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT0, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT0, CFG_FEC_PAD);
+
+	/* FEC RX_ER muxed with DISP2_DAT1 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT1, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT1, CFG_FEC_PAD);
+
+	/* FEC TDATA[1] muxed with DISP2_DAT6 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT6, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT6, CFG_FEC_PAD);
+
+	/* FEC TDATA[2] muxed with DISP2_DAT7 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT7, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT7, CFG_FEC_PAD);
+
+	/* FEC TDATA[3] muxed with DISP2_DAT8 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT8, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT8, CFG_FEC_PAD);
+
+	/* FEC TX_EN muxed with DISP2_DAT9 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT9, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT9, CFG_FEC_PAD);
+
+	/* FEC COL muxed with DISP_DATA10 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT10, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT10, CFG_FEC_PAD);
+
+	/* FEC RX_CLK muxed with DISP2_DAT11 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT11, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT11, CFG_FEC_PAD);
+
+	/* FEC RX_DV muxed with DISP2_DAT12 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT12, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT12, CFG_FEC_PAD);
+
+	/* FEC TX_CLK muxed with DISP2_DAT13 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT13, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT13, CFG_FEC_PAD);
+
+	/* FEC RDATA[0] muxed with DISP2_DAT14 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT14, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT14, CFG_FEC_PAD);
+
+	/* FEC TDATA[0] muxed with DISP2_DAT15 */
+	mxc_request_iomux(MX51_PIN_DISP2_DAT15, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX51_PIN_DISP2_DAT15, CFG_FEC_PAD);
+
+	/*
+	 * FEC signals involved in daisy chain should be mapped
+	 * to DISP2/DI2 pads
+	 */
+	mxc_iomux_set_input(MX51_FEC_FEC_COL_SELECT_INPUT, INPUT_CTL_PATH1);
+	mxc_iomux_set_input(MX51_FEC_FEC_CRS_SELECT_INPUT, INPUT_CTL_PATH1);
+	mxc_iomux_set_input(MX51_FEC_FEC_MDI_SELECT_INPUT, INPUT_CTL_PATH1);
+	mxc_iomux_set_input(MX51_FEC_FEC_RDATA_0_SELECT_INPUT, INPUT_CTL_PATH1);
+	mxc_iomux_set_input(MX51_FEC_FEC_RDATA_1_SELECT_INPUT, INPUT_CTL_PATH1);
+	mxc_iomux_set_input(MX51_FEC_FEC_RDATA_2_SELECT_INPUT, INPUT_CTL_PATH1);
+	mxc_iomux_set_input(MX51_FEC_FEC_RDATA_3_SELECT_INPUT, INPUT_CTL_PATH1);
+	mxc_iomux_set_input(MX51_FEC_FEC_RX_CLK_SELECT_INPUT, INPUT_CTL_PATH1);
+	mxc_iomux_set_input(MX51_FEC_FEC_RX_DV_SELECT_INPUT, INPUT_CTL_PATH1);
+	mxc_iomux_set_input(MX51_FEC_FEC_RX_ER_SELECT_INPUT, INPUT_CTL_PATH1);
+	mxc_iomux_set_input(MX51_FEC_FEC_TX_CLK_SELECT_INPUT, INPUT_CTL_PATH1);
+
+	/* Ethernet PHY leave Reset state (POR only) */
+	gpio_set_value(CONFIG_SYS_PHY_RESET_GPIO, 1);
+	gpio_direction_output(CONFIG_SYS_PHY_RESET_GPIO, 1);
+#endif
+}
+
+#ifdef CONFIG_FSL_ESDHC
+
+struct fsl_esdhc_cfg esdhc_cfg[2] = {
+	{MMC_SDHC1_BASE_ADDR},
+	{MMC_SDHC2_BASE_ADDR},
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+	if (cfg->esdhc_base == MMC_SDHC1_BASE_ADDR)
+		ret = !gpio_get_value(IMX_GPIO_NR(2, 29));
+	return ret;
+}
+
+#define SD_PAD_CFG		(PAD_CTL_DRV_MAX | PAD_CTL_DRV_VOT_HIGH | \
+				 PAD_CTL_HYS_ENABLE | PAD_CTL_47K_PU |	\
+				 PAD_CTL_PUE_PULL | PAD_CTL_PKE_ENABLE | \
+				 PAD_CTL_SRE_FAST)
+int board_mmc_init(bd_t *bis)
+{
+	s32 status = 0;
+	int esdh_addr = CONFIG_SYS_FSL_ESDHC_ADDR;
+
+	switch (esdh_addr) {
+	case MMC_SDHC1_BASE_ADDR:
+
+		/* SD1_CD */
+		imx_iomux_v3_setup_pad(MX51_PAD_EIM_CS4__GPIO2_29);
+		gpio_direction_input(IMX_GPIO_NR(2, 29));
+
+		/* SD1_CMD */
+		mxc_request_iomux(MX51_PIN_SD1_CMD, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD1_CMD, SD_PAD_CFG);
+
+		/* SD1_CLK */
+		mxc_request_iomux(MX51_PIN_SD1_CLK, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD1_CLK, PAD_CTL_DRV_MAX |
+			PAD_CTL_DRV_VOT_HIGH | PAD_CTL_HYS_NONE |
+			PAD_CTL_47K_PU | PAD_CTL_PUE_PULL |
+			PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
+
+		/* SD1_DATA0 */
+		mxc_request_iomux(MX51_PIN_SD1_DATA0, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD1_DATA0, SD_PAD_CFG);
+
+		/* SD1_DATA1 */
+		mxc_request_iomux(MX51_PIN_SD1_DATA1, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD1_DATA1, SD_PAD_CFG);
+
+		/* SD1_DATA2 */
+		mxc_request_iomux(MX51_PIN_SD1_DATA2, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD1_DATA2, SD_PAD_CFG);
+
+		/* SD1_DATA3 */
+		mxc_request_iomux(MX51_PIN_SD1_DATA3, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD1_DATA3, SD_PAD_CFG);
+
+		esdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+		status = fsl_esdhc_initialize(bis, &esdhc_cfg[0]);
+		break;
+	case MMC_SDHC2_BASE_ADDR:
+/*
+		mxc_request_iomux(MX51_PIN_GPIO1_0, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_GPIO1_0, SD_PAD_CFG);
+*/
+		/* SD2_CMD */
+		mxc_request_iomux(MX51_PIN_SD2_CMD, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD2_CMD, SD_PAD_CFG);
+
+		/* SD2_CLK */
+		mxc_request_iomux(MX51_PIN_SD2_CLK, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD2_CLK, PAD_CTL_DRV_MAX |
+			PAD_CTL_DRV_VOT_HIGH | PAD_CTL_HYS_NONE |
+			PAD_CTL_47K_PU | PAD_CTL_PUE_PULL |
+			PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
+
+		/* SD2_DATA0 */
+		mxc_request_iomux(MX51_PIN_SD2_DATA0, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD2_DATA0, SD_PAD_CFG);
+
+		/* SD2_DATA1 */
+		mxc_request_iomux(MX51_PIN_SD2_DATA1, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD2_DATA1, SD_PAD_CFG);
+
+		/* SD2_DATA2 */
+		mxc_request_iomux(MX51_PIN_SD2_DATA2, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD2_DATA2, SD_PAD_CFG);
+
+		/* SD2_DATA3 */
+		mxc_request_iomux(MX51_PIN_SD2_DATA3, IOMUX_CONFIG_ALT0 |
+			IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD2_DATA3, SD_PAD_CFG);
+
+		esdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+		status = fsl_esdhc_initialize(bis, &esdhc_cfg[1]);
+		break;
+	default:
+		printf("*** ERROR: SD/MMC interface %d not supported\n",
+		       esdh_addr);
+		status = 1;
+		break;
+	}
+
+	return status;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)MXC_CCM_BASE;
+	struct src *src = (struct src *)SRC_BASE_ADDR;
+
+	/* Increase freq to APF_ARM_CLK (800MHz) */
+	writel((ACFG_PLL1_CLK / APF_ARM_CLK) - 1, &mxc_ccm->cacrr);
+
+	/* Disable warm reset */
+	writel(0x560, &src->scr);
+
+	setup_misc();
+	setup_uart();
+	setup_spi_io();
+	setup_nfc();
+	setup_fec();
+#ifdef CONFIG_I2C_MXC
+	setup_i2c(I2C2_BASE_ADDR);
+#endif
+	setup_display();
+	setup_usb();
+	setup_audio();
+	setup_eim();
+	setup_csi();
+	setup_keypad();
+#ifdef CONFIG_FPGA
+	setup_fpga();
+#endif
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = CSD0_BASE_ADDR + 0x100;
+
+#ifdef CONFIG_I2C_MXC
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+#endif
+
+#if defined(CONFIG_FPGA)
+	APF51_init_fpga();
+#endif
+	return 0;
+}
+
+int checkboard(void)
+{
+	printf("Board: Armadeus APF51 revision %d\n", get_board_rev());
+	return 0;
+}
+
+/*void enable_caches(void)
+{
+#ifndef CONFIG_SYS_DCACHE_OFF
+
+	dcache_enable();
+#endif
+}*/
+
+#ifndef CONFIG_L2_OFF
+void v7_outer_cache_enable(void)
+{
+	asm("mrc 15, 0, r0, c1, c0, 1");
+	asm("orr r0, r0, #0x2");
+	asm("mcr 15, 0, r0, c1, c0, 1");
+}
+
+void v7_outer_cache_disable(void)
+{
+	asm("mrc 15, 0, r0, c1, c0, 1");
+	asm("bic r0, r0, #0x2");
+	asm("mcr 15, 0, r0, c1, c0, 1");
+}
+#endif
+
+#if defined(CONFIG_CMD_BSP)
+/*
+ * display dcd table. to delete
+ */
+int do_mx51_show_dcd_tab(cmd_tbl_t *cmdtp, int flag, int argc,
+				char *const argv[])
+{
+	ulong i = 1;
+	struct esdctl_regs *esdctl = (struct esdctl_regs *)ESDCTL_BASE_ADDR;
+	char dcd_item[] = "MXC_DCD_ITEM(%ld, %ld, %#010lX, %#010lX)\n";
+
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_RAS),
+	       ACFG_IOMUX_PAD_DRAM_RAS);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_CAS),
+	       ACFG_IOMUX_PAD_DRAM_CAS);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_SDWE),
+	       ACFG_IOMUX_PAD_DRAM_SDWE);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_SDCKE0),
+	       ACFG_IOMUX_PAD_DRAM_SDCKE0);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_SDCKE1),
+	       ACFG_IOMUX_PAD_DRAM_SDCKE1);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_SDCLK),
+	       ACFG_IOMUX_PAD_DRAM_SDCLK);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_SDQS0),
+	       ACFG_IOMUX_PAD_DRAM_SDQS0);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_SDQS1),
+	       ACFG_IOMUX_PAD_DRAM_SDQS1);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_SDQS2),
+	       ACFG_IOMUX_PAD_DRAM_SDQS2);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_SDQS3),
+	       ACFG_IOMUX_PAD_DRAM_SDQS3);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_CS0),
+	       ACFG_IOMUX_PAD_DRAM_CS0);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_CS1),
+	       ACFG_IOMUX_PAD_DRAM_CS1);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_DQM0),
+	       ACFG_IOMUX_PAD_DRAM_DQM0);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_DQM1),
+	       ACFG_IOMUX_PAD_DRAM_DQM1);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_DQM2),
+	       ACFG_IOMUX_PAD_DRAM_DQM2);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_DRAM_DQM3),
+	       ACFG_IOMUX_PAD_DRAM_DQM3);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+				PIN_TO_IOMUX_PAD(MX51_PIN_CTL_PAD_EIM_SDBA2),
+				ACFG_IOMUX_PAD_EIM_SDBA2);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+				PIN_TO_IOMUX_PAD(MX51_PIN_CTL_PAD_EIM_SDODT1),
+				ACFG_IOMUX_PAD_EIM_SDODT1);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+				PIN_TO_IOMUX_PAD(MX51_PIN_CTL_PAD_EIM_SDODT0),
+				ACFG_IOMUX_PAD_EIM_SDODT0);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDRPKS),
+	       ACFG_IOMUX_GRP_DDRPKS);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DRAM_B4),
+	       ACFG_IOMUX_GRP_DRAM_B4);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+				PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_INDDR),
+				ACFG_IOMUX_GRP_INDDR);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_PKEDDR),
+	       ACFG_IOMUX_GRP_PKEDDR);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDR_A0),
+	       ACFG_IOMUX_GRP_DDR_A0);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDR_A1),
+	       ACFG_IOMUX_GRP_DDR_A1);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+				PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDRAPUS),
+				ACFG_IOMUX_GRP_DDRAPUS);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+				PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_HYSDDR0),
+				ACFG_IOMUX_GRP_HYSDDR0);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+				PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_HYSDDR1),
+				ACFG_IOMUX_GRP_HYSDDR1);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+				PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_HYSDDR2),
+				ACFG_IOMUX_GRP_HYSDDR2);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+				PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_HVDDR),
+				ACFG_IOMUX_GRP_HVDDR);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+				PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_HYSDDR3),
+				ACFG_IOMUX_GRP_HYSDDR3);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDR_SR_B0),
+	       ACFG_IOMUX_GRP_DDR_SR_B0);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDRAPKS),
+	       ACFG_IOMUX_GRP_DDRAPKS);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDR_SR_B1),
+	       ACFG_IOMUX_GRP_DDR_SR_B1);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDRPUS),
+	       ACFG_IOMUX_GRP_DDRPUS);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDR_SR_B2),
+	       ACFG_IOMUX_GRP_DDR_SR_B2);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_PKEADDR),
+	       ACFG_IOMUX_GRP_PKEADDR);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDR_SR_B4),
+	       ACFG_IOMUX_GRP_DDR_SR_B4);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+		PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_INMODE1),
+		ACFG_IOMUX_GRP_INMODE1);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+		PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DRAM_B0),
+		ACFG_IOMUX_GRP_DRAM_B0);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DRAM_B1),
+	       ACFG_IOMUX_GRP_DRAM_B1);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDR_SR_A0),
+	       ACFG_IOMUX_GRP_DDR_SR_A0);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DRAM_B2),
+	       ACFG_IOMUX_GRP_DRAM_B2);
+	printf(dcd_item, i++, 4, IOMUXC_BASE_ADDR + PAD_I_START +
+	       PIN_TO_IOMUX_PAD(MX51_PIN_CTL_GRP_DDR_SR_A1),
+	       ACFG_IOMUX_GRP_DDR_SR_A1);
+
+	printf(dcd_item, i++, 4, &esdctl->esdctl0,
+	       (ACFG_SDRAM_ESDCTL_REGISTER_VAL & 0x8FFFFFFF));
+	printf(dcd_item, i++, 4, &esdctl->esdscr, DRR_PRECHARGE_CMD(0, 0));
+	printf(dcd_item, i++, 4, &esdctl->esdscr, DRR_AUTOREFRESH_CMD(0));
+	printf(dcd_item, i++, 4, &esdctl->esdscr, DRR_AUTOREFRESH_CMD(0));
+	printf(dcd_item, i++, 4, &esdctl->esdscr,
+	       DRR_LMR_CMD(0, 0, ACFG_DRR_MR_VAL));
+	printf(dcd_item, i++, 4, &esdctl->esdscr,
+	       DRR_LMR_CMD(0, 2, ACFG_DRR_EMR_VAL));
+	printf(dcd_item, i++, 4, &esdctl->esdscr, DDR_NOP_CMD(0));
+	printf(dcd_item, i++, 4, &esdctl->esdctl0,
+	       ACFG_SDRAM_ESDCTL_REGISTER_VAL);
+	printf(dcd_item, i++, 4, &esdctl->esdcfg0,
+	       ACFG_SDRAM_ESDCFG_REGISTER_VAL);
+
+	printf(dcd_item, i++, 4, &esdctl->esdctl1,
+	       (ACFG_SDRAM_ESDCTL_REGISTER_VAL & 0x8FFFFFFF));
+	printf(dcd_item, i++, 4, &esdctl->esdscr, DRR_PRECHARGE_CMD(1, 0));
+	printf(dcd_item, i++, 4, &esdctl->esdscr, DRR_AUTOREFRESH_CMD(1));
+	printf(dcd_item, i++, 4, &esdctl->esdscr, DRR_AUTOREFRESH_CMD(1));
+	printf(dcd_item, i++, 4, &esdctl->esdscr,
+	       DRR_LMR_CMD(1, 0, ACFG_DRR_MR_VAL));
+	printf(dcd_item, i++, 4, &esdctl->esdscr,
+	       DRR_LMR_CMD(1, 2, ACFG_DRR_EMR_VAL));
+	printf(dcd_item, i++, 4, &esdctl->esdscr, DDR_NOP_CMD(1));
+	printf(dcd_item, i++, 4, &esdctl->esdctl1,
+	       ACFG_SDRAM_ESDCTL_REGISTER_VAL);
+	printf(dcd_item, i++, 4, &esdctl->esdcfg1,
+	       ACFG_SDRAM_ESDCFG_REGISTER_VAL);
+
+	printf(dcd_item, i++, 4, &esdctl->esdmisc,
+	       ACFG_SDRAM_ESDMISC_REGISTER_VAL);
+	printf(dcd_item, i++, 4, &esdctl->esdscr, 0x00000000);
+
+	printf(dcd_item, i++, 4, &esdctl->esdgpr,
+	       ACFG_SDRAM_ESDGPR_REGISTER_VAL);
+	printf(dcd_item, i++, 4, &esdctl->esdcdly1,
+	       ACFG_SDRAM_ESDCDLY1_REGISTER_VAL);
+	printf(dcd_item, i++, 4, &esdctl->esdcdly2,
+	       ACFG_SDRAM_ESDCDLY2_REGISTER_VAL);
+	printf(dcd_item, i++, 4, &esdctl->esdcdly3,
+	       ACFG_SDRAM_ESDCDLY3_REGISTER_VAL);
+	printf(dcd_item, i++, 4, &esdctl->esdcdly4,
+	       ACFG_SDRAM_ESDCDLY4_REGISTER_VAL);
+	printf(dcd_item, i++, 4, &esdctl->esdcdly5,
+	       ACFG_SDRAM_ESDCDLY5_REGISTER_VAL);
+
+	return 0;
+}
+
+/***************************************************/
+
+U_BOOT_CMD(dcdshow, 1, 1, do_mx51_show_dcd_tab,
+		"display mx51 dcd tab\n", "");
+#endif /* CONFIG_CMD_BSP */
diff --git a/board/armadeus/apf51/fpga.c b/board/armadeus/apf51/fpga.c
new file mode 100644
index 0000000..665928e
--- /dev/null
+++ b/board/armadeus/apf51/fpga.c
@@ -0,0 +1,257 @@
+/*
+ * (C) Copyright 2002-2010
+ * Nicolas Colombain <nicolas.colombain@armadeus.com>
+ * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
+ * Keith Outwater, keith_outwater@mvis.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+#include <common.h>
+
+#if defined(CONFIG_FPGA)
+
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/gpio.h>
+#include <generated/asm-offsets.h>
+#include <asm/io.h>
+#include <command.h>
+#include <config.h>
+#include <asm/arch/iomux.h>
+#include "fpga.h"
+#include <spartan3.h>
+
+#ifdef FPGA_DEBUG
+#define		PRINTF(fmt, args...)	printf(fmt , ##args)
+#else
+#define		PRINTF(fmt, args...)
+#endif
+
+static u32 temp_clk;		/* use to restore the emi_clk_sel after donwload */
+static u32 temp_rcr1;
+static u32 temp_wcr1;
+static u32 temp_data;
+static u32 temp_index;
+
+/* Note that these are pointers to code that is in Flash.  They will be
+ * relocated at runtime.
+ * Spartan2 code is used to download our Spartan 6 :) code is compatible.
+ * Just take care about the file size
+*/
+Xilinx_Spartan3_Slave_Parallel_fns fpga_fns = {
+	fpga_pre_fn,
+	fpga_pgm_fn,
+	fpga_init_fn,
+	NULL,
+	fpga_done_fn,
+	fpga_clk_fn,
+	fpga_cs_fn,
+	fpga_wr_fn,
+	fpga_rdata_fn,
+	fpga_wdata_fn,
+	fpga_busy_fn,
+	fpga_abort_fn,
+	fpga_post_fn,
+};
+
+Xilinx_desc fpga[CONFIG_FPGA_COUNT] = {
+	{Xilinx_Spartan3,
+	 slave_parallel,
+	 3713568l / 8,
+	 (void *)&fpga_fns,
+	 0}
+};
+
+/*
+ *
+ */
+int fpga_pre_fn(int cookie)
+{
+#define EMI_CLK_SEL		1<<26
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)MXC_CCM_BASE;
+	struct weim *weim = (struct weim *)WEIM_BASE_ADDR;
+
+	temp_index = 0;
+	temp_rcr1 = readl(&weim->cs1rcr1);
+	writel(0x01000010, &weim->cs1rcr1);
+	temp_wcr1 = readl(&weim->cs1wcr1);
+	writel(0x01000008, &weim->cs1wcr1);
+
+	/* change emi_clk_sel to ensure blck smaller than 50MHz */
+	temp_clk = readl(&mxc_ccm->cbcdr);
+	writel(temp_clk | EMI_CLK_SEL, &mxc_ccm->cbcdr);
+
+	/* FPGA PROG */
+	gpio_set_value(IOMUX_TO_GPIO(ACFG_FPGA_PRG), 1);
+	gpio_direction_output(IOMUX_TO_GPIO(ACFG_FPGA_PRG), 1);
+
+	/* FPGA SUSPEND */
+	gpio_set_value(IOMUX_TO_GPIO(ACFG_FPGA_SUSPEND), 1);
+	gpio_direction_output(IOMUX_TO_GPIO(ACFG_FPGA_SUSPEND), 1);
+
+	/* FPGA DONE */
+	gpio_direction_input(IOMUX_TO_GPIO(ACFG_FPGA_DONE));
+
+	/* FPGA INIT# */
+	gpio_direction_input(IOMUX_TO_GPIO(ACFG_FPGA_INIT));
+
+	/* FPGA PWR */
+	gpio_set_value(IOMUX_TO_GPIO(ACFG_FPGA_PWR), 1);
+	gpio_direction_output(IOMUX_TO_GPIO(ACFG_FPGA_PWR), 1);
+
+	PRINTF("FPGA power enabled\n");
+
+	return cookie;
+}
+
+/*
+ * Set the FPGA's active-low program line to the specified level
+ */
+int fpga_pgm_fn(int assert, int flush, int cookie)
+{
+	PRINTF("%s:%d: FPGA PROGRAM %s\n", __func__, __LINE__,
+		assert ? "high" : "low");
+	gpio_set_value(IOMUX_TO_GPIO(ACFG_FPGA_PRG), !assert);
+	return assert;
+}
+
+/*
+ * Set the FPGA's active-high clock line to the specified level
+ */
+int fpga_clk_fn(int assert_clk, int flush, int cookie)
+{
+	return assert_clk;
+}
+
+/*
+ * Test the state of the active-low FPGA INIT line.  Return 1 on INIT
+ * asserted (low).
+ */
+int fpga_init_fn(int cookie)
+{
+	int value;
+	PRINTF("%s:%d: INIT check...\n", __func__, __LINE__);
+	value = gpio_get_value(IOMUX_TO_GPIO(ACFG_FPGA_INIT));
+	PRINTF("init value read %x\n", value);
+	if (value)
+		return 0;
+	return 1;
+}
+
+/*
+ * Test the state of the active-high FPGA DONE pin
+ */
+int fpga_done_fn(int cookie)
+{
+	int value;
+	value = gpio_get_value(IOMUX_TO_GPIO(ACFG_FPGA_DONE));
+	PRINTF("%s:%d: DONE check... %s", __func__, __LINE__,
+	       value ? "high" : "low");
+	return value ? FPGA_SUCCESS : FPGA_FAIL;
+}
+
+/*
+ * Set the FPGA's wr line to the specified level
+ */
+int fpga_wr_fn(int assert_write, int flush, int cookie)
+{
+	return assert_write;
+}
+
+int fpga_cs_fn(int assert_cs, int flush, int cookie)
+{
+	return assert_cs;
+}
+
+int fpga_rdata_fn(unsigned char *data, int cookie)
+{
+	PRINTF("%s:%d: FPGA READ DATA %02X\n", __func__, __LINE__,
+	       *((char *)ACFG_FPGA_RDATA));
+	*data =
+	    (unsigned char)((*((unsigned short *)ACFG_FPGA_RDATA)) &
+			    0x00FF);
+	return *data;
+}
+
+int fpga_wdata_fn(unsigned char data, int flush, int cookie)
+{
+	PRINTF("%s:%d: FPGA WRITE DATA %02X\n", __func__, __LINE__, data);
+
+	switch (temp_index++) {
+	case 0:
+		temp_data = data << 8;
+		break;
+	case 1:
+		temp_data = temp_data + data;
+		break;
+	case 2:
+		temp_data = temp_data + (data << 24);
+		break;
+	default:
+		*((unsigned long *)ACFG_FPGA_WDATA) = temp_data + (data << 16);
+		temp_index = 0;
+		break;
+	}
+
+	return data;
+}
+
+int fpga_abort_fn(int cookie)
+{
+	return fpga_post_fn(cookie);
+}
+
+int fpga_busy_fn(int cookie)
+{
+	return 1;
+}
+
+int fpga_post_fn(int cookie)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)MXC_CCM_BASE;
+	struct weim *weim = (struct weim *)WEIM_BASE_ADDR;
+	PRINTF("%s:%d: FPGA POST\n", __func__, __LINE__);
+	/* restore emi_clk_sel */
+	writel(temp_clk, &mxc_ccm->cbcdr);
+	udelay(10);		/* wait a few us after emi_clk_sel change */
+	writel(temp_rcr1, &weim->cs1rcr1);
+	writel(temp_wcr1, &weim->cs1wcr1);
+
+	return cookie;
+}
+
+/*
+ * Initialize the fpga.  Return 1 on success, 0 on failure.
+ */
+int APF51_init_fpga(void)
+{
+	int i;
+
+	fpga_init();
+
+	for (i = 0; i < CONFIG_FPGA_COUNT; i++) {
+		PRINTF("%s:%d: Adding fpga %d\n", __func__, __LINE__, i);
+		fpga_add(fpga_xilinx, &fpga[i]);
+	}
+
+	return 0;
+}
+
+#endif /* CONFIG_FPGA */
diff --git a/board/armadeus/apf51/fpga.h b/board/armadeus/apf51/fpga.h
new file mode 100644
index 0000000..f22f4d8
--- /dev/null
+++ b/board/armadeus/apf51/fpga.h
@@ -0,0 +1,39 @@
+/*
+ * (C) Copyright 2002-2010
+ * Eric Jarrige <eric.jarrige@armadeus.org>
+ * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
+ * Keith Outwater, keith_outwater@mvis.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+extern int APF51_init_fpga(void);
+
+extern int fpga_pre_fn(int cookie);
+extern int fpga_pgm_fn(int assert_pgm, int flush, int cookie);
+extern int fpga_cs_fn(int assert_cs, int flush, int cookie);
+extern int fpga_init_fn(int cookie);
+extern int fpga_done_fn(int cookie);
+extern int fpga_clk_fn(int assert_clk, int flush, int cookie);
+extern int fpga_wr_fn(int assert_write, int flush, int cookie);
+extern int fpga_rdata_fn(unsigned char *data, int cookie);
+extern int fpga_wdata_fn(unsigned char data, int flush, int cookie);
+extern int fpga_abort_fn(int cookie);
+extern int fpga_post_fn(int cookie);
+extern int fpga_busy_fn(int cookie);
diff --git a/boards.cfg b/boards.cfg
index 9df6212..1aa7e95 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -241,6 +241,7 @@ am335x_evm                   arm         armv7       am335x              ti
 highbank                     arm         armv7       highbank            -              highbank
 mx51_efikamx                 arm         armv7       mx51_efikamx        genesi         mx5		mx51_efikamx:MACH_TYPE=MACH_TYPE_MX51_EFIKAMX,IMX_CONFIG=board/genesi/mx51_efikamx/imximage_mx.cfg
 mx51_efikasb                 arm         armv7       mx51_efikamx        genesi         mx5		mx51_efikamx:MACH_TYPE=MACH_TYPE_MX51_EFIKASB,IMX_CONFIG=board/genesi/mx51_efikamx/imximage_sb.cfg
+apf51                        arm         armv7       apf51               armadeus       mx5		apf51:IMX_CONFIG=board/armadeus/apf51/imximage.cfg
 mx51evk                      arm         armv7       mx51evk             freescale      mx5		mx51evk:IMX_CONFIG=board/freescale/mx51evk/imximage.cfg
 mx53ard                      arm         armv7       mx53ard             freescale      mx5		mx53ard:IMX_CONFIG=board/freescale/mx53ard/imximage_dd3.cfg
 mx53evk                      arm         armv7       mx53evk             freescale      mx5		mx53evk:IMX_CONFIG=board/freescale/mx53evk/imximage.cfg
-- 
1.7.2.5

