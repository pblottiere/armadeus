---------------------------------------------------------------------------
-- Company     : Automaticaly generated by POD
-- Author(s)   : 
-- 
-- Creation Date : 2009-03-03
-- File          : Top_wishbone_example_tb.vhd
--
-- Abstract : 
-- insert a description here
--
---------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.all;

-- 
--                 Defines communication functions between imx and fpga:
--     
--                 write procedures
--                 procedure imx_write
--                 Params :
--                    address      : Write address 
--                    value        : value to write 
--                    gls_clk      : clock signal
--                    imx_cs_n     : Chip select 
--                    imx_oe_n     : Read signal
--                    imx_eb3_n    : Write signal
--                    imx_address  : Address signal
--                    imx_data     : Data signal
--                    WSC          : Value of imx WSC (see MC9328MXLRM.pdf p169) for sync=0
--     
--                 read procedures
--                 procedure imx_read
--                 Params :
--                    address      : Write address 
--                    value        : value returned
--                    gls_clk      : clock signal
--                    imx_cs_n     : Chip select 
--                    imx_oe_n     : Read signal
--                    imx_eb3_n    : Write signal
--                    imx_address  : Address signal
--                    imx_data     : Data signal
--                    WSC          : Value of imx WSC (see MC9328MXLRM.pdf p169) for sync=0
--                 
use work.apf_test_pkg.all;

entity top_wishbone_example_tb is
end entity top_wishbone_example_tb;

architecture RTL of top_wishbone_example_tb is

    CONSTANT HALF_PERIODE : time := 5.20833333333 ns;  -- Half clock period
    CONSTANT IRQ_MASK : std_logic_vector := x"0000";
    CONSTANT IRQ_PEND : std_logic_vector := x"0002";
    CONSTANT IRQ_MNGR00_ID : std_logic_vector := x"0004";
    CONSTANT LED_REG : std_logic_vector := x"0008";
    CONSTANT LED0_ID : std_logic_vector := x"000a";
    CONSTANT BUTTON0_ID : std_logic_vector := x"000c";
    CONSTANT BUTTON_REG : std_logic_vector := x"000e";
    signal  imx_data :  std_logic_vector(15 downto 0);
    signal  imx_address :  std_logic_vector(11 downto 0);
    signal  ext_clk :  std_logic;
    signal  imx_cs_n :  std_logic;
    signal  imx_eb3_n :  std_logic;
    signal  imx_oe_n :  std_logic;
    signal  gls_irq :  std_logic;
    signal  led_o    :  std_logic;
    signal  button_i :  std_logic;

    component top_wishbone_example
    port (        
        imx_data    : inout std_logic_vector(15 downto 0);
        imx_address : in std_logic_vector(11 downto 0);
        ext_clk     : in std_logic;
        imx_cs_n    : in std_logic;
        imx_eb3_n   : in std_logic;
        imx_oe_n    : in std_logic;
        gls_irq     : out std_logic;
        led_o       : out std_logic;
        button_i    : in std_logic
    );
    end component top_wishbone_example;

    signal value : std_logic_vector (15 downto 0);

begin

    top : top_wishbone_example
    port map(
        imx_data => imx_data,
        imx_address => imx_address,
        ext_clk => ext_clk,
        imx_cs_n => imx_cs_n,
        imx_eb3_n => imx_eb3_n,
        imx_oe_n => imx_oe_n,
        gls_irq => gls_irq,
        led_o => led_o,
        button_i => button_i
    );

     -- test read/write
    stimulus : process
    begin
        imx_oe_n <= '1';
        imx_eb3_n <= '1';
        imx_cs_n <= '1';
        imx_address <= (others => 'Z');
        imx_data  <= (others => 'Z');
        button_i <= '0';

        wait for HALF_PERIODE*10;

        -- reset irq_pend
        imx_write(IRQ_PEND,x"0000",
        ext_clk,imx_cs_n,
        imx_oe_n, imx_eb3_n,
        imx_address(11 downto 0),imx_data,
        4);
        -- write on irq_mask
        imx_write(IRQ_MASK,x"ffff",
        ext_clk,imx_cs_n,
        imx_oe_n, imx_eb3_n,
        imx_address(11 downto 0),imx_data,
        4);
        -- read led value
        imx_read(LED_REG,value,
        ext_clk,imx_cs_n,
        imx_oe_n, imx_eb3_n,
        imx_address(11 downto 0),imx_data,
        4);
        assert value(0) = '0' report "Wrong led value" severity error;

        -- push button
        button_i <= '1';
        wait for HALF_PERIODE*20;
        assert gls_irq = '1' report "IRQ not raised" severity error;
        -- read button value
        imx_read(BUTTON_REG,value,
        ext_clk,imx_cs_n,
        imx_oe_n, imx_eb3_n,
        imx_address(11 downto 0),imx_data,
        4);
        assert value(0) = '1' report  "Failed to read button" severity error;

        -- Read irq pending
        imx_read(IRQ_PEND,value,
        ext_clk,imx_cs_n,
        imx_oe_n, imx_eb3_n,
        imx_address(11 downto 0),imx_data,
        4);
        assert value(0) = '1' report "IRQ pending error" severity error;
        -- Acknowledge irq
        imx_write(IRQ_PEND,x"ffff",
        ext_clk,imx_cs_n,
        imx_oe_n, imx_eb3_n,
        imx_address(11 downto 0),imx_data,
        4);
        imx_read(IRQ_PEND,value,
        ext_clk,imx_cs_n,
        imx_oe_n, imx_eb3_n,
        imx_address(11 downto 0),imx_data,
        4);
        assert value(0) = '0' report "Acknowledge error" severity error;

        -- release button_i
        button_i <= '0';
        wait for HALF_PERIODE*20;
        -- Acknowledge irq
        imx_write(IRQ_PEND,x"ffff",
        ext_clk,imx_cs_n,
        imx_oe_n, imx_eb3_n,
        imx_address(11 downto 0),imx_data,
        4);
        imx_read(IRQ_PEND,value,
        ext_clk,imx_cs_n,
        imx_oe_n, imx_eb3_n,
        imx_address(11 downto 0),imx_data,
        4);
        --read button value
        imx_read(BUTTON_REG,value,
        ext_clk,imx_cs_n,
        imx_oe_n, imx_eb3_n,
        imx_address(11 downto 0),imx_data,
        4);
        assert value(0) = '0' report "Low read button error" severity error;

        wait for HALF_PERIODE*10;
        assert false report "End of test" severity error;
    end process stimulus;        

   
    clockp : process
    begin
        ext_clk <= '1';
        wait for HALF_PERIODE;
        ext_clk <= '0';
        wait for HALF_PERIODE;
    end process clockp;

end architecture RTL;

